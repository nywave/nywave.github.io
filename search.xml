<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面经-C++11新标准</title>
    <url>/2023/07/15/C++11%E6%96%B0%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h1 id="C-11新标准"><a href="#C-11新标准" class="headerlink" title="C++11新标准"></a>C++11新标准</h1><h2 id="1、C-11有哪些新特性？"><a href="#1、C-11有哪些新特性？" class="headerlink" title="1、C++ 11有哪些新特性？"></a>1、C++ 11有哪些新特性？</h2><ul>
<li><p>nullptr替代 NULL</p>
</li>
<li><p>引入了 auto 和 decltype 这两个关键字实现了类型推导</p>
</li>
<li><p>基于范围的 for 循环for(auto&amp; i : res){}</p>
</li>
<li><p>类和结构体的中初始化列表</p>
</li>
<li><p>Lambda 表达式（匿名函数）</p>
</li>
<li><p>std::forward_list（单向链表）</p>
</li>
<li><p>右值引用和move语义</p>
</li>
<li><p>…</p>
</li>
</ul>
<h2 id="2、auto、decltype和decltype-auto-的用法"><a href="#2、auto、decltype和decltype-auto-的用法" class="headerlink" title="2、auto、decltype和decltype(auto)的用法"></a>2、auto、decltype和decltype(auto)的用法</h2><p><strong>（1）auto</strong></p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p><strong>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。</strong></p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以k的类型是const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>（2）decltype</strong></p>
<p>有的时候我们还会遇到这种情况，<strong>我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。</strong>还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，<strong>它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>（3）decltype(auto)</strong></p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“&#x3D;”号右边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="3、C-中NULL和nullptr区别"><a href="#3、C-中NULL和nullptr区别" class="headerlink" title="3、C++中NULL和nullptr区别"></a>3、C++中NULL和nullptr区别</h2><p>算是为了与C语言进行兼容而定义的一个问题吧</p>
<p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。</p>
<p>在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fun</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>那么<strong>在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</strong></p>
<p>nullptr的一种实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">nullptr_t</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，<strong>另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。</strong>但nullptr仍然存在一定问题，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;char* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;int* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt; <span class="string">&quot;int p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>((<span class="type">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line">	<span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h2 id="4、智能指针的原理、常用的智能指针及实现"><a href="#4、智能指针的原理、常用的智能指针及实现" class="headerlink" title="4、智能指针的原理、常用的智能指针及实现"></a>4、智能指针的原理、常用的智能指针及实现</h2><p><strong>原理</strong></p>
<p>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p>
<p><strong>常用的智能指针</strong></p>
<p><strong>(1) shared_ptr</strong></p>
<p>实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。</p>
<ul>
<li>智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针</li>
<li>每次创建类的新对象时，初始化指针并将引用计数置为1</li>
<li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数</li>
<li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li>
<li>调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）</li>
</ul>
<p><strong>(2) unique_ptr</strong></p>
<p>unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。</p>
<p><strong>(3) weak_ptr</strong></p>
<p>weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。</p>
<p><strong>(4) auto_ptr</strong></p>
<p>主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。</p>
<p>auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而unique_ptr则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用std::move()进行转移。</p>
<p>auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。</p>
<p><strong>智能指针shared_ptr代码实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SharedPtr</span>(T* ptr = <span class="literal">NULL</span>):_ptr(ptr), _pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">	&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;</span><br><span class="line">		(*_pcount)++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&amp; s)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (--(*(<span class="keyword">this</span>-&gt;_pcount)) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_pcount;</span><br><span class="line">			&#125;</span><br><span class="line">			_ptr = s._ptr;</span><br><span class="line">			_pcount = s._pcount;</span><br><span class="line">			*(_pcount)++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">SharedPtr</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		--(*(<span class="keyword">this</span>-&gt;_pcount));</span><br><span class="line">		<span class="keyword">if</span> (*(<span class="keyword">this</span>-&gt;_pcount) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> _ptr;</span><br><span class="line">			_ptr = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">delete</span> _pcount;</span><br><span class="line">			_pcount = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* _ptr;</span><br><span class="line">	<span class="type">int</span>* _pcount;<span class="comment">//指向引用计数的指针</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="5、说一说你了解的关于lambda函数的全部知识"><a href="#5、说一说你了解的关于lambda函数的全部知识" class="headerlink" title="5、说一说你了解的关于lambda函数的全部知识"></a>5、说一说你了解的关于lambda函数的全部知识</h2><ol>
<li><p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p>
</li>
<li><p>每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p>
</li>
<li><p>lambda表达式的语法定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
</li>
</ol>
<h2 id="6、智能指针的作用"><a href="#6、智能指针的作用" class="headerlink" title="6、智能指针的作用"></a>6、智能指针的作用</h2><ol>
<li>C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</li>
<li>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、weak_ptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</li>
<li>初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 &#x3D; new int(1);的写法是错误的</li>
</ol>
<p>拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</p>
<ol>
<li>unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</li>
<li>智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</li>
<li>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.</li>
</ol>
<h2 id="7、说说你了解的auto-ptr作用"><a href="#7、说说你了解的auto-ptr作用" class="headerlink" title="7、说说你了解的auto_ptr作用"></a>7、说说你了解的auto_ptr作用</h2><ol>
<li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li>
<li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li>
<li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li>
<li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li>
<li>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li>
<li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li>
<li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li>
<li>T* get(),获得auto_ptr所拥有的指针；T* release()，释放auto_ptr的所有权，并将所有用的指针返回。</li>
</ol>
<h2 id="8、智能指针的循环引用"><a href="#8、智能指针的循环引用" class="headerlink" title="8、智能指针的循环引用"></a>8、智能指针的循环引用</h2><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">		:_pPre(<span class="literal">NULL</span>)</span><br><span class="line">		, _pNext(<span class="literal">NULL</span>)</span><br><span class="line">		, _value(value)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">	shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">	T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	sp1-&gt;_pNext = sp2; <span class="comment">//sp2的引用+1</span></span><br><span class="line">	sp2-&gt;_pPre = sp1; <span class="comment">//sp1的引用+1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Funtest</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//sp1.use_count:1</span></span><br><span class="line"><span class="comment">//sp2.use_count:1</span></span><br><span class="line"><span class="comment">//sp1.use_count:2</span></span><br><span class="line"><span class="comment">//sp2.use_count:2</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</p>
<p>在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p>
<h2 id="9、手写实现智能指针类需要实现哪些函数？"><a href="#9、手写实现智能指针类需要实现哪些函数？" class="headerlink" title="9、手写实现智能指针类需要实现哪些函数？"></a>9、手写实现智能指针类需要实现哪些函数？</h2><ol>
<li><p>智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录SmartPointer&lt;T*&gt;对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象。</p>
<p>除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。</p>
<p>通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减1，新的引用计数加1</p>
</li>
<li><p>一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；</p>
</li>
</ol>
<h2 id="10、智能指针出现循环引用怎么解决？"><a href="#10、智能指针出现循环引用怎么解决？" class="headerlink" title="10、智能指针出现循环引用怎么解决？"></a>10、智能指针出现循环引用怎么解决？</h2><p>弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个shared_ptr成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。</p>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-C++其余问题</title>
    <url>/2023/07/15/C++%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="C-其余问题"><a href="#C-其余问题" class="headerlink" title="C++其余问题"></a>C++其余问题</h1><h2 id="1、C-的多态如何实现"><a href="#1、C-的多态如何实现" class="headerlink" title="1、C++的多态如何实现"></a>1、C++的多态如何实现</h2><p>C++的多态性，<strong>一言以蔽之</strong>就是：</p>
<p>在基类的函数前加上<strong>virtual</strong>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; Base::func()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; Son1::func()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* base = <span class="keyword">new</span> Son1;</span><br><span class="line">	base-&gt;<span class="built_in">fun</span>();</span><br><span class="line">	base = <span class="keyword">new</span> Son2;</span><br><span class="line">	base-&gt;<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;</span><br><span class="line">	base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// Son1::func()</span></span><br><span class="line"><span class="comment">// Base::func()</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>例子中，Base为基类，其中的函数为虚函数。</p>
<p>子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性，那么为什么会出现多态性，其底层的原理是什么？</p>
<p>这里需要引出虚表和虚基表指针的概念。</p>
<p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p>
<p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p>
<p><img src="http://oss.interviewguide.cn/img/202205220022619.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205220022551.png" alt="img"></p>
<p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p>
<p><strong>（1）</strong>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</p>
<p><strong>（2）</strong>编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p>
<p><strong>（3）</strong>所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p>
<p><strong>（4）</strong>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p>
<p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p>
<h2 id="2、为什么析构函数一般写成虚函数"><a href="#2、为什么析构函数一般写成虚函数" class="headerlink" title="2、为什么析构函数一般写成虚函数"></a>2、为什么析构函数一般写成虚函数</h2><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p>
<p>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Parent destructor functio</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将基类的析构函数声明为虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Son destructor function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>但存在一种特例，在<code>CRTP</code>模板中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表。</p>
<h2 id="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h2><p>析构函数：</p>
<ul>
<li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。</li>
<li>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li>
<li><strong>析构函数可以是纯虚函数</strong>，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li>
</ul>
<p>构造函数：</p>
<ul>
<li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li>
<li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li>
</ul>
<h2 id="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h2><p>首先整理一下虚函数表的特征：</p>
<ul>
<li>虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成</li>
<li>虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段</li>
<li>虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中</li>
</ul>
<p>根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区，测试结果显示：</p>
<p>虚函数表vtable在Linux&#x2F;Unix中存放在可执行文件的只读数据段中(rodata)，这与微软的编译器将虚函数表存放在常量段存在一些差别</p>
<p>由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。</p>
<p>一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区</p>
<p>C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p>
<h2 id="5、模板函数和模板类的特例化"><a href="#5、模板函数和模板类的特例化" class="headerlink" title="5、模板函数和模板类的特例化"></a>5、模板函数和模板类的特例化</h2><p><strong>引入原因</strong></p>
<p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p><strong>定义</strong></p>
<p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<p><strong>（1）模板函数特例化</strong></p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1,<span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v1,<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>本质</strong></p>
<p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用<strong>特例化版本</strong>（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p><strong>注意</strong></p>
<p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<p><strong>（2）类模板特例化</strong></p>
<p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(sales_data&amp; s)</span></span>;</span><br><span class="line">	<span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line">	<span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>类模板的部分特例化</strong></p>
<p>不必为所有模板参数提供实参，可以<strong>指定一部分而非所有模板参数</strong>，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p><strong>特例化类中的部分成员</strong></p>
<p><strong>可以特例化类中的部分成员函数而不是整个类</strong>，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="6、构造函数、析构函数、虚函数可否声明为内联函数"><a href="#6、构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="6、构造函数、析构函数、虚函数可否声明为内联函数"></a>6、构造函数、析构函数、虚函数可否声明为内联函数</h2><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p>
<blockquote>
<p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inline construct()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">inline</span> ~<span class="built_in">A</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inline destruct()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">virtualFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;inline virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">virtualFun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//inline construct()</span></span><br><span class="line"><span class="comment">//inline virtual function</span></span><br><span class="line"><span class="comment">//inline destruct()</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>构造函数和析构函数声明为内联函数是没有意义的</strong></p>
<p>《Effective C++》中所阐述的是：<strong>将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简</strong>。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p>
<p><strong>将虚函数声明为inline，要分情况讨论</strong></p>
<p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p>
<p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p>
<p><strong>综上</strong>，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。</p>
<h2 id="7、C-模板是什么，你知道底层怎么实现的？"><a href="#7、C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="7、C++模板是什么，你知道底层怎么实现的？"></a>7、C++模板是什么，你知道底层怎么实现的？</h2><ol>
<li>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</li>
<li>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</li>
</ol>
<h2 id="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h2><p><strong>1、 从存储空间角度，</strong>虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。</p>
<p>问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</p>
<p><strong>2、 从使用角度，</strong>虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。</p>
<p>构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。</p>
<p>所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>
<p><strong>3、构造函数不须要是虚函数，也不同意是虚函数，</strong>由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>
<p><strong>4、从实现上看，</strong>vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</p>
<p><strong>5、当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。</strong></p>
<p>因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。</p>
<p>并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。</p>
<p>VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。</p>
<p>因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。</p>
<p>直接的讲，C++中基类采用virtual虚析构函数是<strong>为了防止内存泄漏。</strong></p>
<p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p>
<p>所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
<h2 id="9、析构函数的作用，如何起作用？"><a href="#9、析构函数的作用，如何起作用？" class="headerlink" title="9、析构函数的作用，如何起作用？"></a>9、析构函数的作用，如何起作用？</h2><ol>
<li><p>构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</p>
<p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。</p>
</li>
<li><p>析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
</li>
</ol>
<h2 id="10、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#10、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="10、构造函数和析构函数可以调用虚函数吗，为什么"></a>10、构造函数和析构函数可以调用虚函数吗，为什么</h2><ol>
<li>在C++中，提倡不在构造函数和析构函数中调用虚函数；</li>
<li>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</li>
<li>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</li>
<li>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</li>
</ol>
<h2 id="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h2><p><strong>1) 构造函数顺序</strong></p>
<p>① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</p>
<p>② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</p>
<p>③ 派生类构造函数。</p>
<p><strong>2) 析构函数顺序</strong></p>
<p>① 调用派生类的析构函数；</p>
<p>② 调用成员类对象的析构函数；</p>
<p>③ 调用基类的析构函数。</p>
<h2 id="12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><a href="#12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？" class="headerlink" title="12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？"></a>12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？</h2><ol>
<li><p>C++中基类采用virtual虚析构函数是为了防止内存泄漏。</p>
<p>具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。</p>
<p>假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。</p>
<p>那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。</p>
<p>所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>
</li>
<li><p>纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。</p>
<p>因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，最好不要把虚析构函数定义为纯虚析构函数。</p>
</li>
</ol>
<h2 id="13、构造函数析构函数可否抛出异常"><a href="#13、构造函数析构函数可否抛出异常" class="headerlink" title="13、构造函数析构函数可否抛出异常"></a>13、构造函数析构函数可否抛出异常</h2><ol>
<li><p>C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</p>
<p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p>
</li>
<li><p>用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p>
</li>
<li><p>如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</p>
</li>
<li><p>如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
</li>
</ol>
<h2 id="14、构造函数一般不定义为虚函数的原因"><a href="#14、构造函数一般不定义为虚函数的原因" class="headerlink" title="14、构造函数一般不定义为虚函数的原因"></a>14、构造函数一般不定义为虚函数的原因</h2><p>（1）创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型</p>
<p>（2）虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了</p>
<p>（3）虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数</p>
<p>（4）析构函数一般都要声明为虚函数，这个应该是老生常谈了，这里不再赘述</p>
<h2 id="15、类什么时候会析构？"><a href="#15、类什么时候会析构？" class="headerlink" title="15、类什么时候会析构？"></a>15、类什么时候会析构？</h2><ol>
<li>对象生命周期结束，被销毁时；</li>
<li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</li>
<li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</li>
</ol>
<h2 id="16、构造函数或者析构函数中可以调用虚函数吗"><a href="#16、构造函数或者析构函数中可以调用虚函数吗" class="headerlink" title="16、构造函数或者析构函数中可以调用虚函数吗"></a>16、构造函数或者析构函数中可以调用虚函数吗</h2><p>简要结论：</p>
<ul>
<li>从语法上讲，调用完全没有问题。</li>
<li>但是从效果上看，往往不能达到需要的目的。</li>
</ul>
<blockquote>
<p>《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">Function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::Fuction&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Function</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Function</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::Function&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	~<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Function</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* a = <span class="keyword">new</span> Base;</span><br><span class="line">	<span class="keyword">delete</span> a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------------------&quot;</span> &lt;&lt;endl;</span><br><span class="line">	Base* b = <span class="keyword">new</span> A;<span class="comment">//语句1</span></span><br><span class="line">	<span class="keyword">delete</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//-------------------------</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line"><span class="comment">//A::Function</span></span><br><span class="line"><span class="comment">//Base::Fuction</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>语句1讲道理应该体现多态性，执行类A中的构造和析构函数，从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数，析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免</p>
<h2 id="17、构造函数的几种关键字"><a href="#17、构造函数的几种关键字" class="headerlink" title="17、构造函数的几种关键字"></a>17、构造函数的几种关键字</h2><p><strong>default</strong></p>
<p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">const</span> <span class="type">char</span>* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句2</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Hello World</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
<p><strong>delete</strong></p>
<p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句1</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
<p><strong>0</strong></p>
<p>将虚函数定义为纯虚函数（纯虚函数无需定义，&#x3D; 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部。</p>
<h2 id="18、构造函数、拷贝构造函数和赋值操作符的区别"><a href="#18、构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="18、构造函数、拷贝构造函数和赋值操作符的区别"></a>18、构造函数、拷贝构造函数和赋值操作符的区别</h2><p><strong>构造函数</strong></p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p><strong>拷贝构造函数</strong></p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p><strong>赋值运算符</strong></p>
<p>对象存在，用别的对象给它赋值，这属于重载“&#x3D;”号运算符的范畴，“&#x3D;”号两侧的对象都是已存在的</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是赋值操作符&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a1; <span class="comment">//调用构造函数</span></span><br><span class="line">	A a2 = a1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	a2 = a1; <span class="comment">//调用赋值操作符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//我是构造函数</span></span><br><span class="line"><span class="comment">//我是拷贝构造函数</span></span><br><span class="line"><span class="comment">//我是赋值操作符</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="19、拷贝构造函数和赋值运算符重载的区别？"><a href="#19、拷贝构造函数和赋值运算符重载的区别？" class="headerlink" title="19、拷贝构造函数和赋值运算符重载的区别？"></a>19、拷贝构造函数和赋值运算符重载的区别？</h2><ul>
<li><p>拷贝构造函数是函数，赋值运算符是运算符重载。</p>
</li>
<li><p>拷贝构造函数会生成新的类对象，赋值运算符不能。</p>
</li>
<li><p>拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。</p>
</li>
<li><p>形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现”&#x3D;”的地方都是使用赋值运算符，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = s;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。</p>
<h2 id="20、什么是虚拟继承"><a href="#20、什么是虚拟继承" class="headerlink" title="20、什么是虚拟继承"></a>20、什么是虚拟继承</h2><p>由于C++支持多继承，除了public、protected和private三种继承方式外，还支持虚拟（virtual）继承，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A)：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span> A &lt;&lt;endl; <span class="comment">// 1，空对象，只有一个占位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(B)：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span> B &lt;&lt;endl; <span class="comment">// 4，一个bptr指针，省去占位,不需要对齐</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(C)：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span> C &lt;&lt;endl; <span class="comment">// 4，一个bptr指针，省去占位,不需要对齐</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(D)：&quot;</span> &lt;&lt; <span class="keyword">sizeof</span> D &lt;&lt;endl; <span class="comment">// 8，两个bptr，省去占位,不需要对齐</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>上述代码所体现的关系是，B和C虚拟继承A，D又公有继承B和C，这种方式是一种<strong>菱形继承或者钻石继承</strong>，可以用如下图来表示</p>
<p><img src="http://oss.interviewguide.cn/img/202205220025114.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205220022397.png" alt="img"></p>
<p><strong>虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体。</strong>虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被称为bptr，如上图所示。如果既存在vptr又存在bptr，某些编译器会将其优化，合并为一个指针。</p>
<h2 id="21、什么情况会自动生成默认构造函数？"><a href="#21、什么情况会自动生成默认构造函数？" class="headerlink" title="21、什么情况会自动生成默认构造函数？"></a>21、什么情况会自动生成默认构造函数？</h2><ol>
<li><p>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。</p>
<p>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</p>
<p>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</p>
</li>
<li><p>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</p>
</li>
<li><p>带有一个虚函数的类</p>
</li>
<li><p>带有一个虚基类的类</p>
</li>
<li><p>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p>
</li>
</ol>
<h2 id="22、抽象基类为什么不能创建对象？"><a href="#22、抽象基类为什么不能创建对象？" class="headerlink" title="22、抽象基类为什么不能创建对象？"></a>22、抽象基类为什么不能创建对象？</h2><p>抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。</p>
<ol>
<li><p>抽象类的定义： 称带有纯虚函数的类为抽象类。</p>
</li>
<li><p>抽象类的作用： 抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。</p>
</li>
<li><p>抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。</p>
<p>抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。</p>
</li>
<li><p>纯虚函数定义 纯虚函数是一种特殊的虚函数，它的一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt; 　&#123; 　<span class="keyword">virtual</span> &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=<span class="number">0</span>; 　… 　&#125;; </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>
</li>
<li><p>纯虚函数引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()&#x3D; 0;）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.</p>
</li>
<li><p>相似概念 </p>
<ul>
<li><p>1、多态性      指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 　</p>
<p>a.编译时多态性：通过重载函数实现 　b.运行时多态性：通过虚函数实现。</p>
</li>
<li><p>2、虚函数 　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 </p>
</li>
<li><p>3、抽象类 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。</p>
</li>
</ul>
</li>
</ol>
<h2 id="23、模板类和模板函数的区别是什么？"><a href="#23、模板类和模板函数的区别是什么？" class="headerlink" title="23、模板类和模板函数的区别是什么？"></a>23、模板类和模板函数的区别是什么？</h2><p>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加<T>，而函数模板不必</p>
<h2 id="24、多继承的优缺点，作为一个开发者怎么看待多继承"><a href="#24、多继承的优缺点，作为一个开发者怎么看待多继承" class="headerlink" title="24、多继承的优缺点，作为一个开发者怎么看待多继承"></a>24、多继承的优缺点，作为一个开发者怎么看待多继承</h2><ol>
<li>C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。</li>
<li>多重继承的优点很明显，就是对象可以调用多个基类中的接口；</li>
<li>如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性</li>
<li>加上全局符确定调用哪一份拷贝。比如pa.Author::eat()调用属于Author的拷贝。</li>
<li>使用虚拟继承，使得多重继承类Programmer_Author只拥有Person类的一份拷贝。</li>
</ol>
<h2 id="25、模板和实现可不可以不写在一个文件里面？为什么？"><a href="#25、模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="25、模板和实现可不可以不写在一个文件里面？为什么？"></a>25、模板和实现可不可以不写在一个文件里面？为什么？</h2><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。 《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<h2 id="26、将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#26、将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="26、将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>26、将字符串“hello world”从开始到打印到屏幕上的全过程?</h2><ol>
<li>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</li>
<li>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</li>
<li>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</li>
<li>操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</li>
<li>执行helloworld程序的第一条指令，发生缺页异常</li>
<li>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</li>
<li>helloword程序执行puts函数（系统调用），在显示器上写一字符串</li>
<li>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</li>
<li>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</li>
<li>视频硬件将像素转换成显示器可接收和一组控制数据信号</li>
<li>显示器解释信号，激发液晶屏</li>
<li>OK，我们在屏幕上看到了HelloWorld</li>
</ol>
<h2 id="27、为什么拷贝构造函数必须传引用不能传值？"><a href="#27、为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="27、为什么拷贝构造函数必须传引用不能传值？"></a>27、为什么拷贝构造函数必须传引用不能传值？</h2><ol>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？ 将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！ a 值传递: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
</ol>
<p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
<p>b 引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型). 上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h2 id="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"><a href="#28、静态函数能定义为虚函数吗？常函数呢？说说你的理解" class="headerlink" title="28、静态函数能定义为虚函数吗？常函数呢？说说你的理解"></a>28、静态函数能定义为虚函数吗？常函数呢？说说你的理解</h2><ol>
<li><p>static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。</p>
</li>
<li><p>静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针。</p>
<p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr。</p>
<p>这就是为何static函数不能为virtual，虚函数的调用关系：this -&gt; vptr -&gt; vtable -&gt;virtual function。</p>
</li>
</ol>
<h2 id="29、虚函数的代价是什么？"><a href="#29、虚函数的代价是什么？" class="headerlink" title="29、虚函数的代价是什么？"></a>29、虚函数的代价是什么？</h2><ol>
<li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚成员函数的指针，增大类；</li>
<li>带有虚函数的类的每一个对象，都会有有一个指向虚表的指针，会增加对象的空间大小；</li>
<li>不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数。</li>
</ol>
<h2 id="30、说一说你了解到的移动构造函数？"><a href="#30、说一说你了解到的移动构造函数？" class="headerlink" title="30、说一说你了解到的移动构造函数？"></a>30、说一说你了解到的移动构造函数？</h2><ol>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</li>
<li></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Example6</span> (Example6&amp;&amp; x) : <span class="built_in">ptr</span>(x.ptr) </span><br><span class="line">  &#123;</span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line">   ptr = x.ptr;</span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="31、-什么情况下会合成构造函数？都说一说，你知道的都说一下"><a href="#31、-什么情况下会合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="31、 什么情况下会合成构造函数？都说一说，你知道的都说一下"></a>31、 什么情况下会合成构造函数？都说一说，你知道的都说一下</h2><ol>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ol>
<p>还有一点需要注意的是：</p>
<ol>
<li>并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</li>
</ol>
<h2 id="32、那什么时候需要合成拷贝构造函数呢？"><a href="#32、那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="32、那什么时候需要合成拷贝构造函数呢？"></a>32、那什么时候需要合成拷贝构造函数呢？</h2><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ol>
<li>对一个对象做显示的初始化操作，X xx &#x3D; x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li>当函数传回一个类对象时；</li>
<li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ol>
<h2 id="33、构造函数的执行顺序是什么？"><a href="#33、构造函数的执行顺序是什么？" class="headerlink" title="33、构造函数的执行顺序是什么？"></a>33、构造函数的执行顺序是什么？</h2><ol>
<li>在派生类构造函数中，所有的虚基类及上一层基类的构造函数调用；</li>
<li>对象的vptr被初始化；</li>
<li>如果有成员初始化列表，将在构造函数体内扩展开来，这必须在vptr被设定之后才做；</li>
<li>执行程序员所提供的代码；</li>
</ol>
<h2 id="34、一个类中的全部构造函数的扩展过程是什么？"><a href="#34、一个类中的全部构造函数的扩展过程是什么？" class="headerlink" title="34、一个类中的全部构造函数的扩展过程是什么？"></a>34、一个类中的全部构造函数的扩展过程是什么？</h2><ol>
<li>记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；</li>
<li>如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；</li>
<li>如果class有虚表，那么它必须被设定初值；</li>
<li>所有上一层的基类构造函数必须被调用；</li>
<li>所有虚基类的构造函数必须被调用。</li>
</ol>
<h2 id="35、哪些函数不能是虚函数？把你知道的都说一说"><a href="#35、哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="35、哪些函数不能是虚函数？把你知道的都说一说"></a>35、哪些函数不能是虚函数？把你知道的都说一说</h2><ol>
<li>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</li>
<li>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</li>
<li>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</li>
<li>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</li>
<li>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</li>
</ol>
<h2 id="36、什么是纯虚函数，与虚函数的区别"><a href="#36、什么是纯虚函数，与虚函数的区别" class="headerlink" title="36、什么是纯虚函数，与虚函数的区别"></a>36、什么是纯虚函数，与虚函数的区别</h2><p><strong>虚函数和纯虚函数区别</strong>？</p>
<ul>
<li>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</li>
<li>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</li>
</ul>
<p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“&#x3D;0”。</p>
<p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p>
<p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;普通虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;子类实现的纯虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* b = <span class="keyword">new</span> Son;</span><br><span class="line">	b-&gt;<span class="built_in">fun1</span>(); <span class="comment">//普通虚函数</span></span><br><span class="line">	b-&gt;<span class="built_in">fun2</span>(); <span class="comment">//子类实现的纯虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-C++STL模板库</title>
    <url>/2023/07/15/C++STL%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    <content><![CDATA[<h1 id="C-STL模板库"><a href="#C-STL模板库" class="headerlink" title="C++STL模板库"></a>C++STL模板库</h1><h2 id="1、什么是STL？"><a href="#1、什么是STL？" class="headerlink" title="1、什么是STL？"></a>1、什么是STL？</h2><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h2 id="2、解释一下什么是trivial-destructor"><a href="#2、解释一下什么是trivial-destructor" class="headerlink" title="2、解释一下什么是trivial destructor"></a>2、解释一下什么是trivial destructor</h2><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p>
<p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露</p>
<p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？</p>
<p>《STL源码解析》中给出的说明是:</p>
<p>首先利用value_type()获取所指对象的型别，再利用__type_traits<T>判断该型别的析构函数是否trivial，若是(__true_type)，则什么也不做，若为(__false_type)，则去调用destory()函数。</p>
<p>也就是说，在实际的应用当中，STL库提供了相关的判断方法**__type_traits**，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p>
<h2 id="3、使用智能指针管理内存资源，RAII是怎么回事？"><a href="#3、使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="3、使用智能指针管理内存资源，RAII是怎么回事？"></a>3、使用智能指针管理内存资源，RAII是怎么回事？</h2><ol>
<li><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</p>
<p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
</li>
<li><p>.智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
</li>
</ol>
<h2 id="4、迭代器：-it、it-哪个好，为什么"><a href="#4、迭代器：-it、it-哪个好，为什么" class="headerlink" title="4、迭代器：++it、it++哪个好，为什么"></a>4、迭代器：++it、it++哪个好，为什么</h2><ol>
<li><p>前置返回一个引用，后置返回一个对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ++i实现代码为：</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)                 </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line"></span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line">&#125; </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5、说一下C-左值引用和右值引用"><a href="#5、说一下C-左值引用和右值引用" class="headerlink" title="5、说一下C++左值引用和右值引用"></a>5、说一下C++左值引用和右值引用</h2><p>C++11正是通过引入右值引用来优化性能，具体来说是通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去，通过完美转发来解决不能按照参数实际类型来转发的问题（同时，完美转发获得的一个好处是可以实现移动语义）。</p>
<ol>
<li>在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a &#x3D; b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</li>
<li>C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</li>
<li>左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</li>
<li>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。</li>
</ol>
<p><strong>左值和右值</strong></p>
<p>左值：表示的是可以获取地址的表达式，它能出现在赋值语句的左边，对该表达式进行赋值。但是修饰符const的出现使得可以声明如下的标识符，它可以取得地址，但是没办法对其进行赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = <span class="number">10</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>右值：表示无法获取地址的对象，有常量值、函数返回值、lambda表达式等。无法获取地址，但不表示其不可改变，当定义了右值的右值引用时就可以更改右值。</p>
<p><strong>左值引用和右值引用</strong></p>
<p>左值引用：传统的C++中引用被称为左值引用</p>
<p>右值引用：C++11中增加了右值引用，右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置</p>
<p><strong>这里主要说一下右值引用的特点：</strong></p>
<ul>
<li>特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去</li>
<li>特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值</li>
<li>特点3：T&amp;&amp; t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; b = a;  <span class="comment">//b是左值引用</span></span><br><span class="line">	<span class="type">int</span>&amp; c = <span class="number">10</span>;  <span class="comment">//错误，c是左值不能使用右值初始化</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; d = <span class="number">10</span>;  <span class="comment">//正确，右值引用用右值初始化</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; e = a;  <span class="comment">//错误，e是右值引用不能使用左值初始化</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; f = a; <span class="comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; g = <span class="number">10</span>;<span class="comment">//正确，左值常引用相当于是万能型，可以用左值或者右值初始化</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp;&amp; h = <span class="number">10</span>; <span class="comment">//正确，右值常引用</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; aa = h;<span class="comment">//正确</span></span><br><span class="line">	<span class="type">int</span>&amp; i = <span class="built_in">getInt</span>();  <span class="comment">//错误，i是左值引用不能使用临时变量（右值）初始化</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; j = <span class="built_in">getInt</span>();  <span class="comment">//正确，函数返回值是右值</span></span><br><span class="line">	<span class="built_in">fun</span>(<span class="number">10</span>); <span class="comment">//此时fun函数的参数t是右值</span></span><br><span class="line">	<span class="built_in">fun</span>(a); <span class="comment">//此时fun函数的参数t是左值</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="6、STL中hashtable的实现？"><a href="#6、STL中hashtable的实现？" class="headerlink" title="6、STL中hashtable的实现？"></a>6、STL中hashtable的实现？</h2><p>STL中的hashtable使用的是开链法解决hash冲突问题，如下图所示。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220035271.png" alt="img"></p>
<p>hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<p>在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。</p>
<h2 id="7、简单说一下traits技法"><a href="#7、简单说一下traits技法" class="headerlink" title="7、简单说一下traits技法"></a>7、简单说一下traits技法</h2><p>traits技法利用“内嵌型别“的编程技巧与<strong>编译器的template参数推导功能</strong>，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。</p>
<p><strong>iterator_traits</strong></p>
<p>被称为<strong>特性萃取机</strong>，能够方便的让外界获取以下5种型别：</p>
<ul>
<li>value_type：迭代器所指对象的型别</li>
<li>difference_type：两个迭代器之间的距离</li>
<li>pointer：迭代器所指向的型别</li>
<li>reference：迭代器所引用的型别</li>
<li>iterator_category：三两句说不清楚，建议看书</li>
</ul>
<p><strong>type_traits</strong></p>
<p>关注的是型别的<strong>特性</strong>，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__true_type</span>&#123;&#125;;<span class="keyword">struct</span> <span class="title class_">__false_type</span>&#123;&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得</p>
<p>当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">__type_traits</span>&lt;Shape&gt;&#123;</span><br><span class="line">	<span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_assignment_operator;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">	<span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="8、STL的两级空间配置器"><a href="#8、STL的两级空间配置器" class="headerlink" title="8、STL的两级空间配置器"></a>8、STL的两级空间配置器</h2><p>1、首先明白为什么需要二级空间配置器？</p>
<p>我们知道动态开辟内存时，要在堆上申请，但若是我们需要</p>
<p>频繁的在堆开辟释放内存，则就会<strong>在堆上造成很多外部碎片</strong>，浪费了内存空间；</p>
<p>每次都要进行调用<strong>malloc、free</strong>函数等操作，使空间就会增加一些附加信息，降低了空间利用率；</p>
<p>随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。</p>
<p>于是就设置了二级空间配置器，<strong>当开辟内存&lt;&#x3D;128bytes时，即视为开辟小块内存，则调用二级空间配置器。</strong></p>
<p>关于STL中一级空间配置器和二级空间配置器的选择上，一般默认<strong>选择的为二级空间配置器</strong>。 如果大于128字节再转去一级配置器器。</p>
<h3 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h3><p><strong>一级空间配置器</strong>中重要的函数就是allocate、deallocate、reallocate 。 一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：</p>
<ol>
<li>直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数</li>
<li>如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常</li>
<li>如果自定义了处理函数就进行处理，完事再继续分配试试</li>
</ol>
<p><img src="http://oss.interviewguide.cn/img/202205220035143.png" alt="img"></p>
<h3 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h3><p><img src="http://oss.interviewguide.cn/img/202205220035104.png" alt="img"></p>
<ol>
<li><p>维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第n个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。</p>
</li>
<li><p>对应的free_list为空，先看其内存池是不是空时，如果内存池不为空： （1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。 （2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。 （3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。 3、内存池为空，申请内存 此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。 4、malloc没有成功 在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。</p>
<p>释放时调用deallocate()函数，若释放的n&gt;128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。</p>
</li>
</ol>
<ul>
<li>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：</li>
</ul>
<ol>
<li>因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；</li>
<li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ol>
<h3 id="一级分配器"><a href="#一级分配器" class="headerlink" title="一级分配器"></a>一级分配器</h3><p>GC4.9之后就没有第一级了，只有第二级</p>
<h3 id="二级分配器"><a href="#二级分配器" class="headerlink" title="二级分配器"></a>二级分配器</h3><p>——default_alloc_template 剖析</p>
<p>有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）</p>
<p>allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc 2*20个块）去内存池去拿或者重新分配。不为空的话</p>
<h2 id="9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#9、-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>9、 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h2><ol>
<li><p>vector数据结构 vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</p>
<p>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</p>
</li>
<li><p>list数据结构 list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。</p>
<p>区别：</p>
<ul>
<li>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。</li>
<li>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</li>
<li>从遍历上来说，list是单向的，vector是双向的。</li>
<li>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。</li>
</ul>
</li>
<li><p>int mySize &#x3D; vec.size();vec.at(mySize -2);</p>
<p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历</p>
</li>
</ol>
<h2 id="10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"><a href="#10、STL-中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？" class="headerlink" title="10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？"></a>10、STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？</h2><p>size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。</p>
<p>由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n&gt;capacity()时，调用reserve(n)才会改变vector容量。</p>
<p>resize()成员函数改变元素的数目，至于空间的的变化需要看具体情况去分析，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">resize</span><span class="params">(size_type __new_size, <span class="type">const</span> _Tp&amp; __x)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (__new_size &lt; size()) </span><br><span class="line">            erase(begin() + __new_size, end());</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">            insert(end(), __new_size - size(), __x);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ol>
<li>空的vector对象，size()和capacity()都为0</li>
<li>当空间大小不足时，新分配的空间大小为原空间大小的2倍。</li>
<li>使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。</li>
<li>当reserve()分配的空间比原空间小时，是不会引起重新分配的。</li>
<li>resize()函数只改变容器的元素数目，未改变容器大小。</li>
<li>用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。</li>
</ol>
<p>不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；</p>
<p>空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。</p>
<p>使用k&#x3D;2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好，最好把增长因子设为(1, 2)，也就是1-2之间的某个数值。</p>
<p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
<h2 id="11、Vector如何释放空间"><a href="#11、Vector如何释放空间" class="headerlink" title="11、Vector如何释放空间?"></a>11、Vector如何释放空间?</h2><p>由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。</p>
<p>如果需要空间动态缩小，可以考虑使用deque。</p>
<p>如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>(Vec).<span class="built_in">swap</span>(Vec); <span class="comment">//将Vec中多余内存清除； </span></span><br><span class="line"><span class="built_in">vector</span>().<span class="built_in">swap</span>(Vec); <span class="comment">//清空Vec的全部内存；</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span> <span class="params">(<span class="number">100</span>,<span class="number">100</span>)</span></span>;   <span class="comment">// three ints with a value of 100</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vec).<span class="built_in">swap</span>(vec); <span class="comment">//清空vec中多余的空间，相当于vec.shrink_to_fit();</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(vec); <span class="comment">//清空vec的全部空间</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.size(): &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;vec.capasity(): &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    运行结果：</span></span><br><span class="line"><span class="comment">    vec.size(): 102</span></span><br><span class="line"><span class="comment">    vec.capasity(): 200</span></span><br><span class="line"><span class="comment">    vec.size(): 102</span></span><br><span class="line"><span class="comment">    vec.capasity(): 102</span></span><br><span class="line"><span class="comment">    vec.size(): 0</span></span><br><span class="line"><span class="comment">    vec.capasity(): 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="12、容器内部删除一个元素"><a href="#12、容器内部删除一个元素" class="headerlink" title="12、容器内部删除一个元素"></a>12、容器内部删除一个元素</h2><ol>
<li><p>顺序容器（序列式容器，比如vector、deque）</p>
<p>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
<p>It &#x3D; c.erase(it);</p>
</li>
<li><p>关联容器(关联式容器，比如map、set、multimap、multiset等)</p>
<p>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
<p>c.erase(it++)</p>
</li>
</ol>
<h2 id="13、STL迭代器如何实现"><a href="#13、STL迭代器如何实现" class="headerlink" title="13、STL迭代器如何实现"></a>13、STL迭代器如何实现</h2><ol>
<li>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</li>
<li>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</li>
<li>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</li>
</ol>
<h2 id="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？"><a href="#14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？-为什么使用红黑树？" class="headerlink" title="14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？"></a>14、map、set是怎么实现的，红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？</h2><ol>
<li>他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn时间内完成，因此可以完成高效的插入删除；</li>
<li>在这里我们定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value</li>
<li>因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。</li>
</ol>
<h2 id="15、如何在共享内存上使用STL标准库？"><a href="#15、如何在共享内存上使用STL标准库？" class="headerlink" title="15、如何在共享内存上使用STL标准库？"></a>15、如何在共享内存上使用STL标准库？</h2><ol>
<li><p>想像一下把STL容器，例如map, vector, list等等，放入共享内存中，IPC一旦有了这些强大的通用数据结构做辅助，无疑进程间通信的能力一下子强大了很多。</p>
<p>我们没必要再为共享内存设计其他额外的数据结构，另外，STL的高度可扩展性将为IPC所驱使。STL容器被良好的封装，默认情况下有它们自己的内存管理方案。</p>
<p>当一个元素被插入到一个STL列表(list)中时，列表容器自动为其分配内存，保存数据。考虑到要将STL容器放到共享内存中，而容器却自己在堆上分配内存。</p>
<p>一个最笨拙的办法是在堆上构造STL容器，然后把容器复制到共享内存，并且确保所有容器的内部分配的内存指向共享内存中的相应区域，这基本是个不可能完成的任务。</p>
</li>
<li><p>假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？</p>
<p>一个方法就是进程A把容器放在共享内存中的确定地址上（fixed offsets），则进程B可以从该已知地址上获取容器。另外一个改进点的办法是，进程A先在共享内存某块确定地址上放置一个map容器，然后进程A再创建其他容器，然后给其取个名字和地址一并保存到这个map容器里。</p>
<p>进程B知道如何获取该保存了地址映射的map容器，然后同样再根据名字取得其他容器的地址。</p>
</li>
</ol>
<h2 id="16、map插入方式有哪几种？"><a href="#16、map插入方式有哪几种？" class="headerlink" title="16、map插入方式有哪几种？"></a>16、map插入方式有哪几种？</h2><p>1.用insert函数插入pair数据，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>2.用insert函数插入value_type数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>3.在insert函数中使用make_pair()函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>)); </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>4.用数组方式插入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>; </span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<h2 id="17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容"><a href="#17、STL中unordered-map-hash-map-和map的区别，hash-map如何解决冲突以及扩容" class="headerlink" title="17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容"></a>17、STL中unordered_map(hash_map)和map的区别，hash_map如何解决冲突以及扩容</h2><ol>
<li>unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，</li>
<li>存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。</li>
<li>所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。但是很多系统内置的数据类型都自带这些，</li>
<li>那么如果是自定义类型，那么就需要自己重载operator&lt;或者hash_value()了。</li>
<li>如果需要内部元素自动排序，使用map，不需要排序使用unordered_map</li>
<li>unordered_map的底层实现是hash_table;</li>
<li>hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。</li>
<li><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</li>
<li>**扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。</li>
</ol>
<h2 id="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"><a href="#18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？" class="headerlink" title="18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？"></a>18、vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？</h2><ol>
<li>通过下标访问vector中的元素时会做边界检查，但该处的实现方式要看具体IDE，不同IDE的实现方式不一样，确保不可访问越界地址。</li>
<li>map的下标运算符[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的某人值插入这个map。</li>
<li>erase()函数，只能删除内容，不能改变容量大小;</li>
</ol>
<p>erase成员函数，它删除了itVect迭代器指向的元素，并且返回要被删除的itVect之后的迭代器，迭代器相当于一个智能指针;clear()函数，只能清空内容，不能改变容量大小;如果要想在删除内容的同时释放内存，那么你可以选择deque容器。</p>
<h2 id="19、map中-与find的区别？"><a href="#19、map中-与find的区别？" class="headerlink" title="19、map中[]与find的区别？"></a>19、map中[]与find的区别？</h2><ol>
<li>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</li>
<li>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</li>
</ol>
<h2 id="20、-STL中list与queue之间的区别"><a href="#20、-STL中list与queue之间的区别" class="headerlink" title="20、 STL中list与queue之间的区别"></a>20、 STL中list与queue之间的区别</h2><ol>
<li>list不再能够像vector一样以普通指针作为迭代器，因为其节点不保证在存储空间中连续存在；</li>
<li>list插入操作原有的list迭代器失效;</li>
<li>list不仅是一个双向链表，而且还是一个环状双向链表，所以它只需要一个指针；</li>
<li>list不像vector那样有可能在空间不足时做重新配置、数据移动的操作，所以插入前的所有迭代器在插入操作之后都仍然有效；</li>
<li>deque是一种双向开口的连续线性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作；</li>
<li>deque和vector最大的差异，一在于deque允许常数时间内对起头端进行元素的插入或移除操作；二在于deque没有所谓容量概念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque没有所谓的空间保留功能。</li>
</ol>
<h2 id="21、STL中的allocator、deallocator"><a href="#21、STL中的allocator、deallocator" class="headerlink" title="21、STL中的allocator、deallocator"></a>21、STL中的allocator、deallocator</h2><ol>
<li>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</li>
<li>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</li>
<li>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</li>
<li>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</li>
</ol>
<h2 id="22、STL中hash-table扩容发生什么？"><a href="#22、STL中hash-table扩容发生什么？" class="headerlink" title="22、STL中hash table扩容发生什么？"></a>22、STL中hash table扩容发生什么？</h2><ol>
<li>hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。</li>
<li>向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。</li>
</ol>
<h2 id="23、常见容器性质总结？"><a href="#23、常见容器性质总结？" class="headerlink" title="23、常见容器性质总结？"></a>23、常见容器性质总结？</h2><ol>
<li><p>vector 底层数据结构为数组 ，支持快速随机访问</p>
</li>
<li><p>list 底层数据结构为双向链表，支持快速增删</p>
</li>
<li><p>deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p>
<p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p>
<p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p>
<p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p>
</li>
<li><p>stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
</li>
<li><p>queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p>
</li>
<li><p>priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p>
</li>
<li><p>set 底层数据结构为红黑树，有序，不重复</p>
</li>
<li><p>multiset 底层数据结构为红黑树，有序，可重复</p>
</li>
<li><p>map 底层数据结构为红黑树，有序，不重复</p>
</li>
<li><p>multimap 底层数据结构为红黑树，有序，可重复</p>
</li>
<li><p>unordered_set 底层数据结构为hash表，无序，不重复</p>
</li>
<li><p>unordered_multiset 底层数据结构为hash表，无序，可重复</p>
</li>
<li><p>unordered_map 底层数据结构为hash表，无序，不重复</p>
</li>
<li><p>unordered_multimap 底层数据结构为hash表，无序，可重复</p>
</li>
</ol>
<h2 id="24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？"><a href="#24、vector的增加删除都是怎么做的？为什么是1-5或者是2倍？" class="headerlink" title="24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？"></a>24、vector的增加删除都是怎么做的？为什么是1.5或者是2倍？</h2><ol>
<li>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；</li>
<li>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；</li>
<li>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；</li>
<li>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</li>
</ol>
<p>对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。</p>
<ol>
<li>考虑可能产生的堆空间浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式有两种，以2二倍的方式扩容，或者以1.5倍的方式扩容。</li>
<li>以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间：</li>
<li>向量容器vector的成员函数pop_back()可以删除最后一个元素.</li>
<li>而函数erase()可以删除由一个iterator指出的元素，也可以删除一个指定范围的元素。</li>
<li>还可以采用通用算法remove()来删除vector容器中的元素.</li>
<li>不同的是：采用remove一般情况下不会改变容器的大小，而pop_back()与erase()等成员函数会改变容器的大小。</li>
</ol>
<h2 id="25、说一下STL每种容器对应的迭代器"><a href="#25、说一下STL每种容器对应的迭代器" class="headerlink" title="25、说一下STL每种容器对应的迭代器"></a>25、说一下STL每种容器对应的迭代器</h2><table>
<thead>
<tr>
<th>容器</th>
<th>迭代器</th>
</tr>
</thead>
<tbody><tr>
<td>vector、deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>stack、queue、priority_queue</td>
<td>无</td>
</tr>
<tr>
<td>list、(multi)set&#x2F;map</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>unordered_(multi)set&#x2F;map、forward_list</td>
<td>前向迭代器</td>
</tr>
</tbody></table>
<h2 id="26、STL中迭代器失效的情况有哪些？"><a href="#26、STL中迭代器失效的情况有哪些？" class="headerlink" title="26、STL中迭代器失效的情况有哪些？"></a>26、STL中迭代器失效的情况有哪些？</h2><p>以vector为例：</p>
<p>插入元素：</p>
<p>1、尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p>
<p>2、中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p>
<p><strong>删除元素：</strong></p>
<p>尾后删除：只有尾迭代失效。</p>
<p>中间删除：删除位置之后所有迭代失效。</p>
<p>deque 和 vector 的情况类似,</p>
<p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p>
<p>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p>
<p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p>
<h2 id="27、STL中vector的实现"><a href="#27、STL中vector的实现" class="headerlink" title="27、STL中vector的实现"></a>27、STL中vector的实现</h2><p>vector是一种序列式容器，其数据安排以及操作方式与array非常类似，两者的唯一差别就是对于空间运用的灵活性，众所周知，array占用的是静态空间，一旦配置了就不可以改变大小，如果遇到空间不足的情况还要自行创建更大的空间，并手动将数据拷贝到新的空间中，再把原来的空间释放。vector则使用灵活的动态空间配置，维护一块<strong>连续的线性空间</strong>，在空间不足时，可以自动扩展空间容纳新元素，做到按需供给。其在扩充空间的过程中仍然需要经历：<strong>重新配置空间，移动数据，释放原空间</strong>等操作。这里需要说明一下动态扩容的规则：以原大小的两倍配置另外一块较大的空间（或者旧长度+新增元素的个数），源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> size_type len  = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>Vector扩容倍数与平台有关，在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍</p>
<p>测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在Linux + GCC下</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//4</span></span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//8</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在 win 10 + VS2019下</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl; <span class="comment">//2</span></span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//3</span></span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">	res.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; res.<span class="built_in">capacity</span>() &lt;&lt;endl;<span class="comment">//6</span></span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>运行上述代码，一开始配置了一块长度为2的空间，接下来插入一个数据，长度变为原来的两倍，为4，此时已占用的长度为3，再继续两个数据，此时长度变为8，可以清晰的看到空间的变化过程</p>
<p>需要注意的是，频繁对vector调用push_back()对性能是有影响的，这是因为每插入一个元素，如果空间够用的话还能直接插入，若空间不够用，则需要重新配置空间，移动数据，释放原空间等操作，对程序性能会造成一定的影响</p>
<h2 id="28、STL中slist的实现"><a href="#28、STL中slist的实现" class="headerlink" title="28、STL中slist的实现"></a>28、STL中slist的实现</h2><p>list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。</p>
<p>根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的</p>
<p>slist的单向迭代器如下图所示：</p>
<p><img src="http://oss.interviewguide.cn/img/202205071953335.png" alt="img"></p>
<p>slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">template &lt;class T, class Allco = alloc&gt;</span><br><span class="line">class slist</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">private:</span><br><span class="line">    ...</span><br><span class="line">    static list_node* create_node(const value_type&amp; x)&#123;&#125;//配置空间、构造元素</span><br><span class="line">    static void destroy_node(list_node* node)&#123;&#125;//析构函数、释放空间</span><br><span class="line">private:</span><br><span class="line">    list_node_base head; //头部</span><br><span class="line">public:</span><br><span class="line">    iterator begin()&#123;&#125;</span><br><span class="line">    iterator end()&#123;&#125;</span><br><span class="line">    size_type size()&#123;&#125;</span><br><span class="line">    bool empty()&#123;&#125;</span><br><span class="line">    void swap(slist&amp; L)&#123;&#125;//交换两个slist，只需要换head即可</span><br><span class="line">    reference front()&#123;&#125; //取头部元素</span><br><span class="line">    void push_front(const value&amp; x)&#123;&#125;//头部插入元素</span><br><span class="line">    void pop_front()&#123;&#125;//从头部取走元素</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;forward_list&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	forward_list&lt;int&gt; fl;</span><br><span class="line">	fl.push_front(1);</span><br><span class="line">	fl.push_front(3);</span><br><span class="line">	fl.push_front(2);</span><br><span class="line">	fl.push_front(6);</span><br><span class="line">	fl.push_front(5);</span><br><span class="line"></span><br><span class="line">	forward_list&lt;int&gt;::iterator ite1 = fl.begin();</span><br><span class="line">	forward_list&lt;int&gt;::iterator ite2 = fl.end();</span><br><span class="line">	for(;ite1 != ite2; ++ite1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *ite1 &lt;&lt;&quot; &quot;; // 5 6 2 3 1</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ite1 = find(fl.begin(), fl.end(), 2); //寻找2的位置</span><br><span class="line"></span><br><span class="line">	if (ite1 != ite2)</span><br><span class="line">		fl.insert_after(ite1, 99);</span><br><span class="line">	for (auto it : fl)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; &quot; &quot;;  //5 6 2 99 3 1</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	ite1 = find(fl.begin(), fl.end(), 6); //寻找6的位置</span><br><span class="line">	if (ite1 != ite2)</span><br><span class="line">		fl.erase_after(ite1);</span><br><span class="line">	for (auto it : fl)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; it &lt;&lt; &quot; &quot;;  //5 6 99 3 1</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++ 11中出现，它与slist的区别是没有size()方法。</p>
<h2 id="29、STL中list的实现"><a href="#29、STL中list的实现" class="headerlink" title="29、STL中list的实现"></a>29、STL中list的实现</h2><p>相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“–”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。</p>
<p>list节点的结构见如下源码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct __list_node&#123;</span><br><span class="line">    typedef void* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。</p>
<p>此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构</p>
<p>list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间</p>
<p>由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作，这里不再详细阐述。</p>
<h2 id="30、STL中的deque的实现"><a href="#30、STL中的deque的实现" class="headerlink" title="30、STL中的deque的实现"></a>30、STL中的deque的实现</h2><p>vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）</p>
<p><img src="http://oss.interviewguide.cn/img/202205071953980.png" alt="img"></p>
<p>deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来</p>
<p>deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque</p>
<p>deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性</p>
<p>deque的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer;<span class="comment">//指向map指针的指针</span></span><br><span class="line">    map_pointer map;<span class="comment">//指向map</span></span><br><span class="line">    size_type map_size;<span class="comment">//map的大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="http://oss.interviewguide.cn/img/202205220021322.png" alt="img"></p>
<p>deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示。</p>
<p>deque的迭代器数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    T* cur;<span class="comment">//迭代器所指缓冲区当前的元素</span></span><br><span class="line">    T* first;<span class="comment">//迭代器所指缓冲区第一个元素</span></span><br><span class="line">    T* last;<span class="comment">//迭代器所指缓冲区最后一个元素</span></span><br><span class="line">    map_pointer node;<span class="comment">//指向map中的node</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素</p>
<p><img src="http://oss.interviewguide.cn/img/202205220021453.png" alt="img"></p>
<p>deque迭代器的“++”、“–”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。</p>
<h2 id="31、STL中stack和queue的实现"><a href="#31、STL中stack和queue的实现" class="headerlink" title="31、STL中stack和queue的实现"></a>31、STL中stack和queue的实现</h2><p><strong>stack</strong></p>
<p>stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p>
<p><img src="http://oss.interviewguide.cn/img/202205220021348.png" alt="img"></p>
<p>stack这种单向开口的数据结构很容易由<strong>双向开口的deque和list</strong>形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非container</p>
<p>stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。</p>
<p><strong>queue</strong></p>
<p>queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：</p>
<p><img src="http://oss.interviewguide.cn/img/202205220021436.png" alt="img"></p>
<p>类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> queue</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> value_type&amp; x)</span></span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。</p>
<p>同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。</p>
<h2 id="32、STL中的heap的实现"><a href="#32、STL中的heap的实现" class="headerlink" title="32、STL中的heap的实现"></a>32、STL中的heap的实现</h2><p>heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。</p>
<p>binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树</p>
<img src="http://oss.interviewguide.cn/img/202205220021792.png" alt="img" style="zoom:67%;" />

<p>完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于$i$处，其左节点必定位于$2i$处，右节点位于$2i+1$处，父节点位于$i&#x2F;2$（向下取整）处。这种以array表示tree的方式称为隐式表述法。</p>
<p>因此我们可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，用vector代替array是一个不错的选择。</p>
<p>那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。</p>
<p><strong>push_heap插入算法</strong></p>
<p>由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举个例子如下图：</p>
<p><img src="http://oss.interviewguide.cn/img/202205220022842.png" alt="img"></p>
<p>新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足max heap的性质，如果了解大根堆的话，这个原理跟大根堆的调整过程是一样的。</p>
<p><strong>pop_heap算法</strong></p>
<p>heap的pop操作实际弹出的是根节点吗，但在heap内部执行pop_heap时，只是将其移动到vector的最后位置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶节点为止，这个过程称为percolate down（下溯）。举个例子：</p>
<p><img src="http://oss.interviewguide.cn/img/202205220022993.png" alt="img"></p>
<p>根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。</p>
<p><strong>sort算法</strong></p>
<p>一言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。</p>
<p><strong>make_heap算法</strong></p>
<p>将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。</p>
<p>代码实测：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">	<span class="built_in">make_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//以vector为底层容器</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 6 4 5 3 1 0 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">push_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 7 6 5 4 1 0 2 3</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">pop_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">// 7 </span></span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 6 4 5 3 1 0 2</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">sort_heap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 0 1 2 3 4 5 6</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="33、STL中的priority-queue的实现"><a href="#33、STL中的priority-queue的实现" class="headerlink" title="33、STL中的priority_queue的实现"></a>33、STL中的priority_queue的实现</h2><p>priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220022333.png" alt="img"></p>
<p>默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。关键的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Squence</span> = vector&lt;T&gt;, </span><br><span class="line"><span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Sequence::value_tyoe&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c; <span class="comment">// 底层容器</span></span><br><span class="line">    Compare comp; <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>()&#125;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push</span>(<span class="type">const</span> value_type&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_heap</span>(x);</span><br><span class="line">        <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(),comp);</span><br><span class="line">        c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span> &#125;;</span><br><span class="line">	<span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq</span><span class="params">(ia, ia + <span class="number">9</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; pq.<span class="built_in">size</span>() &lt;&lt;endl;  <span class="comment">// 9</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pq.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 8 8 8 8 8 8 8 8 8</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pq.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">// 8 7 6 5 4 3 2 1 0</span></span><br><span class="line">		pq.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>





<h2 id="34、STL中set的实现？"><a href="#34、STL中set的实现？" class="headerlink" title="34、STL中set的实现？"></a>34、STL中set的实现？</h2><p>STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。</p>
<p>set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值</p>
<p>set不允许迭代器修改元素的值，其迭代器是一种constance iterators</p>
<p>标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：</p>
<ul>
<li>每个节点不是红色就是黑色</li>
<li>根结点为黑色</li>
<li>如果节点为红色，其子节点必为黑</li>
<li>任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同</li>
</ul>
<p>关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> ia[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">10</span>) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">3</span>); <span class="comment">//再插入一个3</span></span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator b = s.<span class="built_in">begin</span>();</span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator e = s.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">for</span> (; b != e; ++b)</span><br><span class="line">		cout &lt;&lt; *b &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 2 3 4 5</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (b != s.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;5 found&quot;</span> &lt;&lt; endl; <span class="comment">// 5 found</span></span><br><span class="line"></span><br><span class="line">	b = s.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (b != s.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;2 found&quot;</span> &lt;&lt; endl; <span class="comment">// 2 found</span></span><br><span class="line"></span><br><span class="line">	b = s.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (b == s.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 not found&quot;</span> &lt;&lt; endl; <span class="comment">// 1 not found</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。</p>
<h2 id="35、STL中map的实现"><a href="#35、STL中map的实现" class="headerlink" title="35、STL中map的实现"></a>35、STL中map的实现</h2><p>map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key</p>
<p>一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator</p>
<p>标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的架构如下图所示</p>
<img src="http://oss.interviewguide.cn/img/202205220022980.png" alt="img" style="zoom: 67%;" />

<p>map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt; maps;</span><br><span class="line">    <span class="comment">//插入若干元素</span></span><br><span class="line">	maps[<span class="string">&quot;jack&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">	maps[<span class="string">&quot;jane&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">	maps[<span class="string">&quot;july&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//以pair形式插入</span></span><br><span class="line">	<span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;david&quot;</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	maps.<span class="built_in">insert</span>(p);</span><br><span class="line">	<span class="comment">//迭代输出元素</span></span><br><span class="line">	map&lt;string, <span class="type">int</span>&gt;::iterator iter = maps.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; iter != maps.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;--&quot;</span>; <span class="comment">//david 4--jack 1--jane 2--july 3--</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//使用subscipt操作取实值</span></span><br><span class="line">	<span class="type">int</span> num = maps[<span class="string">&quot;july&quot;</span>];</span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">	<span class="comment">//查找某key</span></span><br><span class="line">	iter = maps.<span class="built_in">find</span>(<span class="string">&quot;jane&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(iter != maps.<span class="built_in">end</span>())</span><br><span class="line">		cout &lt;&lt; iter-&gt;second &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">//修改实值</span></span><br><span class="line">	iter-&gt;second = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> num2 = maps[<span class="string">&quot;jane&quot;</span>]; <span class="comment">// 100</span></span><br><span class="line">	cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">maps[<span class="string">&quot;abc&quot;</span>] = <span class="number">1</span>; <span class="comment">//左值运用int num = masp[&quot;abd&quot;]; //右值运用</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>无论如何，subscript操作符都会先根据键值找出实值，源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...T&amp; <span class="keyword">operator</span>[](<span class="type">const</span> key_type&amp; k)&#123;	</span><br><span class="line">    <span class="keyword">return</span> (*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second;</span><br><span class="line">&#125;...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">value_type</span>(k, <span class="built_in">T</span>());</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>再将这个对象插入到map中，并返回一个pair：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(value_type(k, T()))</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first; <span class="comment">//迭代器</span></span><br><span class="line">*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first); <span class="comment">//解引用</span></span><br><span class="line">(*((<span class="built_in">insert</span>(<span class="built_in">value_type</span>(k, <span class="built_in">T</span>()))).first)).second; <span class="comment">//取出实值</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>由于这个实值是以引用方式传递，因此作为左值或者右值都可以</p>
<h2 id="36、set和map的区别，multimap和multiset的区别"><a href="#36、set和map的区别，multimap和multiset的区别" class="headerlink" title="36、set和map的区别，multimap和multiset的区别"></a>36、set和map的区别，multimap和multiset的区别</h2><p>set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素</p>
<p>map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction（），保存的确实是两份元素。</p>
<p>他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 。</p>
<p>multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。</p>
<p><strong>红黑树概念</strong></p>
<p>面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。</p>
<p>1、它是二叉排序树（继承二叉排序树特显）：</p>
<ul>
<li><p>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。</p>
</li>
<li><p>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。</p>
<ul>
<li>左、右子树也分别为二叉排序树。</li>
</ul>
<p>2、它满足如下几点要求：</p>
<ul>
<li>树中所有节点非红即黑。</li>
<li>根节点必为黑节点。</li>
<li>红节点的子节点必为黑（黑节点子节点可为黑）。</li>
<li>从根到NULL的任何路径上黑结点数相同。</li>
</ul>
<p>3、查找时间一定可以控制在O(logn)。</p>
</li>
</ul>
<h2 id="37、STL中unordered-map和map的区别和应用场景"><a href="#37、STL中unordered-map和map的区别和应用场景" class="headerlink" title="37、STL中unordered_map和map的区别和应用场景"></a>37、STL中unordered_map和map的区别和应用场景</h2><p>map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为$O(logn)$，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息</p>
<p>unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大</p>
<p>从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景</p>
<h2 id="38、hashtable中解决冲突有哪些方法？"><a href="#38、hashtable中解决冲突有哪些方法？" class="headerlink" title="38、hashtable中解决冲突有哪些方法？"></a>38、hashtable中解决冲突有哪些方法？</h2><p><strong>记住前三个：</strong></p>
<p>线性探测</p>
<p>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p>
<p><strong>开链</strong></p>
<p>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p>
<p><strong>再散列</strong></p>
<p>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p>
<p><strong>二次探测</strong></p>
<p>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p>
<p><strong>公共溢出区</strong></p>
<p>一旦hash函数计算的结果相同，就放入公共溢出区</p>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-C++内存管理</title>
    <url>/2023/07/15/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h1><h2 id="1、类的对象存储空间？"><a href="#1、类的对象存储空间？" class="headerlink" title="1、类的对象存储空间？"></a>1、类的对象存储空间？</h2><ul>
<li>非静态成员的数据类型大小之和。</li>
<li>编译器加入的额外成员变量（如指向虚函数表的指针）。</li>
<li>为了边缘对齐优化加入的padding。</li>
</ul>
<p>空类(无非静态数据成员)的对象的size为1, 当作为基类时, size为0.</p>
<h2 id="2、简要说明C-的内存分区"><a href="#2、简要说明C-的内存分区" class="headerlink" title="2、简要说明C++的内存分区"></a>2、简要说明C++的内存分区</h2><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。如下图所示</p>
<p><img src="http://oss.interviewguide.cn/img/202205220021689.png" alt="img"></p>
<p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p><strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价。</p>
<p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p><strong>代码区</strong>：存放函数体的二进制代码</p>
<h2 id="3、什么是内存池，如何实现"><a href="#3、什么是内存池，如何实现" class="headerlink" title="3、什么是内存池，如何实现"></a>3、什么是内存池，如何实现</h2><p>内存池（Memory Pool） 是一种<strong>内存分配</strong>方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<p>这里<strong>简单描述一下《STL源码剖析》中的内存池实现机制</strong>：</p>
<p><strong>allocate 包装 malloc，deallocate包装free</strong></p>
<p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小。</p>
<ol>
<li>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</li>
<li>客户端之后有有内存需求，想申请（20<em>64bytes）的空间，这时内存池只有（20</em>32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也.</li>
<li>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</li>
<li>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</li>
</ol>
<p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。</p>
<p>内部实现，目前的所有编译器都是直接调用的::operator new()和::operator delete()，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
<p><strong>其实最开始GC2.9之前</strong></p>
<p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p>
<p>operator new()里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p>
<p>GC2.9下的alloc函数的一个比较好的分配器的实现规则如下：</p>
<p>维护一条0-15号的一共16条链表，其中 0 号表示8 bytes ，1 号表示 16 bytes，2 号表示 24 bytes。。。。而15 号表示 16* 8 &#x3D; 128 bytes。</p>
<p>如果在申请内存时，申请内存的大小并不是8的倍数（比如2、4、7、9、18这样不是8的倍数），那就找刚好能满足内存大小的链表。比如想申请 12 个大小，那就按照 16 来处理，也就是找 1 号链表了；想申请 20 ，距离它最近的就是 24 了，那就找 2 号链表。</p>
<p>只许比所要申请的内容大，不许小！</p>
<p><strong>但是现在GC4.9及其之后</strong> 也还有 alloc 函数，只不过已经变成_pool_alloc这个名字了，名字已经改了，也不再是默认的了。</p>
<p>你需要自己手动去指定它可以自己指定，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;string,__gnu_cxx::pool_alloc&lt;string&gt;&gt; vec;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这样来使用它，等于兜兜转转又回到以前那种对malloc和free的包装形式了。</p>
<h2 id="4、可以说一下你了解的C-得内存管理吗？"><a href="#4、可以说一下你了解的C-得内存管理吗？" class="headerlink" title="4、可以说一下你了解的C++得内存管理吗？"></a>4、可以说一下你了解的C++得内存管理吗？</h2><p>在C++中，内存分成5个区，他们分别是堆、栈、全局&#x2F;静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局&#x2F;静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<h2 id="5、C-中类的数据成员和成员函数内存分布情况"><a href="#5、C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="5、C++中类的数据成员和成员函数内存分布情况"></a>5、C++中类的数据成员和成员函数内存分布情况</h2><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。 类分为成员变量和成员函数，我们先来讨论成员变量。</p>
<p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age地址：&quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p.age) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//对象地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//age地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//对象大小：4</span></span><br><span class="line"><span class="comment">//age大小：4</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<p>要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。</p>
<p>我们再来补充一下静态成员函数的存放问题：<strong>静态成员函数与一般成员函数的唯一区别就是没有this指针</strong>，因此不能访问非静态数据成员。</p>
<p>就像我前面提到的，<strong>所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</strong></p>
<h2 id="6、关于this指针你知道什么？全说出来"><a href="#6、关于this指针你知道什么？全说出来" class="headerlink" title="6、关于this指针你知道什么？全说出来"></a>6、关于this指针你知道什么？全说出来</h2><ul>
<li>this指针是类的指针，指向对象的首地址。</li>
<li>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</li>
<li>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</li>
</ul>
<p><strong>this指针的用处</strong></p>
<p>一个对象的this指针并不是对象本身的一部分，不会影响 sizeof(对象) 的结果。this作用域是在类内部，当在类的<strong>非静态成员函数</strong>中访问类的<strong>非静态成员</strong>的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
<p><strong>this指针的使用</strong></p>
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p>
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n &#x3D; n （不能写成n &#x3D; n）</p>
<p><strong>类的this指针有以下特点</strong></p>
<p>(1）<strong>this</strong>只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，<strong>传入参数为当前对象地址，成员函数第一个参数为</strong>为<strong>T * const this</strong></p>
<p>如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class A&#123;public:	int func(int p)&#123;&#125;&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>其中，<strong>func</strong>的原型在编译器看来应该是：</p>
<p><strong>int func(A * const this,int p);</strong></p>
<p>（2）由此可见，<strong>this</strong>在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A a;a.func(10);//此处，编译器将会编译成：A::func(&amp;a,10);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h2 id="7、几个this指针的易混问题"><a href="#7、几个this指针的易混问题" class="headerlink" title="7、几个this指针的易混问题"></a>7、几个this指针的易混问题</h2><h3 id="A-this指针是什么时候创建的？"><a href="#A-this指针是什么时候创建的？" class="headerlink" title="A. this指针是什么时候创建的？"></a>A. this指针是什么时候创建的？</h3><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p>
<h3 id="B-this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#B-this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="B. this指针存放在何处？堆、栈、全局变量，还是其他？"></a>B. this指针存放在何处？堆、栈、全局变量，还是其他？</h3><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
<h3 id="C-this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><a href="#C-this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？" class="headerlink" title="C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"></a>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h3><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p>
<h3 id="D-this指针是如何访问类中的变量的？"><a href="#D-this指针是如何访问类中的变量的？" class="headerlink" title="D. this指针是如何访问类中的变量的？"></a>D. this指针是如何访问类中的变量的？</h3><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p>
<h3 id="E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#E-我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>E.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h3><p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<h3 id="F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#F-每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>F.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h3><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p>
<h2 id="8、-内存泄漏的后果？如何监测？解决方法？"><a href="#8、-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="8、 内存泄漏的后果？如何监测？解决方法？"></a>8、 内存泄漏的后果？如何监测？解决方法？</h2><p><strong>1) 内存泄漏</strong></p>
<p>内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制；</p>
<p><strong>2) 后果</strong></p>
<p>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种证照：性能下降到内存逐渐用完，导致另一个程序失败；</p>
<p><strong>3) 如何排除</strong></p>
<p>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；</p>
<p>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</p>
<p><strong>4) 解决方法</strong></p>
<p>智能指针。</p>
<p><strong>5) 检查、定位内存泄漏</strong></p>
<p>检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：</p>
<p>输出这样的格式{453}normal block at 0x02432CA8,868 bytes long</p>
<p>被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。</p>
<p>定位代码位置</p>
<p>在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include &lt;crtdbg.h&gt;</p>
<h2 id="9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#9、在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>9、在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h2><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<h2 id="10、为什么是不可预期的问题？"><a href="#10、为什么是不可预期的问题？" class="headerlink" title="10、为什么是不可预期的问题？"></a>10、为什么是不可预期的问题？</h2><p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<h2 id="11、-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#11、-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="11、 如果在类的析构函数中调用delete this，会发生什么？"></a>11、 如果在类的析构函数中调用delete this，会发生什么？</h2><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h2 id="12、你知道空类的大小是多少吗？"><a href="#12、你知道空类的大小是多少吗？" class="headerlink" title="12、你知道空类的大小是多少吗？"></a>12、你知道空类的大小是多少吗？</h2><ol>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ol>
<h2 id="13、请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#13、请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="13、请说一下以下几种情况下，下面几个类的大小各是多少？"></a>13、请说一下以下几种情况下，下面几个类的大小各是多少？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)&#x3D;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h2 id="14、this指针调用成员变量时，堆栈会发生什么变化？"><a href="#14、this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="14、this指针调用成员变量时，堆栈会发生什么变化？"></a>14、this指针调用成员变量时，堆栈会发生什么变化？</h2><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h2 id="15、类对象的大小受哪些因素影响？"><a href="#15、类对象的大小受哪些因素影响？" class="headerlink" title="15、类对象的大小受哪些因素影响？"></a>15、类对象的大小受哪些因素影响？</h2><ol>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ol>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/08/08/Linux/</url>
    <content><![CDATA[<h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092049628.png" alt="image-20230808092049628"></p>
<h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092036780.png" alt="image-20230808092036780"></p>
<h3 id="Linux与Windows的区别"><a href="#Linux与Windows的区别" class="headerlink" title="Linux与Windows的区别"></a>Linux与Windows的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092003642.png" alt="image-20230808092003642"></p>
<hr>
<h1 id="Linux文件与目录结构"><a href="#Linux文件与目录结构" class="headerlink" title="Linux文件与目录结构"></a>Linux文件与目录结构</h1><blockquote>
<p>Ctrl + ALT + F2 由Linux的图形化桌面—→命令行模式</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666887161931-bb67d150-f484-47f3-86b0-11c1330f170d.png" alt="img"></p>
<blockquote>
<p>Ctrl + Alt + F1 由命令行模式—→图形化模式</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666887342842-bd7612b4-fa97-4d4e-9905-4765a61e6c46.png" alt="img"></p>
<h3 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h3><p>Linux系统中一切皆文件</p>
<h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>层级式目录文件</p>
<p>&#x2F; 根目录</p>
<blockquote>
<p>Linux的目录关系是虚拟的，逻辑上的关系。在现实物理实际中，各个磁盘目录可能不在一个物理区域</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092842962.png" alt="image-20230808092842962"></p>
<blockquote>
<p>cd &#x2F;<br>ls</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666888964619-8f388d58-7642-43df-9e93-bb1ad0043a78.png" alt="img"></p>
<p><font color=Red>&#x2F;bin</font></p>
<ul>
<li>是Binary的缩写，这个目录存放着最经常使用的命令。</li>
</ul>
<p><font color=Red>红色</font></p>
<p>&#x2F;sbin</p>
<ul>
<li>s是super user的意思，存放系统管理员可以操作的系统管理程序。</li>
</ul>
<p><font color=Red>&#x2F;home</font></p>
<ul>
<li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
</ul>
<p><font color=Red>&#x2F;root</font></p>
<ul>
<li>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
</ul>
<p>&#x2F;lib</p>
<ul>
<li>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li>
</ul>
<p><font color=Red>&#x2F;etc</font></p>
<ul>
<li>存放系统环境所需要的配置文件和对应的子目录。</li>
</ul>
<p><font color=Red>&#x2F;usr</font></p>
<ul>
<li>用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li>
</ul>
<p><font color=Red>&#x2F;boot</font></p>
<ul>
<li>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。</li>
</ul>
<p>&#x2F;proc</p>
<ul>
<li>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
</ul>
<p>&#x2F;srv</p>
<ul>
<li>service缩写，该目录存放一些服务启动之后需要提取的数据。</li>
</ul>
<p>&#x2F;sys</p>
<ul>
<li>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。</li>
</ul>
<p>&#x2F;tmp</p>
<ul>
<li>这个目录是用来存放一些临时文件的。</li>
</ul>
<p>&#x2F;dev</p>
<ul>
<li>类似于windows的设备管理器，把所有的硬件用文件的形式存储</li>
</ul>
<p><font color=Red>&#x2F;media(CentOS 6)</font></p>
<ul>
<li>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后linux会把识别的设备挂载到这个目录下。</li>
<li>CentOS 7迁移到&#x2F;run&#x2F;media</li>
</ul>
<p><font color=Red>&#x2F;mnt</font></p>
<ul>
<li>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。</li>
</ul>
<p><font color=Red>&#x2F;opt</font></p>
<ul>
<li>这是给主机额外安装软件所摆放的目录。比如你安装一个mysql数据库则就可以放到这个目录下。默认是空的。</li>
</ul>
<p><font color=Red>&#x2F;var</font></p>
<ul>
<li>我们习惯将那些经常被修改的目这个目录中存放着在不断扩充着的东西录放在这个目录下。包括各种日志文件。</li>
</ul>
<hr>
<h1 id="VI-VIM-编辑器⭐"><a href="#VI-VIM-编辑器⭐" class="headerlink" title="VI&#x2F;VIM 编辑器⭐"></a>VI&#x2F;VIM 编辑器⭐</h1><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。 </p>
<p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容、</p>
<h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><p>VI &#x2F; VIM有三种模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808095737948.png" alt="image-20230808095737948"></p>
<h4 id="一般模式常用语法"><a href="#一般模式常用语法" class="headerlink" title="一般模式常用语法"></a>一般模式常用语法</h4><ol>
<li><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808095937262.png" alt="image-20230808095937262"></li>
</ol>
<blockquote>
<dl><dt>w 移动一个词<br>e 移动到一个词的词尾<br>b 调到上一个词的词头<br>gg 移动到当前文档的开头<br>H 移动到当前文档的开头<br>L&#x2F;G 移动到当前文档的行尾<br>3G 跳转到第三行的行头<br>: set nu 显示行号</dt><dd>set nonu 隐藏行号</dd></dl></blockquote>
<h4 id="编辑模式常用语法"><a href="#编辑模式常用语法" class="headerlink" title="编辑模式常用语法"></a>编辑模式常用语法</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808100238706.png" alt="image-20230808100238706"></p>
<h4 id="命令模式常用语法"><a href="#命令模式常用语法" class="headerlink" title="命令模式常用语法"></a>命令模式常用语法</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808100349741.png" alt="image-20230808100349741"></p>
<hr>
<h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p>VMware提供了三种网络连接模式：</p>
<ol>
<li>桥接模式：虚拟机直接连接外部物理网络的模式，主机起到了网桥的作用。在这种模式下，虚拟机可以直接访问外部网络，并且对外部网络是可见的</li>
<li>NAT模式：虚拟机和主机构建一个专用网络，并通过虚拟网络地址转换（NAT）设备对IP进行转换。虚拟机通过共享主机IP可以访问外部网络，但外部网络无法访问虚拟机。</li>
<li>仅主机模式：虚拟机只与主机共享一个专用网络，与外部网络无法通信</li>
</ol>
<h3 id="配置网络ip地址"><a href="#配置网络ip地址" class="headerlink" title="配置网络ip地址"></a>配置网络ip地址</h3><h4 id="ifconfig配置网络接口"><a href="#ifconfig配置网络接口" class="headerlink" title="ifconfig配置网络接口"></a>ifconfig配置网络接口</h4><p>ifconfig :network interfaces configuring 网络接口配</p>
<p>**1）基本语法 **</p>
<p>​	ifconfig （功能描述：显示所有网络接口的配置信息）</p>
<p><strong>2）案例实操</strong></p>
<p>​	 查看当前网络 ip</p>
<p><code>&#39;[root@hadoop100 桌面]# ifconfig&#39;</code></p>
<h4 id="ping-测试主机之间网络连通性"><a href="#ping-测试主机之间网络连通性" class="headerlink" title="ping 测试主机之间网络连通性"></a>ping 测试主机之间网络连通性</h4><p>**1）基本语法 **</p>
<p>​	ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</p>
<p>**2）案例实操 **</p>
<p>​	测试当前服务器是否可以连接百度</p>
<p><code>[root@hadoop100 桌面]# ping www.baidu.com</code></p>
<h4 id="修改IP地址"><a href="#修改IP地址" class="headerlink" title="修改IP地址"></a>修改IP地址</h4><p><strong>1） 查看 IP 配置文件，如图所示</strong></p>
<p><code>[root@hadoop100  桌面]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101708745.png" alt="image-20230808101708745"></p>
<p>以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101835983.png" alt="image-20230808101835983"></p>
<p>修改后，如图 所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101906031.png" alt="image-20230808101906031"></p>
<p>编辑完后，按键盘 esc ，然后输入 :wq 回车即可。</p>
<p><strong>2）执行 service network restart 重启网络,如图所示</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101950224.png" alt="image-20230808101950224"></p>
<hr>
<h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><h4 id="修改主机名-1"><a href="#修改主机名-1" class="headerlink" title="修改主机名"></a>修改主机名</h4><p>**1） 基本语法 **</p>
<p>​	hostname （功能描述：查看当前服务器的主机名称）</p>
<p> <strong>2） 案例实操</strong></p>
<p>​	（1）查看当前服务器主机名称</p>
<p><code>[root@hadoop100 桌面]# hostname</code></p>
<p>​	（2）如果感觉此主机名不合适，我们可以进行修改。通过编辑&#x2F;etc&#x2F;hostname 文件</p>
<p><code>[root@hadoop100 桌面]# vi /etc/hostname</code></p>
<p>​	修改完成后重启生效。</p>
<h4 id="修改-hosts-映射文件"><a href="#修改-hosts-映射文件" class="headerlink" title="修改 hosts 映射文件"></a>修改 hosts 映射文件</h4><p>**1）修改 linux 的主机映射文件（hosts 文件） **</p>
<p>​	后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置， 比较	简单方便。 不用刻意记 ip 地址。 </p>
<p>​	（1）打开&#x2F;etc&#x2F;hosts</p>
<p><code>[root@hadoop100 桌面]# vim /etc/hosts</code></p>
<p>​	添加如下内容</p>
<blockquote>
<p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p>
</blockquote>
<p>​	（2）重启设备，重启后，查看主机名，已经修改成功</p>
<p><strong>2）修改 windows 的主机映射文件（hosts 文件)</strong></p>
<p>​	（1）进入 C:\Windows\System32\drivers\etc 路径 </p>
<p>​	（2）打开 hosts 文件并添加如下内容</p>
<blockquote>
<p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p>
</blockquote>
<p>**3）修改 window10 的主机映射文件（hosts 文件） **</p>
<p>​	（1）进入 C:\Windows\System32\drivers\etc 路径 </p>
<p>​	（2）拷贝 hosts 文件到桌面 </p>
<p>​	（3）打开桌面 hosts 文件并添加如下内</p>
<blockquote>
<p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p>
</blockquote>
<p><strong>（4）将桌面 hosts 文件覆盖 C:\Windows\System32\drivers\etc 路径 hosts 文件</strong></p>
<hr>
<h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>使用xshell7这个软件进行演示</p>
<ol>
<li>创建一个新的会话连接，输入此次会话的名称，选择SSH协议，端口号默认</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210185493-a72d3b6d-4c11-4fea-9e5f-91146051454f.png" alt="img"></p>
<ol>
<li>用户身份登录验证，选择password</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210268385-cdd119da-d98a-40e8-8db7-ae4cd23c019b.png" alt="img"></p>
<p>也可以在外观选项中，修改控制台的字体大小颜色</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210323737-fdd6192a-c6f7-46a5-8ed8-cb1fcbafd7af.png" alt="img"></p>
<p>设置复制粘贴快捷方式</p>
<p>工具–&gt;选项–&gt;键盘和鼠标</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808151347728.png" alt="image-20230808151347728"></p>
<p>图形化传输LinuxOS中的文件，使用Xftp7软件演示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808103010077.png" alt="image-20230808103010077"></p>
<hr>
<h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h3 id="Linux中的进程和服务"><a href="#Linux中的进程和服务" class="headerlink" title="Linux中的进程和服务"></a>Linux中的进程和服务</h3><p>​	计算机中，一个正在执行的程序或命令，被叫做“进程”（process）</p>
<p>​	启动之后一直存在、常驻内存的进程，一般被称为”服务” （service）</p>
<h3 id="systemctl-CentOS-7版本"><a href="#systemctl-CentOS-7版本" class="headerlink" title="systemctl (CentOS 7版本)"></a>systemctl (CentOS 7版本)</h3><p><strong>1） 基本语法</strong></p>
<p>​	systemctl  start|stop|restart|status  服务名</p>
<p><code>[root@hadoop100 桌面]# ls /usr/lib/systemd/</code><br><code>[root@hadoop100 桌面]# systemctl status network</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270350370-d255b364-2135-4609-8ead-4dd9d94282ea.png" alt="img"></p>
<p><code>[root@hadoop100 桌面]# systemctl restart NetworkManager</code></p>
<p><strong>2）案例实操</strong></p>
<p>（1）查看防火墙服务的状态 </p>
<p><code>[root@hadoop100 桌面]# systemctl status firewalld </code></p>
<p>（2）停止防火墙服务</p>
<p><code>[root@hadoop100 桌面]# systemctl stop firewalld</code></p>
<p>（3）启动防火墙服务</p>
<p><code>[root@hadoop100 桌面]# systemctl start firewalld </code></p>
<p>（4）重启防火墙服务 </p>
<p><code>[root@hadoop100 桌面]# systemctl restart firewalld</code></p>
<h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p><strong>1）Linux 运行级别[CentOS 6]</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808104026046.png" alt="image-20230808104026046"></p>
<p><strong>2）CentOS7 的运行级别简化为:</strong></p>
<p>​	multi-user.target  等价于原运行级别3 （多用户有网，无图形界面）</p>
<p>​	graphical.target    等价于原运行级别5 （多用户有网，图形化界面）</p>
<p><strong>3） 查看当前运行级别</strong></p>
<p>​	systemctl get-default</p>
<p><strong>4）修改当前运行级别</strong></p>
<p>​	systemctl set-default TARGET.target  (这里TARGET取multi-user或者graphical)</p>
<h3 id="配置服务开机启动"><a href="#配置服务开机启动" class="headerlink" title="配置服务开机启动"></a>配置服务开机启动</h3><p><code>[root@hadoop100 桌面]# chkconfig --list</code><br><code>[root@hadoop100 桌面]# chkconfig --level 3 network off 网络服务运行级别3 关闭</code><br><code>[root@hadoop100 桌面]# chkconfig --level 2 newwork on  网络服务运行级别2 开启</code><br><code>[root@hadoop100 桌面]# chkconfig network off  关闭所有网络服务运行级别</code><br><code>[root@hadoop100 桌面]# chkconfig network on   开启默认网络服务运行级别</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667273528151-9d914b96-92d4-4b77-8d97-e515f0cfba0e.png" alt="img"></p>
<p><strong>设置网络服务开机不自启动</strong></p>
<p><code>systemctl disable NetworkManager</code>   默认设置NetworkManager开机不自启动</p>
<blockquote>
<p>命令行输出框中：vendor present：enabled  标识默认是开启的</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667282032875-7f811c4f-c2f6-44bf-87b5-0780f560c91e.png" alt="img"></p>
<p><code>systemctl enable NetworkMangaer</code><br><code>systemctl status NetworkManager</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667282201194-ec3e225d-e9bb-4382-8231-aded4867610c.png" alt="img"></p>
<p><code>systemctl list-unit-files</code><br>在Linux中所有的service和target等都被称为unit 单元</p>
<h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>1） 临时关闭防火墙 </p>
<p>​	（1）查看防火墙状态 </p>
<p><code>[root@hadoop100 桌面]# systemctl status firewalld </code></p>
<p>​	（2）临时关闭防火墙 </p>
<p><code>[root@hadoop100 桌面]# systemctl stop firew</code></p>
<p>2）开机启动时关闭防火墙 </p>
<p>​	（1）查看防火墙开机启动状态</p>
<p><code>[root@hadoop100 桌面]# systemctl enable firewalld.service </code></p>
<p>​	（2）设置开机时关闭防火墙</p>
<p><code>[root@hadoop100 桌面]# systemctl disable </code></p>
<p>根据下面截图说明</p>
<ol>
<li>一开始查看防火墙状态：开机不自启动，不是运行的</li>
<li>使其开机自启，查看状态，开机自启完成，但此时还没有在运行</li>
<li>开启防火墙运行，查看状态，在运行了（running）</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667286917290-6e226281-4e0b-4463-a67f-292e102a0f7a.png" alt="img"></p>
<h3 id="开机自启动服务"><a href="#开机自启动服务" class="headerlink" title="开机自启动服务"></a>开机自启动服务</h3><blockquote>
<p>setup  命令行终端敲setup之后，会出现下图情况</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270640955-cc97d012-1aed-43c5-ac5c-d76b463aa728.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270851633-e659a1c7-370d-480c-b95c-7ad24a1bfc8a.png" alt="img"></p>
<p>选择【系统服务】找到某个服务，选中【*】按空格，即可变成开机不启动设置</p>
<p>在Linux领域内大多数用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境，除非特殊情况下，不得已才会关机</p>
<p><strong>1)基本语法描述</strong></p>
<p>sync            (将数据由内存同步到硬盘中) </p>
<p>halt             (停机，关闭系统，但不断电)</p>
<p>poweroff   (关机，断电)</p>
<p>reboot        (就是重启，相当于shutdown -r now)</p>
<p>shutdown[选项] 时间</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-H</td>
<td>相当于–halt，停机</td>
</tr>
<tr>
<td>-r</td>
<td>-r&#x3D;reboot重启</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>now</td>
<td>立刻关机</td>
</tr>
<tr>
<td>时间</td>
<td>等待多久后关机（时间单位是分钟)</td>
</tr>
</tbody></table>
<p><strong>2)经验技巧</strong></p>
<p>Linux系统中为了提高磁盘的读写效率，对磁盘采取了”预读迟写“操作方式。当用户保存文件时，Linux核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘。这种方式可以极大的提高磁盘写入数据的效率。但是也带来了安全隐患。如果数据还没写入磁盘时，系统掉电或者其他严重问题出现，则将导致数据丢失。使用<code>sync</code>指令可以立即将缓冲区的数据写入磁盘</p>
<p><code>shutdown </code>       关机 会默认等待1min才会关机<br><code>shutdown now</code>    立即关机<br><code>shutdown 3 </code>     3min之后关机<br><code>shutdown -c </code>    取消关机<br><code>shutdown 16:20</code>  计划16:20关机</p>
<p><strong>3)案例实操</strong></p>
<p>（1）将数据由内存同步到硬盘中</p>
<p><code>[root@hadoop100 桌面]#sync </code></p>
<p>（2）重启 </p>
<p><code>[root@hadoop100 桌面]# reboot </code></p>
<p>（3）停机（不断电） </p>
<p><code>[root@hadoop100 桌面]#halt </code></p>
<p>（4）计算机将在 1 分钟后关机，并且会显示在登录用户的当前屏幕</p>
<p><code>[root@hadoop100 桌面]#shutdown -h 1 ‘This server will shutdown after 1 mins’ </code></p>
<p>（5）立马关机（等同于 poweroff）</p>
<p><code>[root@hadoop100 桌面]# shutdown -h now </code></p>
<p>（6）系统立马重启（等同于 reboot） </p>
<p><code>[root@hadoop100 桌面]# shutdown -r now</code></p>
<hr>
<h1 id="常用基本命令⭐"><a href="#常用基本命令⭐" class="headerlink" title="常用基本命令⭐"></a>常用基本命令⭐</h1><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd-显示当前工作目录的绝对路径"><a href="#pwd-显示当前工作目录的绝对路径" class="headerlink" title="pwd  显示当前工作目录的绝对路径"></a>pwd  显示当前工作目录的绝对路径</h4><p>pwd:print working directory 打印工作目录</p>
<p>**1）基本语法 **</p>
<p>​	pwd （功能描述：显示当前工作目录的绝对路径） </p>
<p>**2）案例实操 **</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667355600456-8b48d580-85ac-4a39-a34a-f2acf48b6575.png" alt="image.png"></p>
<h4 id="ls-列出目录的内"><a href="#ls-列出目录的内" class="headerlink" title="ls 列出目录的内"></a>ls 列出目录的内</h4><p>ls:list 列出目录内容</p>
<p>**1）基本语法 **</p>
<p>​	ls [选项] [目录或是文件] </p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>全部的文件，联通隐藏档（开头为.的文件）一起列出来（常用）</td>
</tr>
<tr>
<td>-l</td>
<td>长数据串列出，包含文件的数据与权限等等数据；(常用)等价于”ll”</td>
</tr>
</tbody></table>
<p>**3）显示说明 **</p>
<p>​	每行列出的信息依次是： <font color=Red>文件类型与权限 链接数 文件属主 文件属组 文件大小用byte 来表示 建立或最近修改的时间 名字</font></p>
<p><strong>4）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667357550167-0835e617-f31e-46b4-8a52-758daa9bbf09.png" alt="image.png"></p>
<h4 id="cd-切换目"><a href="#cd-切换目" class="headerlink" title="cd 切换目"></a>cd 切换目</h4><p>cd:Change Directory 切换路径</p>
<p>**1）基本语法 **</p>
<p>​	cd [参数] </p>
<p><strong>2）参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cd 绝对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd 相对路径</td>
<td>切换路径</td>
</tr>
<tr>
<td>cd ~或者 cd</td>
<td>回到自己的家目录</td>
</tr>
<tr>
<td>cd -</td>
<td>回到上一次所在目录</td>
</tr>
<tr>
<td>cd ..</td>
<td>回到当前目录的上一级目录</td>
</tr>
<tr>
<td>cd -P</td>
<td>跳转到实际物理路径，而非快捷方式路径</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112335725.png" alt="image-20230808112335725"></p>
<h4 id="mkdir-创建一个新的目录"><a href="#mkdir-创建一个新的目录" class="headerlink" title="mkdir 创建一个新的目录"></a>mkdir 创建一个新的目录</h4><p>mkdir:Make directory 建立目录</p>
<p><strong>1）基本语法 mkdir</strong></p>
<p>​	 [选项] 要创建的目录 </p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>创建多层目录</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112646870.png" alt="image-20230808112646870"></p>
<h4 id="rmdir删除一个空的目录"><a href="#rmdir删除一个空的目录" class="headerlink" title="rmdir删除一个空的目录"></a>rmdir删除一个空的目录</h4><p>​	rmdir:Remove directory 移除目录</p>
<p>**1）基本语法 **</p>
<p>​	rmdir 要删除的空目录 </p>
<p>**2）案例实操 **</p>
<p>​	（1）删除一个空的文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112826606.png" alt="image-20230808112826606"></p>
<h4 id="touch-创建空文件"><a href="#touch-创建空文件" class="headerlink" title="touch 创建空文件"></a>touch 创建空文件</h4><p>**1）基本语法 **</p>
<p>​	touch 文件名称</p>
<p>**2）案例实操 **</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667368541688-b1f7299f-8483-4998-a564-aa8483e5e47b.png" alt="image.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667368756484-403dd29e-4d1a-4a48-a58b-136ea76bc032.png" alt="image.png"></p>
<h4 id="cp复制文件或目录"><a href="#cp复制文件或目录" class="headerlink" title="cp复制文件或目录"></a>cp复制文件或目录</h4><p>**1）基本语法 ** </p>
<p>cp [选项] source dest （功能描述：复制source文件到dest）</p>
<p><strong>1）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归复制整个文件夹</td>
</tr>
</tbody></table>
<p><strong>3）参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>递归复制整个文件夹</td>
</tr>
<tr>
<td>source</td>
<td>源文件</td>
</tr>
<tr>
<td>dest</td>
<td>目标文件</td>
</tr>
</tbody></table>
<p>**4）经验技巧 **</p>
<p>​	强制覆盖不提示的方法：\cp</p>
<p>**5）案例实操 **</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113223773.png" alt="image-20230808113223773"></p>
<h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm 删除文件或目录"></a>rm 删除文件或目录</h4><p>**1）基本语法 **</p>
<p>​	rm [选项] deleteFile （功能描述：递归删除目录中所有内容）</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td>-r</td>
<td>递归删除目录中所有内容</td>
</tr>
<tr>
<td>-f</td>
<td>强制执行删除操作，而不提示用于进行确认。</td>
</tr>
<tr>
<td>-v</td>
<td>显示指令的详细执行过程</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p>​	（1）删除目录中的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113548955.png" alt="image-20230808113548955"></p>
<p>​	（2）递归删除目录中所有内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113556942.png" alt="image-20230808113556942"></p>
<h4 id="mv-移动文件与目录或重命名"><a href="#mv-移动文件与目录或重命名" class="headerlink" title="mv 移动文件与目录或重命名"></a>mv 移动文件与目录或重命名</h4><p>1）基本语法 </p>
<p>（1）<code>mv oldNameFile newNameFile</code> （功能描述：重命名） </p>
<p>（2）<code>mv /temp/movefile /targetFolder</code> （功能描述：移动文件）</p>
<p>将&#x2F;root目录下的 initial-setup-ks.cfg 文件，移动到 &#x2F;home&#x2F;atguigu&#x2F;下，此时&#x2F;root目录就没有该文件了</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667384782286-06471e0a-c547-4be4-9967-ef7084283174.png" alt="img"></p>
<p>mv 还可以将移动文件改名字</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667385292203-a61a3d21-f7c8-43a0-a559-4d7fc4913828.png" alt="img"></p>
<p>mv 也可以在本目录下，修改文件名</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667385393980-56887eb5-22ee-4191-bffb-8197b3405bb1.png" alt="img"></p>
<h4 id="cat查看文件内容"><a href="#cat查看文件内容" class="headerlink" title="cat查看文件内容"></a>cat查看文件内容</h4><p>​	查看文件内容，从第一行开始显示。</p>
<p><strong>1）基本语法</strong></p>
<p>​	 cat [选项] 要查看的文件 </p>
<p>**）选项说明 **</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>显示所有行的行号，包括空行。</td>
</tr>
</tbody></table>
<p>**3）经验技巧 **</p>
<p>一般查看比较小的文件，一屏幕能显示全的。 </p>
<p>**4）案例实操 **</p>
<p>​	（1）查看文件内容并显示行号</p>
<p><code>[atguigu@hadoop101 ~]$ cat -n houge.txt</code></p>
<h4 id="more-文件内容分屏查看器"><a href="#more-文件内容分屏查看器" class="headerlink" title="more  文件内容分屏查看器"></a>more  文件内容分屏查看器</h4><p>​	more指令是一个基于VI编辑器的文件过滤器。它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明。</p>
<p><strong>1）基本语法</strong></p>
<p>​	more 要查看的文件</p>
<p>**2）选项说明 **</p>
<p>在Linux系统的控制台中输入 <code>more  查看的文件</code>，会进入类似vim编辑器的效果页面。按照下面的操作，即可产生响应的效果。如果翻看的内容结束了，就会直接退出了。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键（space）</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Enter</td>
<td>向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>立刻离开more，不再显示该文件内容</td>
</tr>
<tr>
<td>CTRL + F</td>
<td>向下翻滚一屏幕</td>
</tr>
<tr>
<td>CTRL + B</td>
<td>返回上一屏幕</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行的行号</td>
</tr>
</tbody></table>
<h4 id="less-分屏显示文件内容"><a href="#less-分屏显示文件内容" class="headerlink" title="less  分屏显示文件内容"></a>less  分屏显示文件内容</h4><p>​	less指令用来分屏查看文件内容，他的功能和more指令类似，但是比more更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p>
<p><strong>1）基本语法</strong></p>
<p>less  要查看的文件</p>
<p><strong>2)操作说明</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>空白键</td>
<td>向下翻动一页；</td>
</tr>
<tr>
<td>[pagedown]</td>
<td>向下翻动一页</td>
</tr>
<tr>
<td>[pageup]</td>
<td>向上翻动一页；</td>
</tr>
<tr>
<td>&#x2F;字串</td>
<td>&#x2F;字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td>
</tr>
<tr>
<td>?字串</td>
<td>向上搜寻『字串』的功能；n：向上查找；</td>
</tr>
<tr>
<td>q</td>
<td>离开 less 这个程序</td>
</tr>
</tbody></table>
<h4 id="echo-输出内容到控制台"><a href="#echo-输出内容到控制台" class="headerlink" title="echo  输出内容到控制台"></a>echo  输出内容到控制台</h4><p><strong>1）基本语法</strong></p>
<p>​	echo [选项] [输出内容]</p>
<p>​	选项:<br>​		-e:支持反斜线控制的字符转换</p>
<p>​				控制字符        作用<br>​				\\     				输出 \ 本身<br>​				\n     			   换行符<br>​				\t     				制表符，也就是tab键</p>
<p>**2）案例实操 **</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667397186741-61cfce42-5bd9-4605-ab90-4d3b21da8b90.png" alt="img"></p>
<h4 id="head显示文件头部内容"><a href="#head显示文件头部内容" class="headerlink" title="head显示文件头部内容"></a>head显示文件头部内容</h4><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p>
<p><strong>1）基本语法</strong></p>
<p><code>head 文件 </code>      查看文件头10行内容<br><code>head -n 5 文件 </code> 查看文件头5行内容，5可以是任意行数</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>指定显示头部内容的行数</td>
</tr>
</tbody></table>
<p>**3）案例实操 **</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667407519246-22afffda-8fd4-420c-a7ef-d7a808578a3d.png" alt="img"></p>
<h4 id="tail-输出文件尾部内容"><a href="#tail-输出文件尾部内容" class="headerlink" title="tail  输出文件尾部内容"></a>tail  输出文件尾部内容</h4><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容</p>
<p><strong>1）基本语法</strong></p>
<p><code>tail 文件</code>        		查看文件尾部10行内容<br><code>tail -n 5 文件  </code> 	 查看文件尾部5行内容，5可以是任意行数<br><code>tail -f 文件   </code>  	   实时追踪该文档的所有更新</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-n&lt;行数&gt;</td>
<td>输出文件尾部 n 行内容</td>
</tr>
<tr>
<td>-f</td>
<td>显示文件最新追加的内容，监视文件变化</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667407607225-c71126f6-639f-4434-b78a-57000de68a04.png" alt="img"></p>
<h4 id="输出重定向和-追加"><a href="#输出重定向和-追加" class="headerlink" title="&gt; 输出重定向和 &gt;&gt; 追加"></a>&gt; 输出重定向和 &gt;&gt; 追加</h4><p><strong>1）基本语法</strong></p>
<p><code>ls -1 &gt; 文件    </code>  					列表的内容写入文件a.txt中（覆盖写）</p>
<p><code>ls -al &gt;&gt; 文件 </code>   					列表的内容追加到文件aa.txt的末尾</p>
<p><code>cat 文件1 &gt; 文件2 	</code>		   将文件1的内容覆盖到文件2</p>
<p><code>echo &quot;内容&quot;&gt;&gt; 文件</code></p>
<p><strong>2）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808122053437.png" alt="image-20230808122053437"></p>
<h4 id="ln-软链接"><a href="#ln-软链接" class="headerlink" title="ln  软链接"></a>ln  软链接</h4><p>软链接也成为符号链接，类似于win里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径。</p>
<p><strong>1）基本语法</strong></p>
<p><code>ln -s[原文件或目录][软链接名] </code>  给原文件创建一个软链接</p>
<p><strong>2）说明</strong></p>
<p>删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名&#x2F; </p>
<p>如果使用 rm -rf 软链接名&#x2F; 删除，会把软链接对应的真实目录下内容删掉 </p>
<p>查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向</p>
<p> <strong>3）案例实操</strong></p>
<p>下图说明</p>
<ol>
<li>ln -s &#x2F;root&#x2F;info myInfo   将&#x2F;root目录下的info文件  在&#x2F;home &#x2F;atguigu目录下创建一个对应的软链接，软链接名称叫 myInfo</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667409997562-bb842d5f-c741-4fc6-aacb-48c9d5ab2b4d.png" alt="img"></p>
<p>下图说明：</p>
<ol>
<li>mkdir folder   创建了一个名叫 folder 的文件夹</li>
<li>touch folder&#x2F;file  在folder文件夹下创建了一个名叫 file 的文件</li>
<li>ln -s &#x2F;root&#x2F;folder&#x2F; &#x2F;home&#x2F;atguigu&#x2F;myFolder  将&#x2F;roor&#x2F;folder&#x2F;文件夹下的目录，创建一个软链接名为myFolder在&#x2F;home&#x2F;atguigu目录下</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667410348543-93096a3e-5b7d-4ec3-9792-547dfb5320b1.png" alt="img"></p>
<p>-P  显示物理上的绝对路径</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667410759094-81323d5b-e80b-4093-bda2-840727a4ebef.png" alt="img"></p>
<p>ln 文件 链接   这种方式叫硬链接</p>
<h4 id="history-查看已经执行过历史命令"><a href="#history-查看已经执行过历史命令" class="headerlink" title="history  查看已经执行过历史命令"></a>history  查看已经执行过历史命令</h4><p><strong>1）基本语法</strong></p>
<p>history 					（功能描述：查看已经执行过历史命令）</p>
<p> <strong>2）案例实操</strong></p>
<p><code>history</code> 查看过去在Linux中已经执行过得命令</p>
<p><code>history 10</code> 查看过去倒数的10个命令</p>
<p><code>！+ 历史命令编号</code>  相当于重复执行这个命令</p>
<p><code>history -c</code> 清理掉历史命令记录</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667411425793-c543aaa6-c7b5-4cb5-b9a4-371f856c49fb.png" alt="img"></p>
<hr>
<h3 id="date-时间日期类"><a href="#date-时间日期类" class="headerlink" title="date  时间日期类"></a>date  时间日期类</h3><p><strong>1）基本语法</strong></p>
<p>date [OPTION] [FORMAT]</p>
<p><strong>2)选项说明</strong><br>-d&lt;时间字符串&gt;    显示指定的“时间字符串”表示的时间，而非当前时间<br>-s&lt;日期时间&gt;        设置系统日期时间</p>
<p><strong>3)参数说明</strong><br>&lt;+日期时间格式&gt;   指定显示时间的格式形式</p>
<h4 id="date-显示当前时间"><a href="#date-显示当前时间" class="headerlink" title="date 显示当前时间"></a>date 显示当前时间</h4><p><strong>1）基本语法</strong></p>
<p><code>date</code>         											显示当前日期<br><code>date +%Y</code>     										显示当前年份<br><code>date +%m</code>     			   						 显示当前月份<br><code>date +%d</code>     										显示当前是哪一天<br><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>         显示年月日时分秒</p>
<p><code>date +%S</code> 											显示当前秒<br><code>date +%s</code> 											显示当前的时间戳</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455064284-51e97f80-7981-4997-8fa2-900a8f8262e4.png" alt="img"></p>
<h4 id="date-显示非当前时间"><a href="#date-显示非当前时间" class="headerlink" title="date 显示非当前时间"></a>date 显示非当前时间</h4><p><code>date -d &quot;1 day ago&quot;</code>    显示前一天时间，昨天<br><code>date -d &quot;-1 day ago&quot;</code>   显示明天时间</p>
<h4 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a>设置系统时间</h4><p><code>date -s &quot;2000-01-01 12:10:30&quot; </code> 设置系统时间为 </p>
<p><code>ntpdate 同步时间的服务器名称</code>  即可恢复成现实世界时间</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455241629-38a56406-7d98-4a9b-97a2-94470b485b41.png" alt="img"></p>
<h4 id="cal-查看日历"><a href="#cal-查看日历" class="headerlink" title="cal 查看日历"></a>cal 查看日历</h4><p><strong>1）基本语法</strong></p>
<p>cal [选项] 				（功能描述：不加选项，显示本月日历）</p>
<p><strong>2)案例实操</strong></p>
<p><code>cal -3</code> 查看前一个月 后一个月 的日历信息<br><code>cal -m </code>把周一放在第一天的日历</p>
<p><code>cal 2022</code>   查看2022年的日历<br><code>cal -y</code>     查看当前系统时间的一整年日历</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455297972-ea887003-ef8b-4b10-ae0d-5d6b19225e7f.png" alt="img"></p>
<hr>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>Linux是多用户多任务的分时操作系统</p>
<h4 id="useradd-添加新用户"><a href="#useradd-添加新用户" class="headerlink" title="useradd 添加新用户"></a>useradd 添加新用户</h4><p><code>useradd 用户名</code>            添加新用户<br><code>useradd -g 用户组 用户名</code>   添加新用户到某个组中</p>
<p><code>useradd -d /home/dave david</code> 将david这个用户的主文件夹改名成dave，登录Linux的用户名还是david</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465273915-54fa6e40-9dea-4311-8adc-2dc18c9d95ec.png" alt="img"></p>
<h4 id="passwd-设置用户密码"><a href="#passwd-设置用户密码" class="headerlink" title="passwd 设置用户密码"></a>passwd 设置用户密码</h4><p><code>passwd 用户名</code>  给指定用户设置密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465496647-c6845df4-7d56-4751-ab15-384d8a53dddc.png" alt="img"></p>
<p>tony这个用户登录，密码是 123456 ,登录之后进入的目录是 &#x2F;home&#x2F;tony</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465410257-6233f0a5-681e-4f83-bb91-1686188ea7af.png" alt="img"></p>
<p>david这个用户登录之后，直接进入已经修改过用户主文件夹的dave的文件夹</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465563807-ac93c0c4-52d6-45b7-b010-f27cb9b65026.png" alt="img"></p>
<h4 id="id-用户名-查看用户信息，验证是否存在该用户"><a href="#id-用户名-查看用户信息，验证是否存在该用户" class="headerlink" title="id 用户名  查看用户信息，验证是否存在该用户"></a>id 用户名  查看用户信息，验证是否存在该用户</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465770996-28b9e84a-11af-496b-bd07-335f2c92732e.png" alt="img"></p>
<h4 id="查看所有用户信息"><a href="#查看所有用户信息" class="headerlink" title="查看所有用户信息"></a>查看所有用户信息</h4><p><code>cat /etc/passwd</code>   查看创建了哪些用户<br><code>less /etc/passwd</code>  查看创建了哪些用户，<code>q</code>退出</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465932879-a94a0da4-d661-49f4-ac86-7520957ae69a.png" alt="img"></p>
<h4 id="su-用户名-切换到指定用户"><a href="#su-用户名-切换到指定用户" class="headerlink" title="su 用户名  切换到指定用户"></a>su 用户名  切换到指定用户</h4><p><strong>1）基本语法</strong></p>
<p>su 用户名称   （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量） su - 用户名称 （功能描述：切换到用户并获得该用户的环境变量及执行权限）</p>
<p> <strong>2）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466063716-010bc030-5f6e-43a2-9818-98967c1cee6a.png" alt="img"></p>
<blockquote>
<p>下图说明</p>
<p>切换用户实际上是嵌套形式的</p>
<p>root —&gt; atguigu —&gt;tony</p>
<p>如果退出则从 tony —&gt; atguigu —&gt; root 这样路径返回</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466184939-a533ff5e-ed98-4b2e-b248-5cde42337ed0.png" alt="img"></p>
<blockquote>
<p>下图说明</p>
<p>tony不能查看atguigu的文件目录，反之亦然。因为他俩属于同一级别</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466338752-96877f5c-0094-46e2-965f-0465388a2229.png" alt="img"></p>
<blockquote>
<p>下图说明</p>
<p>1.因为当前切换用户是基于root用户来的，所以 who am i 一直输出都是 root</p>
<p>2.whoami 形式，会输出当前切换的用户</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466481207-4684bba9-6509-4db9-a049-2653137c2f7c.png" alt="img"></p>
<h4 id="sudo-设置普通用户具有root权限"><a href="#sudo-设置普通用户具有root权限" class="headerlink" title="sudo  设置普通用户具有root权限"></a>sudo  设置普通用户具有root权限</h4><blockquote>
<p>首先需要在配置文件中配置权限，否则会有下图提示</p>
<p><code>vim /etc/sudoers </code>进入文件</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467478198-f72cf08f-3ad3-4634-a664-38b01b3e47ea.png" alt="img"></p>
<blockquote>
<p>下图说明</p>
<p>在root下，添加用户的权限</p>
<p>修改完之后，<code>:wq!</code>强制执行操作</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467631702-c8eea1aa-639a-401e-952d-e3ef56bd58fe.png" alt="img"></p>
<p>修改完之后，权限就够了</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467731768-abb97595-cb03-4792-a4b4-2fbcf09b0304.png" alt="img"></p>
<h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel  删除用户"></a>userdel  删除用户</h4><p><code>userdel 用户名</code>   删除用户，但不删除用户组的文件内容</p>
<p><code>rm -rf tony/</code>    删除tony用户下的文件目录内容（不推荐使用，建议保留）</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467945599-6540404e-25cf-40e2-8c62-797b8d92be5b.png" alt="img"></p>
<p><code>userdel -r 用户</code>  不仅删除用户，连同该用户的目录也被删掉</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667468146780-4929ad4b-6c6e-4ad5-95f6-924c37f6d37d.png" alt="img"></p>
<hr>
<h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><p>在Linux中，默认新建的用户在自己同名的组中，所有用户组的信息都在 <code>/etc/group</code> 配置文件中</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667471753618-7133c3a4-0c2c-44d7-ae87-390f0acee9b9.png" alt="img"></p>
<h4 id="groupadd-新建组"><a href="#groupadd-新建组" class="headerlink" title="groupadd  新建组"></a>groupadd  新建组</h4><p>groupadd 	组名</p>
<p><code>groupadd meifa</code>  	创建meifa这个组</p>
<h4 id="groupdel-删除组"><a href="#groupdel-删除组" class="headerlink" title="groupdel 删除组"></a>groupdel 删除组</h4><p><code>groupdel 组名</code>    	  删除存在的组</p>
<h4 id="usermod-groupmod-修改用户、修改组"><a href="#usermod-groupmod-修改用户、修改组" class="headerlink" title="usermod  groupmod  修改用户、修改组"></a>usermod  groupmod  修改用户、修改组</h4><p>下图说明</p>
<ol>
<li><code>usermod -g meifa tony</code>               将tony这个用户，放到meifu这个用户组中</li>
<li><code>groupmod -n haircut meifa</code>       将meifa这个组的名字改成haircut</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667471910798-c7f861d8-fbbb-42ce-8672-0a9eb0ad96e0.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li>用户 atguigu 在和root一起创建的时候，会被默认添加到 wheel 组中，而wheel组成员在配合sudo命令时可以拥有管理员权限操作</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667472357293-031fded7-ad22-423a-a141-453c67153c23.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667472462450-2849dd69-8489-405e-9c09-30f06991f6a4.png" alt="img"></p>
<hr>
<h3 id="文件权限类"><a href="#文件权限类" class="headerlink" title="文件权限类"></a>文件权限类</h3><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>Linux是一种典型的多用户多任务的操作系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属用户和组。</p>
<p><strong>1）从左到右的 10 个字符表示，如图 所示</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131446656.png" alt="image-20230808131446656"></p>
<p>如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示:</p>
<p>（1）0 首位表示类型 </p>
<p>​	在Linux中第一个字符代表这个文件是目录、文件或链接文件等等 </p>
<ul>
<li>代表文件</li>
<li>d 代表目录</li>
<li>l 链接文档(link file)；</li>
</ul>
<p>（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User </p>
<p>（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group </p>
<p>（4）第7-9位确定其他用户拥有该文件的权限 —Othe</p>
<p><strong>2）rwx 作用文件和目录的不同解释</strong></p>
<p>（1）作用到文件：</p>
<p>​	 [ r ]代表可读(read): 可以读取，查看</p>
<pre><code> [ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前 提条件是对该文件所在的目录有写权限，才能删除该文件.
</code></pre>
<p>​	[ x ]代表可执行(execute):可以被系统执行</p>
<p>（2）作用到目录：</p>
<p>​	[ r ]代表可读(read): 可以读取，ls查看目录内容</p>
<p>​	[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p>
<p>​	[ x ]代表可执行(execute):可以进入该目录</p>
<p>下图说明</p>
<ol>
<li>在操作<code>ll</code>指令之后，会详细展示出文件类型、操作权限、硬链接数、所属用户、所属用户组、大小、创建&#x2F;修改时间、文件&#x2F;文件夹名称</li>
<li>在黄色区域中，- 表示文件，d表示文件夹，l表示是一个文件链接，c表示字符设备文件(鼠标)，d表示块设备文件(硬盘)</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667483029843-3681d542-0b74-46e8-9e9d-c7d5ce30a2f7.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131740625.png" alt="image-20230808131740625"></p>
<h4 id="chmod-修改文件权限"><a href="#chmod-修改文件权限" class="headerlink" title="chmod  修改文件权限"></a>chmod  修改文件权限</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131808047.png" alt="image-20230808131808047"></p>
<p>第一种方式变更权限 </p>
<p>​	chmod [{ugoa}{+-&#x3D;}{rwx}] 文件或目录 </p>
<p>第二种方式变更权限 </p>
<p>​	chmod [mode&#x3D;421 ] [文件或目录]</p>
<p><strong>经验技巧</strong></p>
<p>​	u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和）</p>
<p>​	r&#x3D;4 w&#x3D;2 x&#x3D;1 	rwx&#x3D;4+2+1</p>
<p><code>chmod u+x initial-setup-ks.cfg</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667484864251-2df2e6e0-715d-47ca-b5ef-e517772f1b9c.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23197095/1667484969947-1ca27fea-ee43-4dff-92fd-5b1d01295169.png" alt="img"></p>
<p><code>chmode 644 initial-setup-ks.cfg</code>  修改文件权限</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667485443424-b34628ff-c566-4d9f-8a95-3fb9abd29e35.png" alt="img"></p>
<p>如果一个文件夹内有很多文件，想要修改该文件夹的权限</p>
<p><code>chmod -R 777 文件夹/ </code>   <code>-R</code>指令会将该文件夹内的文件的权限也一并修改了</p>
<h4 id="chown-改变所有者"><a href="#chown-改变所有者" class="headerlink" title="chown  改变所有者"></a>chown  改变所有者</h4><p><strong>1）基本语法</strong></p>
<p>​	chown [选项] [最终用户] [文件或目录]    (改变文件或目录所有者)</p>
<p><strong>2）选项说明</strong></p>
<p>​	-R   递归操作</p>
<p><strong>3）案例实操</strong></p>
<p><code>chown atguigu houge.txt</code>   将文件houge.txt的所属用户改成 atguigu这个用户</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808132324314.png" alt="image-20230808132324314"></p>
<p>下图说明</p>
<ol>
<li>首先查看了initial-setup-ks.cfg文件的详细信息，所属用户，所属组</li>
<li>chown atguigu initial-setup-ks.cfg    将initial-setup-ks.cfg文件的所属用户从root改成了atguigu</li>
<li>chmod 700 initial-setup-ks.cfg    atguigu这个用户修改initial-setup-ks.cfg文件的权限</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667487847237-96a1f9f7-3fb7-4066-85e4-db73e88b5f5b.png" alt="img"></p>
<h4 id="chgrp-改变所属组"><a href="#chgrp-改变所属组" class="headerlink" title="chgrp  改变所属组"></a>chgrp  改变所属组</h4><p>​	chgrp [最终用户组] [文件或目录]      改变文件或者目录的所属组</p>
<p><code>chgrp root houge.txt</code>  将文件houge.txt文件的所属组改成root</p>
<p>下图说明</p>
<ol>
<li>首先查看initial-setup-ks.cfg文件的详细信息</li>
<li>在atguigu这个用户下修改 initial这个文件的所属组，提示不允许。需要root权限</li>
<li>切换成root权限之后，chgrp haircut initial-setup-ks.cfg  修改initial这个文件的所属组为haircut</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667488102108-71b65a59-61eb-428c-bdfb-16438f7980ec.png" alt="img"></p>
<hr>
<h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find查找文件或目录"><a href="#find查找文件或目录" class="headerlink" title="find查找文件或目录"></a>find查找文件或目录</h4><p>​	finde指令将从指定目录向下递归地遍历各个子目录，将满足条件的文件显示在终端</p>
<p><strong>1）基本语法</strong></p>
<p> find [搜索范围] [选项]</p>
<p><strong>2）选项说明</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808132629919.png" alt="image-20230808132629919"></p>
<p><strong>3）案例实操</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lh   可以更加直观的看到文件的占用存储大小</span><br><span class="line"></span><br><span class="line">find /root -size +10M    在/root路径下，按照存储大小查找超过10M的文件</span><br><span class="line"></span><br><span class="line">find /root -size +2M   </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667531748830-cfaae822-b5a6-4fb0-9a48-547b71f342c4.png" alt="img"></p>
<h4 id="locate快速定位文件路径"><a href="#locate快速定位文件路径" class="headerlink" title="locate快速定位文件路径"></a>locate快速定位文件路径</h4><p>​	locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p>
<p><strong>1）基本语法</strong></p>
<p>​	locate 搜索文件</p>
<p><strong>2）说明</strong></p>
<p>​	由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p>
<p><strong>3）案例实操</strong></p>
<p>下图说明</p>
<ol>
<li><code>updatedb</code>     因为locate命令是根据数据库查询的，所以在使用之前先更新一下系统DB</li>
<li><code>locate temp</code>   会把所有包含tmp字眼的文件或文件夹都查询出来</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532519496-304690f2-f600-4880-8032-e9511e1788f1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532649261-155e9193-d5a6-414d-a702-fbe8c6a5eee0.png" alt="img"></p>
<h4 id="which-whereis-查找命令本身的路径"><a href="#which-whereis-查找命令本身的路径" class="headerlink" title="which  whereis  查找命令本身的路径"></a>which  whereis  查找命令本身的路径</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532770646-5850f5bb-1091-46e2-8f7c-b6d5a7e6314f.png" alt="img"></p>
<h4 id="grep-过滤查找及”-”管道符"><a href="#grep-过滤查找及”-”管道符" class="headerlink" title="grep  过滤查找及”|”管道符"></a>grep  过滤查找及”|”管道符</h4><p>管道符 “|” 表示将前一个命令的处理结果传递给后面的指令处理</p>
<p>find 和locate 与 grep的区别，find locate定位的是文件名，grep查找的是文件的内容</p>
<p><strong>1）基本语法</strong></p>
<p>​	grep [选项] 查找内容 源文件</p>
<p><strong>2）选项说明</strong></p>
<p>​	-n    显示匹配行及行号</p>
<p><strong>3）案例实操</strong></p>
<p>下图说明</p>
<ol>
<li>grep -n boot initial-setup-ks.cfg     查找initial这个文件内容中包含boot的内容，并且-n显示行号</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533166991-b45fd01a-7af3-4618-a432-2e7af4159908.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li>ls  显示出&#x2F;root目录下的文件 文件夹</li>
<li>ls | grep .cfg    将ls查询的结果传递给grep指令，grep在ls查询结果的基础上，筛选出后缀名带有.cfg的文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533353286-6f546157-56eb-470f-8cb3-5b9eb28d5e31.png" alt="img"></p>
<h4 id="wc-work-cound"><a href="#wc-work-cound" class="headerlink" title="wc  work cound"></a>wc  work cound</h4><p>下图说明</p>
<ol>
<li><code>cat info</code>      查看info这个文件的内容</li>
<li><code>wc info</code> 查看文件的行号，多少个单词数，存储大小 ，文件名</li>
<li><code>grep -n boot initial-setup-ks.cfg | wc</code>    将initial文件中包含boot的内容行结果传递给wc指令，统计出该结果有8行，32个单词，341字节</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533787517-441d1b0d-fc6c-4d7c-9295-5be25bb15f06.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533558401-81da8038-24de-493f-8fa8-8e405cfb9a6e.png" alt="img"></p>
<hr>
<h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip压缩解压缩"><a href="#gzip-gunzip压缩解压缩" class="headerlink" title="gzip&#x2F;gunzip压缩解压缩"></a>gzip&#x2F;gunzip压缩解压缩</h4><p><strong>1）基本语法</strong></p>
<p><code>gzip  文件</code>         	压缩文件，只能将文件压缩为 *.gz 文件<br><code>gunzip  文件.gz</code>    解压缩文件名令</p>
<p><strong>2）说明</strong></p>
<p>​	只能压缩文件不能压缩目录<br>​	不保留原来的文件<br>​	同时多个文件会产生多个压缩包</p>
<h4 id="zip-unzip-压缩解压缩"><a href="#zip-unzip-压缩解压缩" class="headerlink" title="zip&#x2F;unzip 压缩解压缩"></a>zip&#x2F;unzip 压缩解压缩</h4><p><strong>1）基本语法</strong></p>
<p><code>zip [选项] xxxxx.zip 将要压缩的内容</code>       压缩文件和目录的命令</p>
<p><code>unzip [选项] xxxxx.zip</code>                   解压缩文件</p>
<p><strong>2）选项</strong></p>
<table>
<thead>
<tr>
<th>zip选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>压缩目录</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>unzip选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d&lt;目录&gt;</td>
<td>指定解压后文件的存放目录</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808133847431.png" alt="image-20230808133847431"></p>
<h4 id="tar-打包（常用，重点）"><a href="#tar-打包（常用，重点）" class="headerlink" title="tar  打包（常用，重点）"></a>tar  打包（常用，重点）</h4><p><strong>1）基本语法</strong></p>
<p><code>tar [选项]  xxxx.tar.gz 将要打包进去的内容</code>       打包目录，压缩后的文件格式.tar.gz</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>产生.tar 打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>-z</td>
<td>打包同时压缩</td>
</tr>
<tr>
<td>-x</td>
<td>解包 .tar 文件</td>
</tr>
<tr>
<td>-C</td>
<td>解压到指定目录</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p>下图说明</p>
<ol>
<li>进入&#x2F;root 目录下，查看其文件 目录</li>
<li><code>tar -zcvf temp.tar.gz initial-setup-ks.cfg xzhdx.txt info 公共/</code></li>
</ol>
<p>​         将 initial，xzhdx.txt，info，公共&#x2F; ，这4个文件和文件夹，-zcvf打包压缩成名为temp.tar.gz的打包压缩文件</p>
<ol>
<li>ls 之后可以看到多出了tem.tar.gz打包压缩文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667545828965-c0baff57-1ee0-4e60-a437-cf2c02802679.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li><code>tar -zxvf temp.tar.gz -C /tmp</code> 将打包压缩文件temp.tar.gz 解包解压缩到 &#x2F;tmp 目录下。</li>
<li>在&#x2F;tmp目录下，可以看到info&#x2F;initial-setup-ks.cfg&#x2F;xzhdx.txt&#x2F;公共&#x2F; 文件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667546227290-8065279a-9108-44c1-97b7-7288696ed9d6.png" alt="img"></p>
<hr>
<h3 id="磁盘管理类"><a href="#磁盘管理类" class="headerlink" title="磁盘管理类"></a>磁盘管理类</h3><h4 id="tree-将目录文件以树形式展示"><a href="#tree-将目录文件以树形式展示" class="headerlink" title="tree  将目录文件以树形式展示"></a>tree  将目录文件以树形式展示</h4><p><strong>1）基本语法</strong></p>
<p><code>yum install tree</code>  		首先在Linux系统中，安装tree这个插件，按照提示 y即可</p>
<p><code>tree ./</code> 						  将本目录以树的形式展示出来</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667547058826-185770d8-d322-4cc8-886c-5b1eba87d0af.png" alt="img"></p>
<h4 id="du-查看文件和目录占用的磁盘空间"><a href="#du-查看文件和目录占用的磁盘空间" class="headerlink" title="du 查看文件和目录占用的磁盘空间"></a>du 查看文件和目录占用的磁盘空间</h4><p>du:  disk usage 磁盘占用情况</p>
<p><strong>1）基本语法</strong></p>
<p>​	<code>du 目录/文件</code> 		(显示目录下每个子目录对的磁盘使用情况)</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td>
</tr>
<tr>
<td>-a</td>
<td>不仅查看子目录大小，还要包括文件</td>
</tr>
<tr>
<td>-c</td>
<td>显示所有的文件和子目录大小后，显示总和</td>
</tr>
<tr>
<td>-s</td>
<td>只显示总和</td>
</tr>
<tr>
<td>–max-depth&#x3D;n</td>
<td>指定统计子目录的深度为第 n 层</td>
</tr>
</tbody></table>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23197095/1667547788923-6847dcb4-42cc-49bb-9396-86c0a1b39725.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li><code>du --max-depth=1 -ah </code>   按照文件的一级目录统计占用磁盘大小，最后汇总总占用多少 166M</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667547803253-d47b04fe-f6f8-45c0-a97e-6d3558125ab8.png" alt="img"></p>
<h4 id="df-查看磁盘空间使用情况"><a href="#df-查看磁盘空间使用情况" class="headerlink" title="df  查看磁盘空间使用情况"></a>df  查看磁盘空间使用情况</h4><p>df  disk free 空余磁盘</p>
<p><strong>1）基本语法</strong></p>
<p>​	<code>df [选项]</code>   列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667619780722-bd77d9b5-cad8-4d5b-8d58-0b79c551ff3e.png" alt="img"></p>
<p><code>free -h</code>  显示内存的使用情况，包括实际内存和虚拟交换的内存</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667620475703-f5c9d536-f2bc-4ddc-a968-cdd656c8205f.png" alt="img"></p>
<h4 id="lsblk-查看设备挂载信息"><a href="#lsblk-查看设备挂载信息" class="headerlink" title="lsblk  查看设备挂载信息"></a>lsblk  查看设备挂载信息</h4><p><strong>1）基本语法</strong></p>
<p>​	<code>lsblk</code>   查看设备挂载情况</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>查看详细的设备挂载情况，显示文件系统信息</td>
</tr>
</tbody></table>
<p>下图说明</p>
<ol>
<li>lsblk  查看设备挂载信息情况。sda的来源取决于使用何种硬盘介质。如果是IPE类型的硬盘，则叫hda&#x2F;hdb&#x2F;hdc 以此类推。如果是SATA、SCSI类型的硬盘，则叫sda&#x2F;sdb&#x2F;sdc以此类推</li>
<li>sr0 是光盘镜像</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667621005245-228a31bf-acf2-4902-8915-a13ef5d801a6.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li><p>lsblk</p>
</li>
<li><p>lsblk -f  会比上一条命令显示更多信息</p>
</li>
<li><ol>
<li>xfs 是文件系统类型格式</li>
<li>UUID  是系统为当前每一个分区分配的唯一标识符  40位</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667621221565-4e9bcb8d-b2f9-430f-bc8f-8e950fb6afea.png" alt="img"></p>
<h4 id="mount-umount-挂载-卸载"><a href="#mount-umount-挂载-卸载" class="headerlink" title="mount &#x2F; umount 挂载 &#x2F; 卸载"></a>mount &#x2F; umount 挂载 &#x2F; 卸载</h4><p>​         对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构</p>
<p>​        Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，他的整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623293103-9eb5a5f3-5091-4a80-82d3-3f0ea9a7f13d.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623312509-d981e5a9-8f45-4144-9e99-993f4320b77d.png" alt="img"></p>
<p>设置完成之后，可以查看文件挂载的路径 </p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623381022-24dbd4be-35b1-4a9b-9a4f-2d0d9cfd37a8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623532664-affdbb11-1925-459e-8b82-8f43520d9510.png" alt="img"></p>
<p>挂载</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623679251-68fa1820-2174-45cc-a8a8-19728bc2cbba.png" alt="img"></p>
<p>卸载</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623719566-60fc2459-4c53-4525-9a07-2bc079079aa8.png" alt="img"></p>
<p>设置开机自启动挂载</p>
<p><code>vim /etc/fstab</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667624015271-702dbfdb-42ee-46ab-8d3a-a12a1cc2ad63.png" alt="img"></p>
<p>进入vim编辑之后</p>
<p>黄色部分是手动写的</p>
<p>&#x2F;dev&#x2F;cdrom 是挂载文件目录路径 </p>
<p>&#x2F;mnt&#x2F;cdrom 是挂载点</p>
<p>iso9660  是文件类型</p>
<p>defaults</p>
<p>0  是是否开启备份</p>
<p>0 是 不做文件系统检查 fsck. 1 2 3 设置优先级，1最高</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667624227767-97c42874-f2e3-4de7-a4e8-21a77eb47ba2.png" alt="img"></p>
<h4 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk  分区"></a>fdisk  分区</h4><p>该命令必须在root用户下才能使用</p>
<p><strong>1）基本语法</strong></p>
<p>​	<code>fdisk -l</code>   查看磁盘分区详情<br>​	<code>fdisk 硬盘设备名</code>  对新增因公安进行分区操作</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>显示所有硬盘的分区列表</td>
</tr>
</tbody></table>
<p>下图说明</p>
<ol>
<li>fdisk &#x2F;dev&#x2F;sdb   将sdb磁盘分区</li>
<li>n  添加一个新的分区；q 不保存退出；w 保存退出；p 打印分区表信息</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667804038236-74f576a2-bd04-4438-8d24-35581a4f9754.png" alt="img"></p>
<p>下图说明</p>
<ol>
<li>接上图，输入n 之后，会提示是创建p 主分区还是 e 扩展分区</li>
<li>Linux中，只能有4个主分区，如果额外添加分区，则将第四个主分区分为第5-16个扩展分区。总计4个主分区，12个扩展分区</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667804424554-ac74defa-c6e6-461f-b785-416c57237b1a.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667792545341-caecf58e-0a98-47a1-a0fa-74062f6951a7.png" alt="img"></p>
<p><code>mkfs -t xfs /dev/sdb1</code>  格式化磁盘，格式化磁盘之后，才能挂载使用该磁盘</p>
<p>mkfs创建系统文件 -t文件格式类型<br><code>mount /dev/sdb1 /home/atguigu/</code>   将20G的sdb1新硬盘挂载到atguigu下<br><code>umount /home/atguigu</code>             卸载sdb1硬盘，解除与&#x2F;home&#x2F;atguigu的目录关系</p>
<hr>
<h3 id="进程管理类"><a href="#进程管理类" class="headerlink" title="进程管理类"></a>进程管理类</h3><p>​	进程是正在执行得给程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源</p>
<h4 id="ps-查看当前系统进程状态"><a href="#ps-查看当前系统进程状态" class="headerlink" title="ps  查看当前系统进程状态"></a>ps  查看当前系统进程状态</h4><p>ps:  process status 进程状态</p>
<p><strong>1）基本语法</strong></p>
<p>​	<code>ps aux | grep xxx</code>   		查看系统中所有进程</p>
<p>​	<code>ps -ef | grep xxx</code>   		可以查看子父进程之间的关系</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>列出带有终端的所有用户的进程</td>
</tr>
<tr>
<td>x</td>
<td>列出当前用户的所有进程，包括没有终端的进程</td>
</tr>
<tr>
<td>u</td>
<td>面向用户友好的显示风格</td>
</tr>
<tr>
<td>-e</td>
<td>列出所有进程</td>
</tr>
<tr>
<td>-u</td>
<td>列出某个用户关联的所有进程</td>
</tr>
<tr>
<td>-f</td>
<td>显示完整格式的进程列表</td>
</tr>
</tbody></table>
<p><strong>3）功能说明</strong></p>
<ol>
<li>PID：进程的ID号。    PPID：PID对应的父进程</li>
<li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li>
<li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li>
<li>VSZ：该进程占用虚拟内存的大小，单位KB</li>
<li>RSS：该进程占用实际物理内存的大小，单位是KB</li>
<li>TTY：该进程是在哪个终端中运行的。对于CentOS来说，tty1是图像化终端，tty2-tty6是本地的字符界面终端。pts&#x2F;0-255代表虚拟终端</li>
<li>STAT：进程状态。常见的状态有：R 运行状态；S 睡眠状态； T 暂停状态 ；Z 僵尸状态 ；s 包含子进程；l 多线程；+ 前台显示；&lt; 当前进程优先级很高；N 当前进程优先级较低</li>
<li>START：该进程的启动时间</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>COMMAND：产生此进程的命令名</li>
</ol>
<p>如果想要查看进程的CPU占用率和内存占用率，可以使用 <code>ps aux</code></p>
<p>如果想看进程的父进程ID，可以使用 <code>ps -ef</code></p>
<h4 id="kill终止进程"><a href="#kill终止进程" class="headerlink" title="kill终止进程"></a>kill终止进程</h4><p><strong>1）基本语法</strong></p>
<p><code>kill [选项] 进程号</code>    通过进程号杀死进程</p>
<p><code>killall  进程名称</code>     通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢的时候很有用</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-9</td>
<td>表示强迫进程立即停止</td>
</tr>
</tbody></table>
<h4 id="pstree-查看进程树"><a href="#pstree-查看进程树" class="headerlink" title="pstree  查看进程树"></a>pstree  查看进程树</h4><p><strong>1）基本语法</strong></p>
<p>pstree [选项]</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>显示进程的 PID</td>
</tr>
<tr>
<td>-u</td>
<td>显示进程的所属用户</td>
</tr>
</tbody></table>
<p>下图说明</p>
<ol>
<li>pstree | less  分页查看进程树</li>
<li>找到sshd远程登录。首先Linux系统开启时，sshd系统守护进程会自启动，之后开启一个远程服务登录sshd会启动，在这个远程登录的页面中启动bash命令界面，在bash中输入了less pstree命令</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667815653233-258f6a2e-7dd7-4606-ba1a-44135949631f.png" alt="img"></p>
<h4 id="top-实时监控系统进程状态"><a href="#top-实时监控系统进程状态" class="headerlink" title="top  实时监控系统进程状态"></a>top  实时监控系统进程状态</h4><p><strong>1）基本语法</strong></p>
<p>top [选项]</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-d 秒数</td>
<td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令</td>
</tr>
<tr>
<td>-i</td>
<td>使top不显示任何闲置或者僵死进程</td>
</tr>
<tr>
<td>-p</td>
<td>通过指定监控进程ID来仅仅监控某个进程的状态</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存的使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
</tbody></table>
<p>下图说明</p>
<p>​	1.上面是整体系统运行状态</p>
<ol>
<li>a.</li>
</ol>
<p>​	2.下面是具体进程运行状态</p>
<ol>
<li><ol>
<li>PID：当前进程ID</li>
<li>USER：哪个用户的进程</li>
<li>PR：当前系统任务调度的优先级</li>
<li>NI：用户指定的nice值（nice值越小）</li>
<li>VIRT：虚拟内存占用的大小</li>
<li>RES：实际内存，物理内存使用大小</li>
<li>SHR：共享内存</li>
<li>S：status状态</li>
<li>%CPU：CPU计算时间的占比</li>
<li>%MEM：内存的占比</li>
<li>TIME+：精确到0.01秒的已经占用到cpu的总时间</li>
<li>COMMAND：调用当前进程的命令是什么</li>
</ol>
</li>
</ol>
<p>​	3.下图默认是按照CPU占用排序的，如果按<code>shift＋m</code> 是按照内存占用大小排序的。	<code>shift+p</code> CPU排序。上下键 pageUP&#x2F;pageDown可以翻页。q退出</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667816821658-21caab83-35d2-44f6-ab19-59f9765a4854.png" alt="img"></p>
<blockquote>
<p>1.在输入top命令之后，输入u 可以指定用户显示进程；输入k可以杀死指定进程，接着发送9信号，就是杀死进程。</p>
<p>2.top -p 4910 表示只查看4910这个进程的信息</p>
</blockquote>
<h4 id="netstat-显示网络状态和端口占用信息"><a href="#netstat-显示网络状态和端口占用信息" class="headerlink" title="netstat  显示网络状态和端口占用信息"></a>netstat  显示网络状态和端口占用信息</h4><p><strong>1）基本语法</strong></p>
<p><code>netstat -anp | grep 进程号</code>     查看该进程网络信息<br><code>netstat -nlp | grep 端口号</code>     查看网络端口号占用情况</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有正在监听（listen）和未监听的套接字（socket）</td>
</tr>
<tr>
<td>-n</td>
<td>拒绝显示别名，能显示数字的全部转化成数字</td>
</tr>
<tr>
<td>-l</td>
<td>仅列出在监听的服务状态</td>
</tr>
<tr>
<td>-p</td>
<td>表示显示哪个进程在调用</td>
</tr>
</tbody></table>
<ol>
<li><p>套接字&#x3D;ip+端口     端口（ 0-65535）</p>
</li>
<li><p>介绍下面的含义</p>
</li>
<li><ol>
<li>Proto：网络传输协议</li>
<li>Recv-Q：已经接收到的但是还没拷贝的字节数</li>
<li>Send-Q：已经发出去了但是远程的主机还没有确认收到的字节数</li>
<li>Local Address：本地地址</li>
<li>Foreign Address：远程地址</li>
<li>State：进程状态</li>
<li>PID&#x2F;Program name：进程ID名字和进程名字</li>
</ol>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667874210230-dfb5cefe-cd2a-432d-af8b-8fe4ccf1240c.png" alt="img"></p>
<h4 id="crontab-系统定时任务"><a href="#crontab-系统定时任务" class="headerlink" title="crontab  系统定时任务"></a>crontab  系统定时任务</h4><p><strong>服务管理</strong></p>
<p>重新启动 crond 服务</p>
<p>systemctl restart crond</p>
<p>定时任务设置</p>
<p><strong>1）基本语法</strong></p>
<p>crontab [选项]</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>编辑crontab定时任务</td>
</tr>
<tr>
<td>-l</td>
<td>查询crontab任务</td>
</tr>
<tr>
<td>-r</td>
<td>删除当前用户素有的crontab任务</td>
</tr>
</tbody></table>
<p>进入crontab编辑界面，会打开vim编辑你的定时任务时间设置</p>
<p>***** 执行的任务</p>
<ol>
<li>*       一小时当中的第几分钟，0–59</li>
<li>*      一天当中的第几个小时，0–23</li>
<li>*      一个月当中的第几天， 1–31</li>
<li>*      一年当中的第几个月，1–12</li>
<li>*      一周当中的星期几，0–7（0和7都代表周日）</li>
</ol>
<p>特殊符号</p>
<p>*      ——&gt;  代表任何时间。比如第一个 * 就代表一个小时中每分钟都执行一次的意思</p>
<p>，    ——&gt;  代表不连续的时间。比如“0 8，12，16***”代表在每天的8点0分，12点0分，16点0分都执行一次</p>
<p>-      ——&gt;  代表连续的时间范围。比如“0 5 ** 1-6”代表在周一到周六的凌晨5点0分执行任务</p>
<p><em>&#x2F;n   ——&gt;  代表每隔多久执行一次。比如“</em>&#x2F;10****”代表每隔10分钟就执行一遍命令</p>
<p>下图说明</p>
<ol>
<li>crontab -l     查看所有定时任务</li>
<li>crontab -e    编辑定时任务，内容见下图。 <em>&#x2F;1</em>***echo “hello,world”  &gt;&gt; &#x2F;root&#x2F;hello</li>
</ol>
<p>每一分钟输出hello，world在&#x2F;root&#x2F;hello文件中</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667878993467-7430e4be-598f-4807-8175-44abd645802c.png" alt="img"></p>
<ol>
<li>cat hello  查看文件内容</li>
<li>tail -f hello  实时监控查看</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667876652468-f0438464-71e8-4de0-ba71-9156642f4f7b.png" alt="img"></p>
<hr>
<h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><h4 id="RPM概述"><a href="#RPM概述" class="headerlink" title="RPM概述"></a>RPM概述</h4><p>​	RPM(RedHat Package Manager),RedHat软件包管理工具，是Linux这系列操作系统里的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p>
<h4 id="查询命令-rpm-qa"><a href="#查询命令-rpm-qa" class="headerlink" title="查询命令(rpm -qa)"></a>查询命令(rpm -qa)</h4><p><strong>1）基本语法</strong></p>
<p><code>rpm -qa</code>    查询所安装的所有rpm软件包</p>
<p>由于软件包比较多，一般都会采用过滤。 rpm -qa | grep rpm软件包</p>
<p>下图说明</p>
<ol>
<li><code>rpm -qa | grep firefox</code>   查询安装的Firefox软件信息</li>
<li><code>rpm -qi firefox</code>   详细查询安装的Firefox软件信息</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667888952612-d88f8abb-6c87-4613-908b-fdf3c279083a.png" alt="img"></p>
<h4 id="RPM卸载命令"><a href="#RPM卸载命令" class="headerlink" title="RPM卸载命令"></a>RPM卸载命令</h4><p><strong>1）基本语法</strong></p>
<p><code>rpm -e RPM软件包名</code>   卸载指定的软件包</p>
<p><code>rpm -e --nodeps</code>     卸载软件时，不检查依赖。</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>卸载软件包</td>
</tr>
<tr>
<td>–nodeps</td>
<td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件</td>
</tr>
</tbody></table>
<p><strong>3）实际操作</strong></p>
<p><code>rpm -e firefox</code></p>
<h4 id="RPM安装命令-rpm-ivh"><a href="#RPM安装命令-rpm-ivh" class="headerlink" title="RPM安装命令(rpm -ivh)"></a>RPM安装命令(rpm -ivh)</h4><p><strong>1）基本语法</strong></p>
<p><code>rpm -ivh RPM包全名</code></p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>install，安装</td>
</tr>
<tr>
<td>-v</td>
<td>–verbose,显示详细信息</td>
</tr>
<tr>
<td>-h</td>
<td>–hash,进度条</td>
</tr>
<tr>
<td>–nodeps</td>
<td>安装前不检查依赖</td>
</tr>
</tbody></table>
<p>下图解释</p>
<ol>
<li>首先Linux的镜像是需要挂载的，然后找到这个镜像的文件夹中的packages目录，ls | grep firefox筛选出火狐浏览器的安装包</li>
<li>rpm -ivh firefox-68.10.0-1.el7.centos.x86-64.rpm  安装火狐浏览器，下面会显示安装进度</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667889610497-e2cdf822-cb05-475c-8339-63cea258128f.png" alt="img"></p>
<hr>
<h3 id="YUM仓库配置"><a href="#YUM仓库配置" class="headerlink" title="YUM仓库配置"></a>YUM仓库配置</h3><h4 id="YUM概述"><a href="#YUM概述" class="headerlink" title="YUM概述"></a>YUM概述</h4><p>YUM（Yellow dog Updater,Modified）是一个在Fedora和RedHat以及CentOS中的shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无需频繁的一次性下载、安装。</p>
<p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667892147333-641864ec-7642-4d6b-8fee-1204a443a996.png" alt="img"></p>
<h4 id="YUM的常用命令"><a href="#YUM的常用命令" class="headerlink" title="YUM的常用命令"></a>YUM的常用命令</h4><p><strong>1）基本语法</strong></p>
<p>yum [选项] [参数]</p>
<p><strong>2）选项说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-y</td>
<td>对所有提问都回答”yes”</td>
</tr>
</tbody></table>
<p><strong>3）参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>install</td>
<td>安装rpm软件包</td>
</tr>
<tr>
<td>update</td>
<td>更新rpm软件包</td>
</tr>
<tr>
<td>check-update</td>
<td>检查是否有可用的更新rpm软件包</td>
</tr>
<tr>
<td>remove</td>
<td>删除指定的rpm软件包</td>
</tr>
<tr>
<td>list</td>
<td>显示软件包信息</td>
</tr>
<tr>
<td>clean</td>
<td>清理yum过期的缓存</td>
</tr>
<tr>
<td>deplist</td>
<td>显示yum软件包的所有依赖关系</td>
</tr>
</tbody></table>
<h4 id="修改网YUM源"><a href="#修改网YUM源" class="headerlink" title="修改网YUM源"></a>修改网YUM源</h4><p>​	默认的系统yum源，需要连接国外apache网站，网速比较慢，可以修改关联的网络YUM源位国内镜像的网站，比如网易163，aliyun等</p>
<p>1.安装wget，wget用来从指定的URL下载文件</p>
<p><code>yum install wget</code></p>
<p>2.在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下，备份默认的repos文件</p>
<blockquote>
<p>进入&#x2F;etc&#x2F;yum.repos.d目录下</p>
</blockquote>
<p><code>cp CentOS-Base.repo CentOS-Base.repo.backup</code></p>
<p>3.下载网易163或是aliyun的repos文件，任选其一</p>
<p><code>wget http://mirrors.aliyun.com/repo/CentOS-7.repo</code>         阿里云</p>
<p><code>wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code>   网易163</p>
<p>4.使用下载好的repos文件替换默认的repos文件</p>
<p>用CentOS7-Base163.repo替换CentOS-Base.repo</p>
<p><code>mv CentOS7-Base-163.repo CentOS-Base.repo</code></p>
<p>5.清理就缓存数据，缓存新数据</p>
<p><code>yum clean all</code><br><code>yum makecache</code>   就是把服务器的包信息下载到本地电脑缓存起来</p>
<p>6.测试</p>
<p><code>yum list | grep firefox</code>   查看当前是否安装了firefox相关的软件<br><code>yum -y install firefox</code>    如果没有的话，yum方式安装</p>
<hr>
<h1 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h1><p>略</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell</title>
    <url>/2023/08/10/Shell/</url>
    <content><![CDATA[<h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><p>shell是一个命令行解释器，它接收应用程序&#x2F;用户命令，然后调用操作系统内核。</p>
<p>shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强</p>
<hr>
<h1 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h1><p><strong>1）脚本格式</strong></p>
<p>脚本以<font color=Red>#!&#x2F;bin&#x2F;bash</font>开头（指定解析器）</p>
<p><strong>2）第一个 Shell 脚本：helloworld.sh</strong></p>
<p>（1）需求：创建一个 Shell 脚本，输出 helloworld</p>
<p>（2）案例实操：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch helloworld.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.sh</span><br><span class="line"></span><br><span class="line">在 helloworld.sh 中输入如下内容</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld</span><br></pre></td></tr></table></figure>

<p>（3）脚本的常用执行方式</p>
<p>​	第一种：采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限)</p>
<p>​	sh+脚本的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​	sh+脚本的绝对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh /home/atguigu/shells/helloworld.sh</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>

<p>​	bash+脚本的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​	bash+脚本的绝对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash /home/atguigu/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​	第二种：采用输入脚本的绝对路径或相对路径执行脚本<font color=Red>（必须具有可执行权限+x）</font></p>
<p>​	①首先要赋予 helloworld.sh 脚本的+x 权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ chmod +x helloworld.sh</span><br></pre></td></tr></table></figure>

<p>​	②执行脚本</p>
<p>​		相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​		绝对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ /home/atguigu/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​		注意：第一种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执行 权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p>
<p>​	【了解】第三种：在脚本的路径前加上“.”或者 source</p>
<p>​	①有以下脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat test.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=5</span><br><span class="line">echo $A</span><br></pre></td></tr></table></figure>

<p>​	②分别使用 sh，bash，.&#x2F; 和 . 的方式来执行，结果如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ sh test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ ./test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ . test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>​		原因： </p>
<p>​		前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则 子 shell 关闭，回到父 shell 中。</p>
<p>​		第三种，也就是使用在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前 shell 里执行，而无需打开子 shell！这也是为什么我们每次要修改完&#x2F;etc&#x2F;profile 文件以后，需 要 source 一下的原因。 </p>
<p>​		开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的 当前变量，父 shell 是不可见的。</p>
<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h3><p><strong>1）常用系统变量</strong></p>
<p>​		$HOME、$PWD、$SHELL、$USER 等</p>
<p><strong>2）案例实操</strong></p>
<p>（1）查看系统变量的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $HOME</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure>

<p>（2）显示当前 Shell 中所有变量：set</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure>

<h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p><strong>1）基本语法</strong></p>
<p>​	（1）定义变量：变量名&#x3D;变量值， <font color=Red>注意，&#x3D;号前后不能有空格</font></p>
<p>​	（2）撤销变量：unset 变量名</p>
<p>​	（3）声明静态变量：readonly 变量，注意：不能 unset</p>
<p><strong>2）变量定义规则</strong></p>
<p>​	（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头， <font color=Red>环境变量名建议大写</font>。</p>
<p>​	（2）等号两侧不能有空格。</p>
<p>​	（3）在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。 </p>
<p>​	（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p>
<p><strong>3）案例实操</strong></p>
<p>​	（1）定义变量 A</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=5</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>​	（2）给变量 A 重新赋值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=8</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>​	（3）撤销变量 A</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ unset A</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br></pre></td></tr></table></figure>

<p>​	（4）声明静态的变量 B&#x3D;2，不能 unset</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ readonly B=2</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $B</span><br><span class="line">2</span><br><span class="line">[atguigu@hadoop101 shells]$ B=9</span><br><span class="line">-bash: B: readonly variable</span><br></pre></td></tr></table></figure>

<p>​	（5）在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ C=1+2</span><br><span class="line">[atguigu@hadoop102 ~]$ echo $C</span><br><span class="line">1+2</span><br></pre></td></tr></table></figure>

<p>​	（6）变量的值如果有空格，需要使用双引号或单引号括起来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ D=I love banzhang</span><br><span class="line">-bash: world: command not found</span><br><span class="line">[atguigu@hadoop102 ~]$ D=&quot;I love banzhang&quot;</span><br><span class="line">[atguigu@hadoop102 ~]$ echo $D</span><br><span class="line">I love banzhang</span><br></pre></td></tr></table></figure>

<p>​	（7）可把变量提升为全局环境变量，可供其他 Shell 程序使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export 变量名</span><br><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.sh</span><br></pre></td></tr></table></figure>

<p>​	在 helloworld.sh 文件中增加echo $B</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld&quot;</span><br><span class="line">echo $B</span><br><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>

<p>​	发现并没有打印输出变量 B 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ export B</span><br><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">helloworld</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><h4 id="n"><a href="#n" class="headerlink" title="$n"></a>$n</h4><p><strong>1）基本语法</strong></p>
<p>​	$n （功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}） </p>
<p><strong>2）案例实操</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls</span><br><span class="line">xz</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title="$#"></a>$#</h4><p><strong>1）基本语法</strong></p>
<p>​	$#（功能描述：获取所有 <font color=Red>输入参数个数</font>，常用于循环,判断参数的个数是否正确以及 加强脚本的健壮性）。</p>
<p><strong>2）案例实操</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27;</span><br><span class="line">echo $#</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls</span><br><span class="line">xz</span><br><span class="line">==========$#==========</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="、"><a href="#、" class="headerlink" title="$*、$@"></a>$*、$@</h4><p><strong>1）基本语法</strong></p>
<p>​	$* （功能描述：这个变量代表命令行中所有的参数，<font color=Red>$*把所有的参数看成一个整体</font>）	</p>
<p> $@ （功能描述：这个变量也代表命令行中所有的参数，不过<font color=Red>$@把每个参数区分对待</font>）	</p>
<p><strong>2）案例实操</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27;</span><br><span class="line">echo $#</span><br><span class="line">echo &#x27;==========$*==========&#x27;</span><br><span class="line">echo $*</span><br><span class="line">echo &#x27;==========$@==========&#x27;</span><br><span class="line">echo $@</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh a b c d e f g</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">==========$#==========</span><br><span class="line">7</span><br><span class="line">==========$*==========</span><br><span class="line">a b c d e f g</span><br><span class="line">==========$@==========</span><br><span class="line">a b c d e f g</span><br></pre></td></tr></table></figure>

<h4 id="？"><a href="#？" class="headerlink" title="$？"></a>$？</h4><p><strong>1）基本语法</strong></p>
<p>​	$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明 上一个命令执行不正确了。）</p>
<p><strong>2）案例实操</strong></p>
<p>​	判断 helloworld.sh 脚本是否正确执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>1）基本语法</strong></p>
<p>​	“$((运算式))” 或 “$[运算式]”</p>
<p><strong>2）案例实操</strong></p>
<p>​	计算（2+3）* 4 的值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]# S=$[(2+3)*4]</span><br><span class="line">[atguigu@hadoop101 shells]# echo $S</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p><strong>1）基本语法</strong></p>
<p>​	（1）test condition </p>
<p>​	（2）[ condition ]（<font color=Red>注意 condition 前后要有空格</font>)	</p>
<p>​	 注意：条件非空即为 true，[ atguigu ]返回 true，[   ]返回 false.</p>
<p><strong>2）常用条件判断</strong></p>
<p>​	（1）两个整数之间比较 </p>
<p>​	-eq 等于（equal）</p>
<p>​	-ne 不等于（not equal） </p>
<p>​	-lt 小于（less than） </p>
<p>​	-le 小于等于（less equal）</p>
<p>​	 -gt 大于（greater than） </p>
<p>​	-ge 大于等于（greater equal） </p>
<p>​	注：如果是字符串之间的比较 ，用等号“&#x3D;”判断相等；用“!&#x3D;”判断不等。 </p>
<p>​	（2）按照文件权限进行判断</p>
<p>​	-r 有读的权限（read）</p>
<p>​	-w 有写的权限（write） </p>
<p>​	-x 有执行的权限（execute） </p>
<p>​	（3）按照文件类型进行判断 </p>
<p>​	-e 文件存在（existence） </p>
<p>​	-f 文件存在并且是一个常规的文件（file）</p>
<p>​	-d 文件存在并且是一个目录（directory）</p>
<p><strong>3）案例实操</strong></p>
<p>（1）23 是否大于等于 22</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ 23 -ge 22 ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（2）helloworld.sh 是否具有写权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -w helloworld.sh ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>（3）&#x2F;home&#x2F;atguigu&#x2F;cls.txt 目录中的文件是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -e /home/atguigu/cls.txt ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一 条命令执行失败后，才执行下一条命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ [ atguigu ] &amp;&amp; echo OK || echo notOK</span><br><span class="line">OK</span><br><span class="line">[atguigu@hadoop101 shells]$ [ ] &amp;&amp; echo OK || echo notOK</span><br><span class="line">notOK</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="流程控制（重点）"><a href="#流程控制（重点）" class="headerlink" title="流程控制（重点）"></a>流程控制（重点）</h1><h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><p><strong>1）基本语法</strong></p>
<p>​	（1）单分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>​	或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>（2）多分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">	程序</span><br><span class="line">else</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>​	注意事项： </p>
<p>​	①[ 条件判断式 ]，中括号和条件判断式之间必须有空格 </p>
<p>​	②if 后要有空格</p>
<p><strong>2）案例实操</strong></p>
<p>​	输入一个数字，如果是 1，则输出 banzhang zhen shuai，如果是 2，则输出 cls zhen mei， 如果是其它，什么也不输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch if.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim if.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq 1 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;banzhang zhen shuai&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;cls zhen mei&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 if.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./if.sh 1</span><br><span class="line">banzhang zhen shua</span><br></pre></td></tr></table></figure>

<h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><p><strong>1）基本语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值 1&quot;）</span><br><span class="line">	如果变量的值等于值 1，则执行程序 1</span><br><span class="line">;;</span><br><span class="line">&quot;值 2&quot;）</span><br><span class="line">	如果变量的值等于值 2，则执行程序 2</span><br><span class="line">;;</span><br><span class="line">	…省略其他分支…</span><br><span class="line">*）</span><br><span class="line">	如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>​	（1）case 行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。 </p>
<p>​	（2）双分号“;;”表示命令序列结束，相当于 java 中的 break。 </p>
<p>​	（3）最后的“*）”表示默认模式，相当于 java 中的 default。</p>
<p><strong>2）案例实操</strong></p>
<p>​	输入一个数字，如果是 1，则输出 banzhang，如果是 2，则输出 cls，如果是其它，输出 renyao。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim case.sh</span><br><span class="line"></span><br><span class="line">!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">	echo &quot;banzhang&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">	echo &quot;cls&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">	echo &quot;renyao&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./case.sh 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>1）基本语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>2）案例实操</strong></p>
<p>​	从 1 加到 100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for1.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">for((i=0;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">	sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for1.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<p><strong>3）基本语法2</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值 1 值 2 值 3…</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>2）案例实操</strong></p>
<p>​	（1）打印所有输入参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for2.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for2.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印数字</span></span><br><span class="line"></span><br><span class="line">for i in cls mly wls</span><br><span class="line">do</span><br><span class="line">	echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for2.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for2.sh</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love mly</span><br><span class="line">ban zhang love wls</span><br></pre></td></tr></table></figure>

<p>​	（2）比较$<em>和$@区别</em></p>
<p>​	$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n 的形式输出所有参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for3.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;=============$*=============&#x27;</span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">	echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line">echo &#x27;=============$@=============&#x27;</span><br><span class="line">for j in $@</span><br><span class="line">do</span><br><span class="line">	echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for3.sh cls mly wls</span><br><span class="line">=============$*=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br></pre></td></tr></table></figure>

<p>​	当它们被双引号“”包含时，$*会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输 出所有参数；$@会将各个参数分开，以“$1” “$2”…“$n”的形式输出所有参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim for4.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;=============$*=============&#x27;</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">$*中的所有参数看成是一个整体，所以这个 <span class="keyword">for</span> 循环只会循环一次</span></span><br><span class="line">do</span><br><span class="line">	echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;=============$@=============&#x27;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$@</span>中的每个参数都看成是独立的，所以“<span class="variable">$@</span>”中有几个参数，就会循环几次</span></span><br><span class="line">do</span><br><span class="line">	echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for4.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for4.sh cls mly wls</span><br><span class="line">=============$*=============</span><br><span class="line">banzhang love cls mly wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br></pre></td></tr></table></figure>

<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><strong>1）基本语法</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>2）案例实操</strong></p>
<p>​	从 1 加到 100</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim while.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">	sum=$[$sum+$i]</span><br><span class="line">	i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./while.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="read-读取控制台输"><a href="#read-读取控制台输" class="headerlink" title="read 读取控制台输"></a>read 读取控制台输</h1><p><strong>1）基本语法</strong></p>
<p>​	read (选项) (参数) </p>
<p>​	①选项： </p>
<p>​			-p：指定读取值时的提示符； </p>
<p>​			-t：指定读取值时等待的时间（秒）如果-t 不加表示一直等待 </p>
<p>​	②参数 </p>
<p>​			变量：指定读取值的变量名</p>
<p><strong>2）案例实操</strong></p>
<p>​	提示 7 秒内，读取控制台输入的名称</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch read.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim read.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds :&quot; NN</span><br><span class="line">echo $NN</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ ./read.sh</span><br><span class="line">Enter your name in 7 seconds : atguigu</span><br><span class="line">atguigu</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p><strong>1）基本语法</strong></p>
<p>​	basename [string &#x2F; pathname] [suffix] 		（功能描述：basename 命令会删掉所有的前 缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。 </p>
<p>​	basename 可以理解为取路径里的文件名称 </p>
<p>​	选项： </p>
<p>​	suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p>
<p><strong>2）案例实操</strong></p>
<p>​	截取该&#x2F;home&#x2F;atguigu&#x2F;banzhang.txt 路径的文件名称。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure>

<h4 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h4><p><strong>1）基本语法</strong></p>
<p>​	dirname 文件绝对路径 		（功能描述：从给定的包含绝对路径的文件名中去除文件名 （非目录的部分），然后返回剩下的路径（目录的部分）） </p>
<p>​	dirname 可以理解为取文件路径的绝对路径名称</p>
<p><strong>2）案例实操</strong></p>
<p>​		获取 banzhang.txt 文件的路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure>

<h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><strong>1）基本语法</strong></p>
<p>​	[ function ] funname[()] </p>
<p>​	{ </p>
<p>​			Action; </p>
<p>​			[return int;] </p>
<p>​	}</p>
<p><strong>2）经验技巧</strong></p>
<p>​	（1）必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一 样先编译。 </p>
<p>​	（2）函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将 以最后一条命令运行结果，作为返回值。return 后跟数值 n(0-255)</p>
<p><strong>3）案例实操</strong></p>
<p>​		计算两个输入参数的和。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim fun.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">	s=0</span><br><span class="line">	s=$[$1+$2]</span><br><span class="line">	echo &quot;$s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input the number1: &quot; n1;</span><br><span class="line">read -p &quot;Please input the number2: &quot; n2;</span><br><span class="line">sum $n1 $n2;</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./fun.sh</span><br><span class="line">Please input the number1: 2</span><br><span class="line">Please input the number2: 5</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h1><h3 id="常规匹配"><a href="#常规匹配" class="headerlink" title="常规匹配"></a>常规匹配</h3><p>​	一串不包含特殊字符的正则表达式匹配它自己，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep atguigu </span><br></pre></td></tr></table></figure>

<p>​	就会匹配所有包含 atguigu 的行。</p>
<h3 id="常用特殊字符"><a href="#常用特殊字符" class="headerlink" title="常用特殊字符"></a>常用特殊字符</h3><p><strong>1）特殊字符：^</strong></p>
<p>​	^ 匹配一行的开头，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ^a </span><br></pre></td></tr></table></figure>

<p>​	会匹配出所有以 a 开头的行</p>
<p><strong>2）特殊字符：$</strong></p>
<p>​	$ 匹配一行的结束，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep t$ </span><br></pre></td></tr></table></figure>

<p>​	会匹配出所有以 t 结尾的行</p>
<p>​	<strong>思考：^$ 匹配什么？</strong>	</p>
<p><strong>3）特殊字符：.</strong></p>
<p>​	. 匹配一个任意的字符，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r..t </span><br></pre></td></tr></table></figure>

<p>​	会匹配包含 rabt,rbbt,rxdt,root 等的所有行</p>
<p><strong>4）特殊字符：</strong>*</p>
<p>​	不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ro*t </span><br></pre></td></tr></table></figure>

<p>​	会匹配 rt, rot, root, rooot, roooot等所有行</p>
<p>​	<em><em>思考：.</em> 匹配什么</em>*</p>
<p><strong>5）字符区间（中括号）：[ ]</strong></p>
<p>​	[ ] 表示匹配某个范围内的一个字符，例如：</p>
<p>​	 [6,8]——匹配 6 或者 8</p>
<p>​	 [0-9]——匹配一个 0-9 的数字 </p>
<p>​	[0-9]*——匹配任意长度的数字字符串 *</p>
<p>​	[a-z]——匹配一个 a-z 之间的字符*</p>
<p>​	[a-z]* ——匹配任意长度的字母字符串</p>
<p>​	[a-c, e-f]-匹配 a-c 或者 e-f 之间的任意字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure>

<p>​	会匹配 rt,rat, rbt, rabt, rbact,rabccbaaacbt 等等所有行</p>
<p><strong>5）特殊字符：\ </strong></p>
<p>​	\ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配 某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要 将转义字符和特殊字符连用，来表示特殊字符本身，例如 ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ‘a\$b’ </span><br></pre></td></tr></table></figure>

<p>​	就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来。</p>
<hr>
<h1 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h1><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>​	cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每 一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p>
<p><strong>1）基本用法</strong></p>
<p>​	cut [选项参数] filename </p>
<p>​	说明：默认分隔符是制表符 </p>
<p><strong>2）选项参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>列号，提取第几列</td>
</tr>
<tr>
<td>-d</td>
<td>分隔符，按照指定分隔符分割列，默认是制表符“\t”</td>
</tr>
<tr>
<td>-c</td>
<td>按字符进行切割 后加加 n 表示取第几列 比如 -c 1</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p>​	（1）数据准备 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch cut.txt</span><br><span class="line">[atguigu@hadoop101 shells]$ vim cut.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br></pre></td></tr></table></figure>

<p>​	（2）切割 cut.txt 第一列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure>

<p>​	（3）切割 cut.txt 第二、三列</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure>

<p>​	（4）在 cut.txt 文件中切割出 guan</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat cut.txt |grep guan | cut -d &quot; &quot; -f 1</span><br><span class="line">guan</span><br></pre></td></tr></table></figure>

<p>​	（5）选取系统 PATH 变量值，第 2 个“：”开始后的所有路径： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/</span><br><span class="line">home/atguigu/bin</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $PATH | cut -d &quot;:&quot; -f 3-</span><br><span class="line">/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/home/atguigu/bin</span><br></pre></td></tr></table></figure>

<p>​	（6）切割 ifconfig 后打印的 IP 地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | grep netmask | cut -d &quot; &quot; -f 10</span><br><span class="line">192.168.111.101</span><br></pre></td></tr></table></figure>

<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>​	一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开 的部分再进行分析处理。</p>
<p><strong>1）基本用法</strong></p>
<p>​	awk  [选项参数]  ‘&#x2F;pattern1&#x2F;{action1} &#x2F;pattern2&#x2F;{action2}…’  filename</p>
<p>​	pattern：表示 awk 在数据中查找的内容，就是匹配模式</p>
<p>​	action：在找到匹配内容时所执行的一系列命令</p>
<p><strong>2）选项参数说明</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定输入文件分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<p><strong>3）案例实操</strong></p>
<p>​	（1）数据准备 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sudo cp /etc/passwd ./</span><br><span class="line">passwd 数据的含义</span><br><span class="line">用户名:密码(加密过后的):用户 id:组 id:注释:用户家目录:sh</span><br></pre></td></tr></table></figure>

<p>​	（2）搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 7 列。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $7&#125;&#x27; passwd</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>​	（3）搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 1 列和第 7 列， 中间以“，”号分割。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure>

<p>​	注意：只有匹配了 pattern 的行才会执行 action。</p>
<p>​	（4）只显示&#x2F;etc&#x2F;passwd 的第一列和第七列，以逗号分割，且在所有行前面添加列名 user， shell 在最后一行添加”dahaige，&#x2F;bin&#x2F;zuishuai”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125;</span><br><span class="line">END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd</span><br><span class="line">user, shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">bin,/sbin/nologin 。。。</span><br><span class="line">atguigu,/bin/bash</span><br><span class="line">dahaige,/bin/zuishuai</span><br></pre></td></tr></table></figure>

<p>​	注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p>
<p>​	（5）将 passwd 文件中的用户 id 增加数值 1 并输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -v i=1 -F : &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>4）awk 的内置变量</strong></p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数（行号）</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<p><strong>5）案例实操</strong></p>
<p>​	（1）统计 passwd 文件名，每行的行号，每行的列数 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenum:&quot;</span><br><span class="line">NR &quot;,col:&quot;NF&#125;&#x27; passwd</span><br><span class="line">filename:passwd,linenum:1,col:7</span><br><span class="line">filename:passwd,linenum:2,col:7</span><br><span class="line">filename:passwd,linenum:3,col:7</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​	（2）搜查询 ifconfig 命令输出结果中的空行所在的行号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig | awk &#x27;/^$/&#123;print NR&#125;&#x27;</span><br><span class="line">9</span><br><span class="line">18</span><br><span class="line">26</span><br></pre></td></tr></table></figure>

<p>​	（3）切割 IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | awk &#x27;/netmask/ &#123;print $2&#125;&#x27;</span><br><span class="line">192.168.6.101</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="综合应用案例"><a href="#综合应用案例" class="headerlink" title="综合应用案例"></a>综合应用案例</h1><h3 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h3><p>​	实际生产应用中，往往需要对重要数据进行归档备份。 </p>
<p>​	需求：实现一个每天对指定目录归档备份的脚本，输入一个目录名称（末尾不带&#x2F;）， 将目录下所有文件按天归档保存，并将归档日期附加在归档文件名上，放在&#x2F;root&#x2F;archive 下。 </p>
<p>​	这里用到了归档命令：tar</p>
<p>​	后面可以加上-c 选项表示归档，加上-z 选项表示同时进行压缩，得到的文件后缀名 为.tar.gz。 </p>
<p>​	脚本实现如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先判断输入参数个数是否为1</span></span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;参数个数错误！应该输入一个参数，作为归档目录名&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从参数中获取目录名称</span></span><br><span class="line">if [ -d $1 ]</span><br><span class="line">then</span><br><span class="line">	echo</span><br><span class="line">else</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;目录不存在！&quot;</span><br><span class="line">	echo</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">DIR_NAME=$(basename $1)</span><br><span class="line">DIR_PATH=$(cd $(dirname $1); pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前日期</span></span><br><span class="line">DATE=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义生成的归档文件名称</span></span><br><span class="line">FILE=archive_$&#123;DIR_NAME&#125;_$DATE.tar.gz</span><br><span class="line">DEST=/root/archive/$FILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始归档目录文件</span></span><br><span class="line"></span><br><span class="line">echo &quot;开始归档...&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">tar -czf $DEST $DIR_PATH/$DIR_NAME</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">	echo</span><br><span class="line">	echo &quot;归档成功！&quot;</span><br><span class="line">	echo &quot;归档文件为：$DEST&quot;</span><br><span class="line">	echo</span><br><span class="line">else</span><br><span class="line">	echo &quot;归档出现问题！&quot;</span><br><span class="line">	echo</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>​	我们可以利用 Linux 自带的 mesg 和 write 工具，向其它用户发送消息。</p>
<p>​	需求：实现一个向某个用户快速发送消息的脚本，输入用户名作为第一个参数，后面直 接跟要发送的消息。脚本需要检测用户是否登录在系统中、是否打开消息功能，以及当前发 送消息是否为空。</p>
<p>​	脚本实现如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">login_user=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $login_user ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;$1 不在线！&quot;</span><br><span class="line">	echo &quot;脚本退出..&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">is_allowed=$(who -T | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ $is_allowed != &quot;+&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;$1 没有开启消息功能&quot;</span><br><span class="line">	echo &quot;脚本退出..&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z $2 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;没有消息发出&quot;</span><br><span class="line">	echo &quot;脚本退出..&quot;</span><br><span class="line">	exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">whole_msg=$(echo $* | cut -d &quot; &quot; -f 2- )</span><br><span class="line"></span><br><span class="line">user_terminal=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">echo $whole_msg | write $login_user $user_terminal</span><br><span class="line"></span><br><span class="line">if [ $? != 0 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;发送失败！&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;发送成功！&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>面经-C++基础语法</title>
    <url>/2023/07/15/C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++基础语法"></a>C++基础语法</h1><h2 id="1、-在main执行之前和之后执行的代码可能是什么？"><a href="#1、-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1、 在main执行之前和之后执行的代码可能是什么？"></a>1、 在main执行之前和之后执行的代码可能是什么？</h2><p><strong>main函数执行之前</strong>，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，指针为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li>全局对象初始化，在<code>main</code>之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li><code>__attribute__((constructor))</code></li>
</ul>
<p><strong>main函数执行之后</strong>：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 <strong><code>atexit</code></strong> 注册一个函数，它会在main 之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h2 id="2、结构体内存对齐问题？"><a href="#2、结构体内存对齐问题？" class="headerlink" title="2、结构体内存对齐问题？"></a>2、结构体内存对齐问题？</h2><ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li>
<li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li>
</ul>
<p>c++11以后引入两个关键字 <a href="https://zh.cppreference.com/w/cpp/language/alignas">alignas (opens new window)</a>与 <a href="https://zh.cppreference.com/w/cpp/language/alignof">alignof (opens new window)</a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。</p>
<p>但是<code>alignas</code>在某些情况下是不能使用的，具体见下面的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alignas 生效的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint16_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 6  2 + 2 + 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Info2 &#123;</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint16_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="comment">// 8  4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><code>alignas</code>将内存对齐调整为4个字节。所以<code>sizeof(Info2)</code>的值变为了8。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alignas 失效的情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 12  4 + 4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">2</span>) Info2 &#123;</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info2) &lt;&lt; std::endl;   <span class="comment">// 12  4 + 4 + 4</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info2) &lt;&lt; std::endl;  <span class="comment">// 4</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</p>
<ul>
<li><p>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(push,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span> a;</span><br><span class="line">  <span class="type">uint32_t</span> b;</span><br><span class="line">  <span class="type">uint8_t</span> c;</span><br><span class="line">&#125; ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 6 1 + 4 + 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>确定结构体中每个元素大小可以通过下面这种方法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN __attribute__((packed))</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ONEBYTE_ALIGN</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(push,1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 0 1   3     6   8 9            15</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* |a| b |  c  | d |e|     pad     |</span></span><br><span class="line"><span class="comment">* | |   |     |   | |             |</span></span><br><span class="line"><span class="comment">* +-+---+-----+---+-+-------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> a : <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint16_t</span> b : <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint16_t</span> c : <span class="number">3</span>;</span><br><span class="line">  <span class="type">uint16_t</span> d : <span class="number">2</span>;</span><br><span class="line">  <span class="type">uint16_t</span> e : <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint16_t</span> pad : <span class="number">7</span>;</span><br><span class="line">&#125; ONEBYTE_ALIGN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) || defined(__GNUG__)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_MSC_VER)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">undef</span> ONEBYTE_ALIGN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Info) &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">alignof</span>(Info) &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种处理方式是<code>alignas</code>处理不了的。</p>
</li>
</ul>
<h2 id="3、指针和引用的区别"><a href="#3、指针和引用的区别" class="headerlink" title="3、指针和引用的区别"></a>3、指针和引用的区别</h2><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li>
<li>引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<p>参考代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;指针p为NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPTR</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">	p = &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testREFF</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">	p = a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>* b = &amp;a;</span><br><span class="line">	<span class="built_in">testPTR</span>(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; *b &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">testREFF</span>(a);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在编译器看来, int a &#x3D; 10; int &amp;b &#x3D; a; 等价于 int * const b &#x3D; &a; 而 b &#x3D; 20; 等价于 *b &#x3D; 20; 自动转换为指针和自动解引用.</p>
<h2 id="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h2><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h2 id="5、堆和栈的区别"><a href="#5、堆和栈的区别" class="headerlink" title="5、堆和栈的区别"></a>5、堆和栈的区别</h2><ul>
<li>申请方式不同。<ul>
<li>栈由系统自动分配。</li>
</ul>
</li>
<li>堆是自己申请和释放的。</li>
<li>申请大小限制不同。<ul>
<li>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。</li>
<li>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
</ul>
</li>
<li>申请效率不同。<ul>
<li>栈由系统分配，速度快，不会有碎片。</li>
<li>堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
</li>
</ul>
<p>栈空间默认是4M, 堆区一般是 1G - 4G</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>堆</th>
<th>栈</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>管理方式</strong></td>
<td>堆中资源由程序员控制（容易产生memory leak）</td>
<td>栈资源由编译器自动管理，无需手工控制</td>
</tr>
<tr>
<td align="left"><strong>内存管理机制</strong></td>
<td>系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）</td>
<td>只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）</td>
</tr>
<tr>
<td align="left"><strong>空间大小</strong></td>
<td>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td>
<td>栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）</td>
</tr>
<tr>
<td align="left"><strong>碎片问题</strong></td>
<td>对于堆，频繁的new&#x2F;delete会造成大量碎片，使程序效率降低</td>
<td>对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别）</td>
</tr>
<tr>
<td align="left"><strong>生长方向</strong></td>
<td>堆向上，向高地址方向增长。</td>
<td>栈向下，向低地址方向增长。</td>
</tr>
<tr>
<td align="left"><strong>分配方式</strong></td>
<td>堆都是动态分配（没有静态分配的堆）</td>
<td>栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。</td>
</tr>
<tr>
<td align="left"><strong>分配效率</strong></td>
<td>堆由C&#x2F;C++函数库提供，机制很复杂。所以堆的效率比栈低很多。</td>
<td>栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。</td>
</tr>
</tbody></table>
<p><strong>形象的比喻</strong></p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h2 id="6、你觉得堆快一点还是栈快一点？"><a href="#6、你觉得堆快一点还是栈快一点？" class="headerlink" title="6、你觉得堆快一点还是栈快一点？"></a>6、你觉得堆快一点还是栈快一点？</h2><p>毫无疑问是栈快一点。</p>
<p>因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。</p>
<p>而堆的操作是由C&#x2F;C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h2 id="7、区别以下指针类型？"><a href="#7、区别以下指针类型？" class="headerlink" title="7、区别以下指针类型？"></a>7、区别以下指针类型？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>]</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>]</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span> </span></span><br></pre></td></tr></table></figure>

<ul>
<li>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li>
<li>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
<h2 id="8、new-delete-与-malloc-free的异同"><a href="#8、new-delete-与-malloc-free的异同" class="headerlink" title="8、new &#x2F; delete 与 malloc &#x2F; free的异同"></a>8、new &#x2F; delete 与 malloc &#x2F; free的异同</h2><p>相同点</p>
<ul>
<li>都可用于内存的动态申请和释放</li>
</ul>
<p>不同点</p>
<ul>
<li>前者是C++运算符，后者是C&#x2F;C++语言标准库函数</li>
<li>new自动计算要分配的空间大小，malloc需要手工计算</li>
<li>new是类型安全的，malloc不是。例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">double</span>));<span class="comment">//编译无错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li>new调用名为<strong>operator new</strong>的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为<strong>operator delete</strong>的标准库函数释放该对象所用内存。后者均没有相关调用</li>
<li>后者需要库文件支持，前者不用</li>
<li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li>
</ul>
<h2 id="9、new和delete是如何实现的？"><a href="#9、new和delete是如何实现的？" class="headerlink" title="9、new和delete是如何实现的？"></a>9、new和delete是如何实现的？</h2><ul>
<li>new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针</li>
<li>delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存</li>
</ul>
<h2 id="10、malloc和new的区别？"><a href="#10、malloc和new的区别？" class="headerlink" title="10、malloc和new的区别？"></a>10、malloc和new的区别？</h2><ul>
<li>malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。</li>
<li>malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。</li>
<li>malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。</li>
</ul>
<h2 id="11、既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？"><a href="#11、既然有了malloc-free，C-中为什么还需要new-delete呢？直接用malloc-free不好吗？" class="headerlink" title="11、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？"></a>11、既然有了malloc&#x2F;free，C++中为什么还需要new&#x2F;delete呢？直接用malloc&#x2F;free不好吗？</h2><ul>
<li>malloc&#x2F;free和new&#x2F;delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc&#x2F;free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc&#x2F;free，所以new&#x2F;delete是必不可少的。</li>
</ul>
<h2 id="12、被free回收的内存是立即返还给操作系统吗？"><a href="#12、被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="12、被free回收的内存是立即返还给操作系统吗？"></a>12、被free回收的内存是立即返还给操作系统吗？</h2><p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h2 id="13、宏定义和函数有何区别？"><a href="#13、宏定义和函数有何区别？" class="headerlink" title="13、宏定义和函数有何区别？"></a>13、宏定义和函数有何区别？</h2><ul>
<li>宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。</li>
<li>宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。</li>
<li>宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li>
<li>宏定义不要在最后加分号。</li>
</ul>
<h2 id="14、宏定义和typedef区别？"><a href="#14、宏定义和typedef区别？" class="headerlink" title="14、宏定义和typedef区别？"></a>14、宏定义和typedef区别？</h2><ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li>
<li>宏不检查类型；typedef会检查数据类型。</li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li>
<li>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</li>
</ul>
<h2 id="15、变量声明和定义区别？"><a href="#15、变量声明和定义区别？" class="headerlink" title="15、变量声明和定义区别？"></a>15、变量声明和定义区别？</h2><ul>
<li>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</li>
<li>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</li>
</ul>
<h2 id="16、strlen和sizeof区别？"><a href="#16、strlen和sizeof区别？" class="headerlink" title="16、strlen和sizeof区别？"></a>16、strlen和sizeof区别？</h2><ul>
<li>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</li>
<li>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</li>
<li>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h2 id="16-2、（补充题）一个指针占多少字节？"><a href="#16-2、（补充题）一个指针占多少字节？" class="headerlink" title="16.2、（补充题）一个指针占多少字节？"></a>16.2、（补充题）一个指针占多少字节？</h2><p>在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；</p>
<p>而在32位环境下，指针占用大小为4字节。</p>
<p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p>
<p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p>
<h2 id="17、常量指针和指针常量区别？"><a href="#17、常量指针和指针常量区别？" class="headerlink" title="17、常量指针和指针常量区别？"></a>17、常量指针和指针常量区别？</h2><ul>
<li>指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。</li>
<li>常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。</li>
</ul>
<h2 id="18、a和-a有什么区别？"><a href="#18、a和-a有什么区别？" class="headerlink" title="18、a和&amp;a有什么区别？"></a>18、a和&amp;a有什么区别？</h2><p>假设数组int a[10]; int (*p)[10] &#x3D; &a;其中：</p>
<ul>
<li>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) &#x3D; a[1]。</li>
<li>&amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</li>
<li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。</li>
</ul>
<h2 id="19、C-和Python的区别"><a href="#19、C-和Python的区别" class="headerlink" title="19、C++和Python的区别"></a>19、C++和Python的区别</h2><p>包括但不限于：</p>
<ul>
<li>Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>Python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>Python的库函数比C++的多，调用起来很方便</li>
</ul>
<h2 id="20、C-和C语言的区别"><a href="#20、C-和C语言的区别" class="headerlink" title="20、C++和C语言的区别"></a>20、C++和C语言的区别</h2><ul>
<li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li>
<li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li>
<li>C++中的try&#x2F;catch&#x2F;throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li>
<li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的</li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等</li>
</ul>
<h2 id="21、C-与Java的区别"><a href="#21、C-与Java的区别" class="headerlink" title="21、C++与Java的区别"></a>21、C++与Java的区别</h2><p><strong>语言特性</strong></p>
<ul>
<li>Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强</li>
<li>Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题</li>
<li>C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果</li>
<li>Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性</li>
</ul>
<p><strong>垃圾回收</strong></p>
<ul>
<li>C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放</li>
<li>Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）</li>
<li>Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架</li>
<li>对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在</li>
</ul>
<h2 id="22、C-中struct和class的区别"><a href="#22、C-中struct和class的区别" class="headerlink" title="22、C++中struct和class的区别"></a>22、C++中struct和class的区别</h2><p><strong>相同点</strong></p>
<ul>
<li>两者都拥有成员函数、公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承， 而struct默认是public继承</li>
</ul>
<p><strong>引申</strong>：C++和C的struct区别</p>
<ul>
<li>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</li>
<li>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员<strong>不可以是函数</strong></li>
<li>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</li>
<li>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</li>
</ul>
<h2 id="23、define宏定义和const的区别"><a href="#23、define宏定义和const的区别" class="headerlink" title="23、define宏定义和const的区别"></a>23、define宏定义和const的区别</h2><p><strong>编译阶段</strong></p>
<ul>
<li>define是在编译的<strong>预处理</strong>阶段起作用，而const是在编译、运行的时候起作用</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</li>
<li>const常量有数据类型，编译器可以对其进行类型安全检查</li>
</ul>
<p><strong>内存占用</strong></p>
<ul>
<li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li>
<li>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</li>
<li>宏不检查类型；const会检查数据类型。</li>
<li>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</li>
</ul>
<h2 id="24、C-中const和static的作用"><a href="#24、C-中const和static的作用" class="headerlink" title="24、C++中const和static的作用"></a>24、C++中const和static的作用</h2><p><strong>static</strong></p>
<ul>
<li>不考虑类的情况<ul>
<li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li>
<li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。</li>
<li>static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；<strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li>
</ul>
</li>
</ul>
<p><strong>const</strong></p>
<ul>
<li>不考虑类的情况<ul>
<li>const常量在定义时必须初始化，之后无法更改</li>
<li>const形参可以接收const和非const类型的实参，例如&#x2F;&#x2F; i 可以是 int 型或者 const int 型void fun(const int&amp; i){ &#x2F;&#x2F;…}</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li>const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化</li>
<li>const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值</li>
</ul>
</li>
</ul>
<p>补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。</p>
<h2 id="25、C-的顶层const和底层const"><a href="#25、C-的顶层const和底层const" class="headerlink" title="25、C++的顶层const和底层const"></a>25、C++的顶层const和底层const</h2><p><strong>概念区分</strong></p>
<ul>
<li><strong>顶层</strong>const：指的是const修饰的变量<strong>本身</strong>是一个常量，无法修改，指的是指针，就是 * 号的右边</li>
<li><strong>底层</strong>const：指的是const修饰的变量<strong>所指向的对象</strong>是一个常量，指的是所指变量，就是 * 号的左边</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">//顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;       <span class="comment">//底层const，b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>; 		   <span class="comment">//顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">//前一个const为底层，后一个为顶层，b4不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;		   <span class="comment">//用于声明引用变量，都是底层const</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>区分作用</strong></p>
<ul>
<li>执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const</li>
<li>使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;<span class="type">int</span> <span class="type">const</span> a;<span class="type">const</span> <span class="type">int</span> *a;<span class="type">int</span> *<span class="type">const</span> a;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>int const a和const int a均表示定义常量类型a。</li>
<li>const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)</li>
<li>int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)</li>
</ul>
<h2 id="26、数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#26、数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="26、数组名和指针（这里为指向数组首元素的指针）区别？"></a>26、数组名和指针（这里为指向数组首元素的指针）区别？</h2><ul>
<li>二者均可通过增减偏移量来访问数组中的元素。</li>
<li>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</li>
<li><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></li>
</ul>
<h2 id="27、final和override关键字"><a href="#27、final和override关键字" class="headerlink" title="27、final和override关键字"></a>27、final和override关键字</h2><p>override</p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果不使用override，当你手一抖，将**foo()<strong>写成了</strong>f00()**会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0o</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>final</strong></p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="28、拷贝初始化和直接初始化"><a href="#28、拷贝初始化和直接初始化" class="headerlink" title="28、拷贝初始化和直接初始化"></a>28、拷贝初始化和直接初始化</h2><ul>
<li>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;I am a string&quot;</span>)</span></span>;<span class="comment">//语句1 直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(str1)</span></span>;<span class="comment">//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化</span></span><br><span class="line">string str3 = <span class="string">&quot;I am a string&quot;</span>;<span class="comment">//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</span></span><br><span class="line">string str4 = str1;<span class="comment">//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了提高效率，允许编译器跳过创建临时对象这一步，<strong>直接调用构造函数构造要创建的对象，这样就完全等价于</strong>直接初始化了</p>
<p>（语句1和语句3等价），但是需要辨别两种情况。</p>
<ul>
<li>当拷贝构造函数为private时：语句3和语句4在编译时会报错</li>
<li>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</li>
</ul>
</li>
</ul>
<h2 id="29、初始化和赋值的区别"><a href="#29、初始化和赋值的区别" class="headerlink" title="29、初始化和赋值的区别"></a>29、初始化和赋值的区别</h2><ul>
<li>对于简单类型来说，初始化和赋值没什么区别</li>
<li>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">num1</span>(a),<span class="built_in">num2</span>(b)&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;&#125;;</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="30、extern”C”的用法"><a href="#30、extern”C”的用法" class="headerlink" title="30、extern”C”的用法"></a>30、extern”C”的用法</h2><p>为了能够<strong>正确的在C++代码中调用C语言</strong>的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；</p>
<p>哪些情况下使用extern “C”：</p>
<p>（1）C++代码中调用C语言代码；</p>
<p>（2）在C++中的头文件中使用；</p>
<p>（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；</p>
<p>举个例子，C++中调用C代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_HANDLE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_HANDLE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">result_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">void</span>* <span class="type">my_handle_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">my_handle_t</span> <span class="title">create_handle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">result_t</span> <span class="title">operate_on_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_handle</span><span class="params">(<span class="type">my_handle_t</span> handle)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>综上，总结出使用方法<strong>，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern “C”声明，在.c文件中包含了extern “C”时会出现编译语法错误。</strong>所以使用extern “C”全部都放在于cpp程序相关文件或其头文件中。</p>
<p>总结出如下形式：</p>
<p>（1）C++调用C函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//xx.c</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xx.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（2）C调用C++函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xx.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xx.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="31、野指针和悬空指针"><a href="#31、野指针和悬空指针" class="headerlink" title="31、野指针和悬空指针"></a>31、野指针和悬空指针</h2><p>都是是指向无效内存区域(这里的无效指的是”不安全不可控”)的指针，访问行为将会导致未定义行为。</p>
<ul>
<li><p>野指针<br>野指针，指的是没有被初始化过的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>* p;     <span class="comment">// 未初始化</span></span><br><span class="line">    std::cout&lt;&lt; *p &lt;&lt; std::endl; <span class="comment">// 未初始化就被使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>因此，为了防止出错，对于指针初始化时都是赋值为 nullptr，这样在使用时编译器就不会直接报错，产生非法内存访问。</p>
</li>
<li><p>悬空指针<br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; </span><br><span class="line">  <span class="type">int</span> * p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">  </span><br><span class="line">  p = p2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<p>此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为<code>p=p2=nullptr</code>。此时再使用，编译器会直接保错。 避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。</p>
<p><strong>产生原因及解决办法：</strong></p>
<p>野指针：指针变量未及时初始化 &#x3D;&gt; 定义指针变量及时初始化，要么置空。</p>
<p>悬空指针：指针free或delete之后没有及时置空 &#x3D;&gt; 释放操作后立即置空。</p>
<h2 id="32、C和C-的类型安全"><a href="#32、C和C-的类型安全" class="headerlink" title="32、C和C++的类型安全"></a>32、C和C++的类型安全</h2><p>什么是类型安全？</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。</p>
<p>类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<p><strong>（1）C的类型安全</strong></p>
<p>C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：</p>
<ul>
<li>printf格式输出</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205212341869.png" alt="img"></p>
<p>上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误</p>
<ul>
<li>malloc函数的返回值</li>
</ul>
<p>malloc是C中进行内存分配的函数，它的返回类型是void<em>即空类型指针，常常有这样的用法char</em> pStr&#x3D;(char*)malloc(100*sizeof(char))，这里明显做了显式的类型转换。</p>
<p>类型匹配尚且没有问题，但是一旦出现int* pInt&#x3D;(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。</p>
<p><strong>（2）C++的类型安全</strong></p>
<p>如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li><p>操作符new返回的指针类型严格与对象匹配，而不是void*</p>
</li>
<li><p>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</p>
</li>
<li><p>引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换</p>
</li>
<li><p>一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全</p>
</li>
<li><p>C++提供了<strong>dynamic_cast</strong>关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<p>例1：使用void*进行类型转换</p>
</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205212341679.png" alt="img"></p>
<p> 例2：不同类型指针之间转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">Child1</span>(<span class="type">int</span> e):<span class="built_in">i</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">double</span> d;</span><br><span class="line">	<span class="built_in">Child2</span>(<span class="type">double</span> e):<span class="built_in">d</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line">	Parent* pp;</span><br><span class="line">	Child1* pc1;</span><br><span class="line"> 	</span><br><span class="line">	pp=&amp;c1; </span><br><span class="line">	pc1=(Child1*)pp;  <span class="comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span></span><br><span class="line">	cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; <span class="comment">//输出：5</span></span><br><span class="line"> </span><br><span class="line">	pp=&amp;c2;</span><br><span class="line">	pc1=(Child1*)pp;  <span class="comment">//强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">	cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;<span class="comment">// 输出：1717986918</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void<em>，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void</em>，尽量不对两种类型指针做强制转换。</p>
<h2 id="33、C-中的重载、重写（覆盖）和隐藏的区别"><a href="#33、C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="33、C++中的重载、重写（覆盖）和隐藏的区别"></a>33、C++中的重载、重写（覆盖）和隐藏的区别</h2><p>（1）重载（overload）</p>
<p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（2）重写（覆盖）（override）</p>
<p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p>
<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回值类型</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重写,一般加override可以确保是重写父类的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>重载与重写的区别：</p>
<ul>
<li>重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系</li>
<li>重写要求参数列表相同，重载则要求参数列表不同，返回值不要求</li>
<li>重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul>
<p>（3）隐藏（hide）</p>
<p>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p>
<ul>
<li>两个函数参数相同，但是基类函数不是虚函数。<strong>和重写的区别在于基类函数是否是虚函数。</strong>举个例子：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用的是B中的fun函数</span></span><br><span class="line">    b.A::<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//隐藏父类的fun函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* a)</span></span>&#123;</span><br><span class="line">	   cout &lt;&lt; <span class="string">&quot;A中的fun函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//报错，调用的是B中的fun函数，参数类型不对</span></span><br><span class="line">    b.A::<span class="built_in">fun</span>(<span class="number">2</span>); <span class="comment">//调用A中fun函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>补充：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is A fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is A add &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 覆盖</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is B fun &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;   <span class="comment">// 隐藏</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is B add &quot;</span> &lt;&lt; a + a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖</span></span><br><span class="line">    <span class="comment">// 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。</span></span><br><span class="line"></span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">1</span>);      <span class="comment">// 调用子类 fun 覆盖函数</span></span><br><span class="line">    p-&gt;A::<span class="built_in">fun</span>(<span class="number">1</span>);   <span class="comment">// 调用父类 fun</span></span><br><span class="line">    p-&gt;<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// p-&gt;add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配</span></span><br><span class="line">    <span class="comment">// p-&gt;B::add(1);   // 错误，无法识别子类 add 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="34、C-有哪几种的构造函数"><a href="#34、C-有哪几种的构造函数" class="headerlink" title="34、C++有哪几种的构造函数"></a>34、C++有哪几种的构造函数</h2><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n)&#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">		<span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 age:%d, num:%d\n&quot;</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 age:%d, num:%d\n&quot;</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</li>
<li>复制构造函数用于复制本类的对象</li>
<li>转换构造函数用于将其他类型的变量，隐式转换为本类对象</li>
</ul>
<h2 id="35、浅拷贝和深拷贝的区别"><a href="#35、浅拷贝和深拷贝的区别" class="headerlink" title="35、浅拷贝和深拷贝的区别"></a>35、浅拷贝和深拷贝的区别</h2><p><strong>浅拷贝</strong></p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<p><strong>深拷贝</strong></p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>()&#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">	~<span class="built_in">Student</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Student &quot;</span> &lt;&lt; &amp;name &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="built_in">Student</span>(<span class="type">const</span> Student &amp;s)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">		Student s1;</span><br><span class="line">		<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out&#x27;: double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<h2 id="36、内联函数和宏定义的区别"><a href="#36、内联函数和宏定义的区别" class="headerlink" title="36、内联函数和宏定义的区别"></a>36、内联函数和宏定义的区别</h2><ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数有类型检测、语法判断等功能，而宏没有</li>
</ul>
<p><strong>内联函数适用场景:</strong></p>
<ul>
<li>使用宏定义的地方都可以使用 inline 函数。</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。</li>
</ul>
<h2 id="37、public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#37、public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="37、public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？"></a>37、public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</h2><ul>
<li>public的变量和函数在类的内部外部都可以访问。</li>
<li>protected的变量和函数只能在类的内部和其派生类中访问。</li>
<li>private修饰的元素只能在类内访问。</li>
</ul>
<p>（一）访问权限</p>
<p>派生类可以继承基类中除了构造&#x2F;析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212341241.png" alt="img"></p>
<p>派生类对基类成员的访问形象有如下两种：</p>
<ul>
<li>内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问</li>
<li><strong>外部访问</strong>：在派生类外部，通过派生类的对象对从基类继承来的成员的访问</li>
</ul>
<p>（二）继承权限</p>
<p><strong>public继承</strong></p>
<p>公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p>
<p><strong>protected继承</strong></p>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表</p>
<p><img src="http://oss.interviewguide.cn/img/202205212341074.png" alt="img"></p>
<p><strong>private继承</strong></p>
<p>私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表</p>
<p><img src="http://oss.interviewguide.cn/img/202205212341430.png" alt="img"></p>
<p><strong>总结</strong></p>
<p>一、访问权限</p>
<table>
<thead>
<tr>
<th>访问权限</th>
<th>外部</th>
<th>派生类</th>
<th>内部</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>protected</td>
<td>❌</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>private</td>
<td>❌</td>
<td>❌</td>
<td>✔</td>
</tr>
</tbody></table>
<p>public、protected、private 的访问权限范围关系：</p>
<p>public &gt; protected &gt; private</p>
<p>二、继承权限</p>
<ol>
<li>派生类继承自基类的成员权限有四种状态：public、protected、private、不可见</li>
<li>派生类对基类成员的访问权限取决于两点：一、继承方式；二、基类成员在基类中的访问权限</li>
<li>派生类对基类成员的访问权限是取以上两点中的更小的访问范围（除了 private 的继承方式遇到 private 成员是不可见外）。例如：</li>
</ol>
<ul>
<li>public 继承 + private 成员 &#x3D;&gt; private</li>
<li>private 继承 + protected 成员 &#x3D;&gt; private</li>
<li>private 继承 + private 成员 &#x3D;&gt; 不可见</li>
</ul>
<h2 id="38、如何用代码判断大小端存储？"><a href="#38、如何用代码判断大小端存储？" class="headerlink" title="38、如何用代码判断大小端存储？"></a>38、如何用代码判断大小端存储？</h2><p>大端存储：字数据的高字节存储在低地址中</p>
<p>小端存储：字数据的低字节存储在低地址中</p>
<p>例如：32bit的数字0x12345678</p>
<p><strong>所以在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输</strong></p>
<p>小端模式中的存储方式为：</p>
<p><img src="http://oss.interviewguide.cn/img/202205071832785.png" alt="img"></p>
<p>大端模式中的存储方式为：</p>
<p><img src="http://oss.interviewguide.cn/img/202205071832707.png" alt="img"></p>
<p>了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：</p>
<p><strong>方式一：使用强制类型转换</strong>-这种法子不错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span></span><br><span class="line">    <span class="type">char</span> c = (<span class="type">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>方式二：巧用union联合体</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="39、volatile、mutable和explicit关键字的用法"><a href="#39、volatile、mutable和explicit关键字的用法" class="headerlink" title="39、volatile、mutable和explicit关键字的用法"></a>39、volatile、mutable和explicit关键字的用法</h2><p>(1)<strong>volatile</strong></p>
<p>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素更改</strong>，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用 volatile 声明的变量的值的时候，<strong>系统总是重新从它所在的内存读取数据</strong>，即使它前面的指令刚刚从该处读取过数据。</p>
<p><strong>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</strong></p>
<p><strong>volatile 指针</strong></p>
<p>volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念</p>
<p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpch;<span class="keyword">volatile</span> <span class="type">char</span>* vpch;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> pchc;<span class="type">char</span>* <span class="keyword">volatile</span> pchv;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li>
<li>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</li>
<li>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</li>
</ul>
<p><strong>多线程下的volatile</strong></p>
<p>有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，<strong>该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。</strong></p>
<p>如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。</p>
<p>volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。</p>
<p>（2）<strong>mutable</strong></p>
<p>mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<strong>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</strong>。</p>
<p>样例一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> <span class="type">const</span><span class="comment">//在函数里不可修改this指针指向的值 常量指针</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">10</span>;<span class="comment">//错误  不可修改值，this已经被修饰为常量指针</span></span><br><span class="line">        m_B = <span class="number">20</span>;<span class="comment">//正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>样例二</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量 在常函数里值也可以被修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> person p = <span class="built_in">person</span>();<span class="comment">//修饰常对象 不可修改类成员的值</span></span><br><span class="line">    p.m_A = <span class="number">10</span>;<span class="comment">//错误，被修饰了指针常量</span></span><br><span class="line">    p.m_B = <span class="number">200</span>;<span class="comment">//正确，特殊变量，修饰了mutable</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（3）<strong>explicit</strong></p>
<p>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以<strong>显式的方式进行类型转换</strong>，注意以下几点：</p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上</li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
<h2 id="40、什么情况下会调用拷贝构造函数"><a href="#40、什么情况下会调用拷贝构造函数" class="headerlink" title="40、什么情况下会调用拷贝构造函数"></a>40、什么情况下会调用拷贝构造函数</h2><ul>
<li>用类的一个实例化对象去初始化另一个对象的时候</li>
<li>函数的参数是类的对象时（非引用传递）</li>
<li>函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数</li>
</ul>
<p><strong>另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数</strong></p>
<p><strong>总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数</strong>。</p>
<p>在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。</p>
<p><strong>在VS2019下进行下述实验：</strong></p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor is called&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useClassA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getClassA</span><span class="params">()</span><span class="comment">//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//A&amp; getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	A a;</span></span><br><span class="line"><span class="comment">//	return a;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a1,a3,a4;</span><br><span class="line">	A a2 = a1;  <span class="comment">//调用拷贝构造函数,对应情况1</span></span><br><span class="line">	<span class="built_in">useClassA</span>(a1);<span class="comment">//调用拷贝构造函数，对应情况2</span></span><br><span class="line">	a3 = <span class="built_in">getClassA</span>();<span class="comment">//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3</span></span><br><span class="line">	a4 = <span class="built_in">getClassA2</span>(a1);<span class="comment">//发生NRV优化，且引用返回自身，不会调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>情况1比较好理解</p>
<p>情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象</p>
<p>情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数</p>
<h2 id="41、C-中有几种类型的new"><a href="#41、C-中有几种类型的new" class="headerlink" title="41、C++中有几种类型的new"></a>41、C++中有几种类型的new</h2><p>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new</p>
<p>（1）<strong>plain new</strong></p>
<p>言下之意就是普通的new，就是我们常用的new，在C++中定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>因此<strong>plain new</strong>在空间分配失败的情况下，抛出异常<strong>std::bad_alloc</strong>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc &amp;ex)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果：bad allocation</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（2）<strong>nothrow new</strong></p>
<p>nothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">10e11</span>];</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：alloc failed</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>（3）<strong>placement new</strong></p>
<p>这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>,<span class="type">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*,<span class="type">void</span>*)</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>使用placement new需要注意两点：</p>
<ul>
<li>palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组</li>
<li>placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ADT</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ADT</span>()&#123;</span><br><span class="line">		i = <span class="number">10</span>;</span><br><span class="line">		j = <span class="number">100</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ADT construct i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;j=&quot;</span>&lt;&lt;j &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">ADT</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ADT destruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="keyword">sizeof</span> ADT + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;alloc failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	ADT *q = <span class="built_in">new</span>(p) ADT;  <span class="comment">//placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可</span></span><br><span class="line">	<span class="comment">//delete q;//错误!不能在此处调用delete q;</span></span><br><span class="line">	q-&gt;ADT::~<span class="built_in">ADT</span>();<span class="comment">//显示调用析构函数</span></span><br><span class="line">	<span class="keyword">delete</span>[] p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//ADT construct i=10j=100</span></span><br><span class="line"><span class="comment">//ADT destruct</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="42、C-的异常处理的方法"><a href="#42、C-的异常处理的方法" class="headerlink" title="42、C++的异常处理的方法"></a>42、C++的异常处理的方法</h2><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<ul>
<li>数组下标越界</li>
<li>除法计算时除数为0</li>
<li>动态分配空间时空间不足</li>
<li>…</li>
</ul>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p><strong>（1）try、throw和catch关键字</strong></p>
<p>C++中的异常处理机制主要使用<strong>try</strong>、<strong>throw</strong>和<strong>catch</strong>三个关键字，其在程序中的用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<p><strong>（2）函数的异常声明列表</strong></p>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int fun() throw(int,double,A,B,C)&#123;...&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<p><strong>（3）C++标准异常类 exception</strong></p>
<p>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示</p>
<p><img src="http://oss.interviewguide.cn/img/202205212342667.png" alt="img"></p>
<ul>
<li>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* a = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">  		cout &lt;&lt; <span class="built_in">typeid</span>(*a).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// Error condition</span></span><br><span class="line">  	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (bad_typeid)&#123;</span><br><span class="line">  		cout &lt;&lt; <span class="string">&quot;Object is NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h2 id="43、static的用法和作用？"><a href="#43、static的用法和作用？" class="headerlink" title="43、static的用法和作用？"></a>43、static的用法和作用？</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p>
<p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p>
<p>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p>
<p>3.static的第三个作用是默认初始化为0（static变量）</p>
<p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p>
<p>4.static的第四个作用：C++中的类成员声明static</p>
<ol>
<li>函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；</li>
<li>在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；</li>
<li>在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；</li>
<li>在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；</li>
<li>在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</li>
</ol>
<p>类内：</p>
<ol>
<li>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</li>
<li>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；</li>
<li>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</li>
</ol>
<h2 id="44、指针和const的用法"><a href="#44、指针和const的用法" class="headerlink" title="44、指针和const的用法"></a>44、指针和const的用法</h2><ol>
<li>当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。</li>
<li>int const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过p2读写这个变量的值。顶层指针表示指针本身是一个常量</li>
<li>int const *p1或者const int p1两种情况中const修饰p1，所以理解为p1的值不可以改变，即不可以给p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。</li>
</ol>
<p>底层指针表示指针所指向的变量是一个常量。</p>
<h2 id="45、形参与实参的区别？"><a href="#45、形参与实参的区别？" class="headerlink" title="45、形参与实参的区别？"></a>45、形参与实参的区别？</h2><ol>
<li>形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。</li>
<li>实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</li>
<li>实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。</li>
<li>函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</li>
<li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</li>
</ol>
<h2 id="46、值传递、指针传递、引用传递的区别和效率"><a href="#46、值传递、指针传递、引用传递的区别和效率" class="headerlink" title="46、值传递、指针传递、引用传递的区别和效率"></a>46、值传递、指针传递、引用传递的区别和效率</h2><ol>
<li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li>
<li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li>
<li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li>
</ol>
<h2 id="47、静态变量什么时候初始化"><a href="#47、静态变量什么时候初始化" class="headerlink" title="47、静态变量什么时候初始化"></a>47、静态变量什么时候初始化</h2><ol>
<li>初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</li>
<li>静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</li>
<li>而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</li>
</ol>
<h2 id="48、const关键字的作用有哪些"><a href="#48、const关键字的作用有哪些" class="headerlink" title="48、const关键字的作用有哪些?"></a>48、const关键字的作用有哪些?</h2><ol>
<li>阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；</li>
<li>对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；</li>
<li>在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；</li>
<li>对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；</li>
<li>对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。</li>
<li>const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；</li>
<li>非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；</li>
<li>一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。</li>
<li>const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；</li>
<li>const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；</li>
<li>对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</li>
</ol>
<h2 id="49、什么是类的继承？"><a href="#49、什么是类的继承？" class="headerlink" title="49、什么是类的继承？"></a>49、什么是类的继承？</h2><ol>
<li>类与类之间的关系</li>
</ol>
<p>has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；</p>
<p>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；</p>
<p>is-A，继承关系，关系具有传递性；</p>
<ol>
<li>继承的相关概念</li>
</ol>
<p>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；</p>
<ol>
<li>继承的特点</li>
</ol>
<p>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；</p>
<ol>
<li>继承中的访问控制</li>
</ol>
<p>public、protected、private</p>
<ol>
<li>继承中的构造和析构函数</li>
<li>继承中的兼容性原则</li>
</ol>
<h2 id="50、从汇编层去解释一下引用"><a href="#50、从汇编层去解释一下引用" class="headerlink" title="50、从汇编层去解释一下引用"></a>50、从汇编层去解释一下引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>:      <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">00401048</span>  mov     dword ptr [ebp<span class="number">-4</span>],<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:     <span class="type">int</span> &amp;b = x;</span><br><span class="line"></span><br><span class="line"><span class="number">0040104F</span>   lea     eax,[ebp<span class="number">-4</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">00401052</span>  mov     dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p>
<p>lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器</p>
<p>mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址</p>
<p>ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p>
<h2 id="51、深拷贝与浅拷可以描述一下吗？"><a href="#51、深拷贝与浅拷可以描述一下吗？" class="headerlink" title="51、深拷贝与浅拷可以描述一下吗？"></a>51、深拷贝与浅拷可以描述一下吗？</h2><p>浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”。</p>
<p>换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p>
<p>深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。</p>
<p>在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A&#x3D;B。</p>
<p>这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存，这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是悬挂指针了，出现运行错误。</p>
<h2 id="52、new和malloc的区别"><a href="#52、new和malloc的区别" class="headerlink" title="52、new和malloc的区别"></a>52、new和malloc的区别</h2><p>1、 new&#x2F;delete是C++关键字，需要编译器支持。malloc&#x2F;free是库函数，需要头文件支持；</p>
<p>2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
<p>3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
<p>4、 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
<p>5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
<h2 id="53、delete-p、delete-p、allocator都有什么作用？"><a href="#53、delete-p、delete-p、allocator都有什么作用？" class="headerlink" title="53、delete p、delete [] p、allocator都有什么作用？"></a>53、delete p、delete [] p、allocator都有什么作用？</h2><p>1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；</p>
<p>2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；</p>
<p>3、 delete[]时，数组中的元素按逆序的顺序进行销毁；</p>
<p>4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。</p>
<h2 id="54、new和delete的实现原理，-delete是如何知道释放内存的大小的？"><a href="#54、new和delete的实现原理，-delete是如何知道释放内存的大小的？" class="headerlink" title="54、new和delete的实现原理， delete是如何知道释放内存的大小的？"></a>54、new和delete的实现原理， delete是如何知道释放内存的大小的？</h2><p>1、 new简单类型直接调用operator new分配内存；</p>
<p>而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；</p>
<p>对于简单类型，new[]计算好大小后调用operator new；</p>
<p>对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；</p>
<p>① new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；</p>
<p>② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；</p>
<p>③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
<p>2、 delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。</p>
<p>3、 需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。</p>
<h2 id="55、malloc申请的存储空间能用delete释放吗"><a href="#55、malloc申请的存储空间能用delete释放吗" class="headerlink" title="55、malloc申请的存储空间能用delete释放吗?"></a>55、malloc申请的存储空间能用delete释放吗?</h2><p>不能，malloc &#x2F;free主要为了兼容C，new和delete 完全可以取代malloc &#x2F;free的。</p>
<p>malloc &#x2F;free的操作对象都是必须明确大小的，而且不能用在动态类上。</p>
<p>new 和delete会自动进行类型检查和大小，malloc&#x2F;free不能执行构造函数与析构函数，所以动态对象它是不行的。</p>
<p>当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。</p>
<h2 id="56、malloc与free的实现原理？"><a href="#56、malloc与free的实现原理？" class="headerlink" title="56、malloc与free的实现原理？"></a>56、malloc与free的实现原理？</h2><p>1、 在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;</p>
<p>2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；</p>
<p>3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。</p>
<p>4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</p>
<h2 id="57、malloc、realloc、calloc的区别"><a href="#57、malloc、realloc、calloc的区别" class="headerlink" title="57、malloc、realloc、calloc的区别"></a>57、malloc、realloc、calloc的区别</h2><ol>
<li>malloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">20</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));申请<span class="number">20</span>个<span class="type">int</span>类型的空间；</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ol>
<li>calloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> n,<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">calloc</span>(<span class="number">20</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；</p>
<ol>
<li>realloc函数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">realloc</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> new_size)</span></span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>给动态分配的空间分配额外的空间，用于扩充容量。</p>
<h2 id="58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#58、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h2><ol>
<li>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。</li>
</ol>
<p>这两种方式的主要区别在于：</p>
<p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p>
<p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
<ol>
<li>一个派生类构造函数的执行顺序如下：</li>
</ol>
<p>① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。</p>
<p>② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。</p>
<p>③ 类类型的成员对象的构造函数（按照成员对象在类中的定义顺序）</p>
<p>④ 派生类自己的构造函数。</p>
<ol>
<li>方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</li>
</ol>
<h2 id="59、有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#59、有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="59、有哪些情况必须用到成员列表初始化？作用是什么？"></a>59、有哪些情况必须用到成员列表初始化？作用是什么？</h2><ol>
<li>必须使用成员初始化的四种情况</li>
</ol>
<p>① 当初始化一个引用成员时；</p>
<p>② 当初始化一个常量成员时；</p>
<p>③ 当调用一个基类的构造函数，而它拥有一组参数时；</p>
<p>④ 当调用一个成员类的构造函数，而它拥有一组参数时；</p>
<ol>
<li>成员初始化列表做了什么</li>
</ol>
<p>① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；</p>
<p>② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>
<h2 id="60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？"><a href="#60、C-中新增了string，它与C语言中的-char-有什么区别吗？它是如何实现的？" class="headerlink" title="60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？"></a>60、C++中新增了string，它与C语言中的 char *有什么区别吗？它是如何实现的？</h2><p>string继承自basic_string,其实是对char进行了封装，封装的string包含了char数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2*n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h2 id="61、什么是内存泄露，如何检测与避免"><a href="#61、什么是内存泄露，如何检测与避免" class="headerlink" title="61、什么是内存泄露，如何检测与避免"></a>61、什么是内存泄露，如何检测与避免</h2><p><strong>内存泄露</strong></p>
<p>一般我们常说的内存泄漏是指<strong>堆内存的泄漏</strong>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<p><strong>避免内存泄露的几种方式</strong></p>
<ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为<strong>虚函数</strong></li>
<li>对象数组的释放一定要用<strong>delete []</strong></li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<p><strong>检测工具</strong></p>
<ul>
<li>Linux下可以使用<strong>Valgrind工具</strong></li>
<li>Windows下可以使用<strong>CRT库</strong></li>
</ul>
<h2 id="62、对象复用的了解，零拷贝的了解"><a href="#62、对象复用的了解，零拷贝的了解" class="headerlink" title="62、对象复用的了解，零拷贝的了解"></a>62、对象复用的了解，零拷贝的了解</h2><p><strong>对象复用</strong></p>
<p>对象复用其本质是一种设计模式：Flyweight享元模式。</p>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<p><strong>零拷贝</strong></p>
<p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数<strong>emplace_back()<strong>很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：</strong>使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造</strong>，效率更高。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string p_name, <span class="type">int</span> p_age): <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">age</span>(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been copy constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(Person&amp;&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been moved&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt;endl;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="63、介绍面向对象的三大特性，并且举例说明"><a href="#63、介绍面向对象的三大特性，并且举例说明" class="headerlink" title="63、介绍面向对象的三大特性，并且举例说明"></a>63、介绍面向对象的三大特性，并且举例说明</h2><p>三大特性：继承、封装和多态</p>
<p><strong>（1）继承</strong></p>
<p>让某种类型对象获得另一个类型对象的属性和方法。</p>
<p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展</p>
<p>常见的继承有三种方式：</p>
<ol>
<li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li>
<li>接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力</li>
<li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）</li>
</ol>
<p>例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法</p>
<p><strong>（2）封装</strong></p>
<p>数据和代码捆绑在一起，避免外界干扰和不确定性访问。</p>
<p>封装，也就是<strong>把客观事物封装成抽象的类</strong>，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。</p>
<p><strong>（3）多态</strong></p>
<p>同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为<strong>（重载实现编译时多态，虚函数实现运行时多态）</strong>。</p>
<p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p>
<p>实现多态有二种方式：覆盖（override），重载（overload）。</p>
<p>覆盖：是指子类重新定义父类的虚函数的做法。</p>
<p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。</p>
<h2 id="64、成员初始化列表的概念，为什么用它会快一些？"><a href="#64、成员初始化列表的概念，为什么用它会快一些？" class="headerlink" title="64、成员初始化列表的概念，为什么用它会快一些？"></a>64、成员初始化列表的概念，为什么用它会快一些？</h2><p><strong>成员初始化列表的概念</strong></p>
<p>在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值</p>
<p><strong>效率</strong></p>
<p>用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int &quot;</span>&lt;&lt;value&lt;&lt;<span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        value = a.value;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数A(A&amp; a):  &quot;</span>&lt;&lt;value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() : <span class="built_in">a</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="built_in">A</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//A(int 1)</span></span><br><span class="line"><span class="comment">//默认构造函数A()</span></span><br><span class="line"><span class="comment">//A(int 2)</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但<strong>如果有些成员是类</strong>，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以<strong>如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。</strong></p>
<h2 id="65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#65、C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast"></a>65、C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</h2><p><strong>reinterpret_cast</strong></p>
<p>reinterpret_cast<type-id> (expression)</p>
<p>type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。</p>
<p><strong>const_cast</strong></p>
<p>const_cast<type_id> (expression)</p>
<p>该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：</p>
<ul>
<li>常量指针被转化成非常量的指针，并且仍然指向原来的对象</li>
<li>常量引用被转换成非常量的引用，并且仍然指向原来的对象</li>
<li>const_cast一般用于修改底指针。如const char *p形式</li>
</ul>
<p><strong>static_cast</strong></p>
<p>static_cast &lt; type-id &gt; (expression)</p>
<p>该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p>
<ul>
<li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<ul>
<li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的</li>
<li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的</li>
</ul>
</li>
<li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式转换成void类型</li>
</ul>
<p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p>
<p><strong>dynamic_cast</strong></p>
<p>有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全</p>
<p>dynamic_cast <type-id> (expression)</p>
<p>该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*</p>
<p>如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用</p>
<p>dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）</p>
<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换</p>
<p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的</p>
<p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() :<span class="built_in">b</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>() :<span class="built_in">d</span>(<span class="number">2</span>) &#123;&#125;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">97</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reinterpret_cast</span></span><br><span class="line">	<span class="type">int</span> *p = &amp;n;</span><br><span class="line">	<span class="comment">//以下两者效果相同</span></span><br><span class="line">	<span class="type">char</span> *c = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt; (p); </span><br><span class="line">	<span class="type">char</span> *c2 =  (<span class="type">char</span>*)(p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;reinterpret_cast输出：&quot;</span>&lt;&lt; *c2 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//const_cast</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> *p2 = &amp;n;</span><br><span class="line">	<span class="type">int</span> *p3 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p2);</span><br><span class="line">	*p3 = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;const_cast输出：&quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	Base* b1 = <span class="keyword">new</span> Son;</span><br><span class="line">	Base* b2 = <span class="keyword">new</span> Base;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//static_cast</span></span><br><span class="line">	Son* s1 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b1); <span class="comment">//同类型转换</span></span><br><span class="line">	Son* s2 = <span class="built_in">static_cast</span>&lt;Son*&gt;(b2); <span class="comment">//下行转换，不安全</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;static_cast输出：&quot;</span>&lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s1-&gt;d &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s2-&gt;d &lt;&lt; endl; <span class="comment">//下行转换，原先父对象没有d成员，输出垃圾值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//dynamic_cast</span></span><br><span class="line">	Son* s3 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b1); <span class="comment">//同类型转换</span></span><br><span class="line">	Son* s4 = <span class="built_in">dynamic_cast</span>&lt;Son*&gt;(b2); <span class="comment">//下行转换，安全</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;dynamic_cast输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s3-&gt;d &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">if</span>(s4 == <span class="literal">nullptr</span>)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;s4指针为nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; s4-&gt;d &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//reinterpret_cast输出：a</span></span><br><span class="line"><span class="comment">//const_cast输出：100</span></span><br><span class="line"><span class="comment">//static_cast输出：</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//-33686019</span></span><br><span class="line"><span class="comment">//dynamic_cast输出：</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//s4指针为nullptr</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。</p>
<h2 id="66、C-函数调用的压栈过程"><a href="#66、C-函数调用的压栈过程" class="headerlink" title="66、C++函数调用的压栈过程"></a>66、C++函数调用的压栈过程</h2><h2 id="66-1、以例子进行讲解"><a href="#66-1、以例子进行讲解" class="headerlink" title="66.1、以例子进行讲解"></a>66.1、以例子进行讲解</h2><p>从代码入手，解释这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> var1 = param1;</span><br><span class="line">	<span class="type">int</span> var2 = param2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));<span class="comment">//如果将printf换为cout进行输出，输出结果则刚好相反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p>
<p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<h2 id="66-2、文字化表述"><a href="#66-2、文字化表述" class="headerlink" title="66.2、文字化表述"></a>66.2、文字化表述</h2><p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址&#x2F;指针传递。</p>
<h2 id="67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#67、写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h2><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<ul>
<li>使用gdb命令对core文件进行调试</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在编辑器内键入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,i);<span class="comment">//正确的应该是&amp;i,这里使用i会导致segment fault</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">./coredumpTest</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>使用gdb调试coredump</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br><span class="line">   </span><br></pre></td></tr></table></figure>



<h2 id="68、说说移动构造函数"><a href="#68、说说移动构造函数" class="headerlink" title="68、说说移动构造函数"></a>68、说说移动构造函数</h2><p>1.我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
<p>2.拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p>
<p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p>
<p>3.移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p>
<h2 id="69、C-中将临时变量作为返回值时的处理过程"><a href="#69、C-中将临时变量作为返回值时的处理过程" class="headerlink" title="69、C++中将临时变量作为返回值时的处理过程"></a>69、C++中将临时变量作为返回值时的处理过程</h2><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了。</p>
<h2 id="70、如何获得结构成员相对于结构开头的字节偏移量"><a href="#70、如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="70、如何获得结构成员相对于结构开头的字节偏移量"></a>70、如何获得结构成员相对于结构开头的字节偏移量</h2><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> y;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	<span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在Visual Studio 2019 + Win10 下的输出情况如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>当然了，如果加上 #pragma pack(4) 指定4字节对齐方式就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">char</span> y;</span><br><span class="line">	<span class="type">int</span> z;</span><br><span class="line">	<span class="type">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, x) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, y) &lt;&lt; endl; <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, z) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">offsetof</span>(S, a) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">｝</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>S结构体中各个数据成员的内存空间划分如下所示，需要注意内存对齐</p>
<p><img src="http://oss.interviewguide.cn/img/202205220035079.png" alt="img"></p>
<h2 id="71、静态类型和动态类型，静态绑定和动态绑定的介绍"><a href="#71、静态类型和动态类型，静态绑定和动态绑定的介绍" class="headerlink" title="71、静态类型和动态类型，静态绑定和动态绑定的介绍"></a>71、静态类型和动态类型，静态绑定和动态绑定的介绍</h2><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。 举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*virtual*/</span> <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;A::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C::func()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">	B* pb = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">//pb的静态类型和动态类型也都是B*；</span></span><br><span class="line">	A* pa = pc;      <span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；</span></span><br><span class="line">	pa = pb;         <span class="comment">//pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">	C *pnull = <span class="literal">NULL</span>; <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line">    </span><br><span class="line">    pa-&gt;<span class="built_in">func</span>();      <span class="comment">//A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用A::func()；</span></span><br><span class="line">	pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此调用C::func()；</span></span><br><span class="line">	pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>如果将A类中的virtual注释去掉，则运行结果是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pa-&gt;<span class="built_in">func</span>();      <span class="comment">//B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；</span></span><br><span class="line">pc-&gt;<span class="built_in">func</span>();      <span class="comment">//C::func() pc的动、静态类型都是C*，因此也是先在C中查找；</span></span><br><span class="line">pnull-&gt;<span class="built_in">func</span>();   <span class="comment">//空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在上面的例子中，</p>
<ul>
<li>如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。</li>
<li>同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；</li>
<li>如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；</li>
</ul>
<p><strong>本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。</strong></p>
<p>至此总结一下静态绑定和动态绑定的区别：</p>
<ul>
<li>静态绑定发生在编译期，动态绑定发生在运行期；</li>
<li>对象的动态类型可以更改，但是静态类型无法更改；</li>
<li>要想实现动态，必须使用动态绑定；</li>
<li>在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；</li>
</ul>
<p><strong>建议：</strong></p>
<p>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。 看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;E::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> : <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;F::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F* pf = <span class="keyword">new</span> <span class="built_in">F</span>();</span><br><span class="line">	E* pe = pf;</span><br><span class="line">	pf-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 1  正常，就该如此；</span></span><br><span class="line">	pe-&gt;<span class="built_in">func</span>(); <span class="comment">//F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="72、引用是否能实现动态绑定，为什么可以实现？"><a href="#72、引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="72、引用是否能实现动态绑定，为什么可以实现？"></a>72、引用是否能实现动态绑定，为什么可以实现？</h2><p>可以。</p>
<p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line">	Base&amp; b = s; <span class="comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span></span><br><span class="line">	s.<span class="built_in">fun</span>(); <span class="comment">//son::fun()</span></span><br><span class="line">	b.<span class="built_in">fun</span>(); <span class="comment">//son :: fun()</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>需要说明的是虚函数才具有动态绑定</strong>，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
<h2 id="73、全局变量和局部变量有什么区别？"><a href="#73、全局变量和局部变量有什么区别？" class="headerlink" title="73、全局变量和局部变量有什么区别？"></a>73、全局变量和局部变量有什么区别？</h2><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p>
<h2 id="74、指针加减计算要注意什么？"><a href="#74、指针加减计算要注意什么？" class="headerlink" title="74、指针加减计算要注意什么？"></a>74、指针加减计算要注意什么？</h2><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *a, *b, c;</span><br><span class="line">	a = (<span class="type">int</span>*)<span class="number">0x500</span>;</span><br><span class="line">	b = (<span class="type">int</span>*)<span class="number">0x520</span>;</span><br><span class="line">	c = b - a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 8</span></span><br><span class="line">	a += <span class="number">0x020</span>;</span><br><span class="line">	c = b - a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// -24</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16^2&#x3D;1280）和1312（5</em>16^2+2*16&#x3D;1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32&#x2F;4&#x3D;8</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 &#x3D; 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 &#x3D; -96，所以c的值就变成了-96&#x2F;4 &#x3D; -24</p>
<p>遇到指针的计算，<strong>需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</strong></p>
<h2 id="75、-怎样判断两个浮点数是否相等？"><a href="#75、-怎样判断两个浮点数是否相等？" class="headerlink" title="75、 怎样判断两个浮点数是否相等？"></a>75、 怎样判断两个浮点数是否相等？</h2><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h2 id="76、方法调用的原理（栈，汇编）"><a href="#76、方法调用的原理（栈，汇编）" class="headerlink" title="76、方法调用的原理（栈，汇编）"></a>76、方法调用的原理（栈，汇编）</h2><ol>
<li>机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</li>
<li>由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</li>
<li>过程实现</li>
</ol>
<p>① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</p>
<p>② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</p>
<p>③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</p>
<p>④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</p>
<p>⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</p>
<p>⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</p>
<p>⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</p>
<p>⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。</p>
<ol start="4">
<li>过程调用和返回指令</li>
</ol>
<p>① call指令</p>
<p>② leave指令</p>
<p>③ ret指令</p>
<h2 id="77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#77、C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h2><ol>
<li>指针参数传递本质上是值传递，它所传递的是一个地址值。</li>
</ol>
<p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<ol start="2">
<li>引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</li>
</ol>
<p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p>
<p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p><strong>3)</strong> 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p>
<p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p><strong>4)</strong> 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p>
<p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p>
<p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h2 id="78、类如何实现只能静态分配和只能动态分配"><a href="#78、类如何实现只能静态分配和只能动态分配" class="headerlink" title="78、类如何实现只能静态分配和只能动态分配"></a>78、类如何实现只能静态分配和只能动态分配</h2><ol>
<li>前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</li>
<li>建立类的对象有两种方式：</li>
</ol>
<p>​	① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</p>
<p>​	② 动态建立，A *p &#x3D; new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在	堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</p>
<ol start="3">
<li>只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</li>
</ol>
<h2 id="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#79、如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="79、如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>79、如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<p>所以必须定义而非声明。</p>
<h2 id="80、-继承机制中对象之间如何转换？指针和引用之间如何转换？"><a href="#80、-继承机制中对象之间如何转换？指针和引用之间如何转换？" class="headerlink" title="80、 继承机制中对象之间如何转换？指针和引用之间如何转换？"></a>80、 继承机制中对象之间如何转换？指针和引用之间如何转换？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">向上类型转换</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">向下类型转换</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。</p>
<h2 id="81、知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#81、知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="81、知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>81、知道C++中的组合吗？它与继承相比有什么优缺点吗？</h2><p><strong>一：继承</strong></p>
<p>继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。</p>
<p>继承的缺点有以下几点：</p>
<p>①：父类的内部细节对子类是可见的。</p>
<p>②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。</p>
<p>③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。所以说子类与父类是一种高耦合，违背了面向对象思想。</p>
<p><strong>二：组合</strong></p>
<p>组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。</p>
<p>组合的优点：</p>
<p>①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。</p>
<p>②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。</p>
<p>③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。</p>
<p>组合的缺点：①：容易产生过多的对象。②：为了能组合多个对象，必须仔细对接口进行定义。</p>
<h2 id="82、函数指针？"><a href="#82、函数指针？" class="headerlink" title="82、函数指针？"></a>82、函数指针？</h2><p><strong>1) 什么是函数指针?</strong></p>
<p>函数指针指向的是特殊</p>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格。</p>
<p><strong>2) 函数指针的声明方法</strong></p>
<p>int (*pf)(const int&amp;, const int&amp;); (1)</p>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个const int&amp;参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p>
<p>int *pf(const int&amp;, const int&amp;); (2)</p>
<p>而这声明了一个函数pf，其返回类型为int *， 带有两个const int&amp;参数。</p>
<p><strong>3) 为什么有函数指针</strong></p>
<p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p>
<p><strong>4) 一个函数名就是一个指针，它指向函数的代码。</strong></p>
<p>一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
<p><strong>5) 两种方法赋值：</strong></p>
<p>指针名 &#x3D; 函数名； 指针名 &#x3D; &amp;函数名</p>
<h2 id="83、说一说你理解的内存对齐以及原因"><a href="#83、说一说你理解的内存对齐以及原因" class="headerlink" title="83、说一说你理解的内存对齐以及原因"></a>83、说一说你理解的内存对齐以及原因</h2><p>1、 分配内存的顺序是按照声明的顺序。</p>
<p>2、 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。</p>
<p>3、 最后整个结构体的大小必须是里面变量类型最大值的整数倍。</p>
<p>添加了#pragma pack(n)后规则就变成了下面这样：</p>
<p>1、 偏移量要是n和当前变量大小中较小值的整数倍</p>
<p>2、 整体大小要是n和最大变量大小中较小值的整数倍</p>
<p>3、 n值必须为1,2,4,8…，为其他值时就按照默认的分配规则</p>
<h2 id="84、-结构体变量比较是否相等"><a href="#84、-结构体变量比较是否相等" class="headerlink" title="84、 结构体变量比较是否相等"></a>84、 结构体变量比较是否相等</h2><ol>
<li>重载了 “&#x3D;&#x3D;” 操作符</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> foo&amp; rhs) *<span class="comment">//* *操作运算符重载*</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">return</span>( a == rhs.a) &amp;&amp; (b == rhs.b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ol>
<li>元素的话，一个个比；</li>
<li>指针直接比较，如果保存的是同一个实例地址，则(p1&#x3D;&#x3D;p2)为真；</li>
</ol>
<h2 id="85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#85、-函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>85、 函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h2><p>1、调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调</p>
<p> 函数所需要的参数压入栈;</p>
<p>2、调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作</p>
<p> 隐含在call指令中);</p>
<p>3、在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前</p>
<p> 被调函数的栈底地址(mov ebp,esp);</p>
<p>4、在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的</p>
<p> 顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</p>
<h2 id="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"><a href="#86、define、const、typedef、inline的使用方法？他们之间有什么区别？" class="headerlink" title="86、define、const、typedef、inline的使用方法？他们之间有什么区别？"></a>86、define、const、typedef、inline的使用方法？他们之间有什么区别？</h2><p>一、const与#define的区别：</p>
<ol>
<li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li>
<li>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</li>
<li>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</li>
<li>define预处理后，占用代码段空间，const占用数据段空间；</li>
<li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li>
<li>define独特功能，比如可以用来防止文件重复引用。</li>
</ol>
<p>二、#define和别名typedef的区别</p>
<ol>
<li>执行时间不同，typedef在编译阶段有效，typedef有类型检查的功能；#define是宏定义，发生在预处理阶段，不进行类型检查；</li>
<li>功能差异，typedef用来定义类型的别名，定义与平台无关的数据类型，与struct的结合使用等。#define不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
<li>作用域不同，#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而typedef有自己的作用域。</li>
</ol>
<p>三、 define与inline的区别</p>
<ol>
<li>#define是关键字，inline是函数；</li>
<li>宏定义在预处理阶段进行文本替换，inline函数在编译阶段进行替换；</li>
<li>inline函数有类型检查，相比宏定义比较安全；</li>
</ol>
<h2 id="87、你知道printf函数的实现原理是什么吗？"><a href="#87、你知道printf函数的实现原理是什么吗？" class="headerlink" title="87、你知道printf函数的实现原理是什么吗？"></a>87、你知道printf函数的实现原理是什么吗？</h2><p>在C&#x2F;C++中，对函数参数的扫描是从后向前的。</p>
<p>C&#x2F;C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p>
<h2 id="88、为什么模板类一般都是放在一个h文件中"><a href="#88、为什么模板类一般都是放在一个h文件中" class="headerlink" title="88、为什么模板类一般都是放在一个h文件中"></a>88、为什么模板类一般都是放在一个h文件中</h2><ol>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
</ol>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<ol start="2">
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
</ol>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p>
<h2 id="89、C-中类成员的访问权限和继承权限问题"><a href="#89、C-中类成员的访问权限和继承权限问题" class="headerlink" title="89、C++中类成员的访问权限和继承权限问题"></a>89、C++中类成员的访问权限和继承权限问题</h2><p>1.三种访问权限</p>
<p>① public:用该关键字修饰的成员表示公有成员，该成员不仅可以在类内可以被 访问，在类外也是可以被访问的，是类对外提供的可访问接口；</p>
<p>② private:用该关键字修饰的成员表示私有成员，该成员仅在类内可以被访问，在类体外是隐藏状态；</p>
<p>③ protected:用该关键字修饰的成员表示保护成员，保护成员在类体外同样是隐藏状态，但是对于该类的派生类来说，相当于公有成员，在派生类中可以被访问。</p>
<p>2.三种继承方式</p>
<p>① 若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；</p>
<p>② 若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；</p>
<p>③ 若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h2 id="90、cout和printf有什么区别？"><a href="#90、cout和printf有什么区别？" class="headerlink" title="90、cout和printf有什么区别？"></a>90、cout和printf有什么区别？</h2><p>很多人认为cout&lt;&lt;是一个函数，其实不是的，它是类std::ostream的全局对象。</p>
<p>cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。</p>
<p>输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是有缓冲输出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">&quot;abc &quot;</span> &lt; &lt;endl; </span><br><span class="line">或cout &lt; &lt; <span class="string">&quot;abc\n &quot;</span>; cout &lt; &lt;flush; 这两个才是一样的.</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>flush立即强迫缓冲输出。</p>
<p>printf是行缓冲输出，不是无缓冲输出。</p>
<h2 id="91、你知道重载运算符吗？"><a href="#91、你知道重载运算符吗？" class="headerlink" title="91、你知道重载运算符吗？"></a>91、你知道重载运算符吗？</h2><p>1、 我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</p>
<p>2、 两种重载方式：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</p>
<p>3、 引入运算符重载，是为了实现类的多态性；</p>
<p>4、 当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</p>
<p>5、 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</p>
<p>6、 下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</p>
<p>7、 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</p>
<h2 id="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#92、当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="92、当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>92、当程序中有函数重载时，函数的匹配原则和顺序是什么？</h2><ol>
<li>名字查找</li>
<li>确定候选函数</li>
<li>寻找最佳匹配</li>
</ol>
<h2 id="93、定义和声明的区别"><a href="#93、定义和声明的区别" class="headerlink" title="93、定义和声明的区别"></a>93、定义和声明的区别</h2><p><strong>如果是指变量的声明和定义：</strong> 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<p><strong>如果是指函数的声明和定义：</strong> 声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。 定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
<h2 id="94、全局变量和static变量的区别"><a href="#94、全局变量和static变量的区别" class="headerlink" title="94、全局变量和static变量的区别"></a>94、全局变量和static变量的区别</h2><p>1.全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。</p>
<p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</p>
<p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</p>
<p>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p>
<p>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p>
<p>2.static函数与普通函数有什么区别？ static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p>
<p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。 static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<h2 id="95、-静态成员与普通成员的区别是什么？"><a href="#95、-静态成员与普通成员的区别是什么？" class="headerlink" title="95、 静态成员与普通成员的区别是什么？"></a>95、 静态成员与普通成员的区别是什么？</h2><p>1.生命周期</p>
<p>静态成员变量从类被加载开始到类被卸载，一直存在；</p>
<p>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p>
<p>2.共享方式</p>
<p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p>
<p>3.定义位置</p>
<p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p>
<p>4.初始化位置</p>
<p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p>
<p>5.默认实参</p>
<p>可以使用静态成员变量作为默认实参，</p>
<h2 id="96、说一下你理解的-ifdef-endif代表着什么？"><a href="#96、说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="96、说一下你理解的 ifdef endif代表着什么？"></a>96、说一下你理解的 ifdef endif代表着什么？</h2><p>1.一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
<p>2.条件编译命令最常见的形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line">程序段<span class="number">2</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 其中#else部分也可以没有，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  </span></span><br><span class="line">程序段<span class="number">1</span>  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>3.在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</p>
<p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p>
<h2 id="97、隐式转换，如何消除隐式转换？"><a href="#97、隐式转换，如何消除隐式转换？" class="headerlink" title="97、隐式转换，如何消除隐式转换？"></a>97、隐式转换，如何消除隐式转换？</h2><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p>
<p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h2 id="98、C-如何处理多个异常的？"><a href="#98、C-如何处理多个异常的？" class="headerlink" title="98、C++如何处理多个异常的？"></a>98、C++如何处理多个异常的？</h2><ol>
<li>C++中的异常情况： 语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。 运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</li>
<li>C++异常处理机制： 异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。 C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获) 抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>  &#123;  可能抛出异常的语句；（检查） <span class="keyword">try</span> </span><br><span class="line">&#123; </span><br><span class="line">可能抛出异常的语句；（检查） </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>（类型名[形参名]）<span class="comment">//捕获特定类型的异常 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//处理1； </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>（类型名[形参名]）<span class="comment">//捕获特定类型的异常 </span></span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//处理2； </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>（…）<span class="comment">//捕获所有类型的异常 </span></span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="99、如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#99、如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="99、如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>99、如何在不使用额外空间的情况下，交换两个数？你有几种方法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)  算术</span><br><span class="line"></span><br><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line"></span><br><span class="line">x = x - y; </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)  异或</span><br><span class="line"></span><br><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>









<h2 id="100、你知道strcpy和memcpy的区别是什么吗？"><a href="#100、你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="100、你知道strcpy和memcpy的区别是什么吗？"></a>100、你知道strcpy和memcpy的区别是什么吗？</h2><p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 3、用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</p>
<h2 id="101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#101、程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>101、程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h2><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p>
<h2 id="102、volatile关键字的作用？"><a href="#102、volatile关键字的作用？" class="headerlink" title="102、volatile关键字的作用？"></a>102、volatile关键字的作用？</h2><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p>
<p>volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；</li>
</ol>
<h2 id="103、如果有一个空类，它会默认添加哪些函数？"><a href="#103、如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="103、如果有一个空类，它会默认添加哪些函数？"></a>103、如果有一个空类，它会默认添加哪些函数？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)  <span class="built_in">Empty</span>(); <span class="comment">// 缺省构造函数//</span></span><br><span class="line"><span class="number">2</span>)  <span class="built_in">Empty</span>( <span class="type">const</span> Empty&amp; ); <span class="comment">// 拷贝构造函数//</span></span><br><span class="line"><span class="number">3</span>)  ~<span class="built_in">Empty</span>(); <span class="comment">// 析构函数//</span></span><br><span class="line"><span class="number">4</span>)  Empty&amp; <span class="keyword">operator</span>=( <span class="type">const</span> Empty&amp; ); <span class="comment">// 赋值运算符//</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="104、C-中标准库是什么？"><a href="#104、C-中标准库是什么？" class="headerlink" title="104、C++中标准库是什么？"></a>104、C++中标准库是什么？</h2><p>1.C++ 标准库可以分为两部分：</p>
<p>标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。</p>
<p>面向对象类库： 这个库是类及其相关函数的集合。</p>
<p>2.输入&#x2F;输出 I&#x2F;O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数</p>
<p>3.标准的 C++ I&#x2F;O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库</p>
<h2 id="105、你知道const-char-与string之间的关系是什么吗？"><a href="#105、你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="105、你知道const char* 与string之间的关系是什么吗？"></a>105、你知道const char* 与string之间的关系是什么吗？</h2><ol>
<li>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</li>
<li>三者的转化关系如下所示：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a)  string转<span class="type">const</span> <span class="type">char</span>* </span><br><span class="line"></span><br><span class="line">string s = “abc”; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>(); </span><br><span class="line"></span><br><span class="line">b)  <span class="type">const</span> <span class="type">char</span>* 转string，直接赋值即可 </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>; </span><br><span class="line"></span><br><span class="line">c)  string 转<span class="type">char</span>* </span><br><span class="line"> string s = “abc”; </span><br><span class="line"> <span class="type">char</span>* c; </span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>(); </span><br><span class="line"> c = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>]; </span><br><span class="line"> <span class="built_in">strcpy</span>(c,s.<span class="built_in">c_str</span>()); </span><br><span class="line"></span><br><span class="line">d)  <span class="type">char</span>* 转string </span><br><span class="line"> <span class="type">char</span>* c = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c)</span></span>; </span><br><span class="line"></span><br><span class="line">e)  <span class="type">const</span> <span class="type">char</span>* 转<span class="type">char</span>* </span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* cpc = “abc”; </span><br><span class="line"> <span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line"> <span class="built_in">strcpy</span>(pc,cpc);</span><br><span class="line"></span><br><span class="line">f)  <span class="type">char</span>* 转<span class="type">const</span> <span class="type">char</span>*，直接赋值即可 </span><br><span class="line"> <span class="type">char</span>* pc = “abc”; </span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="106、你什么情况用指针当参数，什么时候用引用，为什么？"><a href="#106、你什么情况用指针当参数，什么时候用引用，为什么？" class="headerlink" title="106、你什么情况用指针当参数，什么时候用引用，为什么？"></a>106、你什么情况用指针当参数，什么时候用引用，为什么？</h2><p>1.使用引用参数的主要原因有两个：</p>
<p>程序员能修改调用函数中的数据对象</p>
<p>通过传递引用而不是整个数据–对象，可以提高程序的运行速度</p>
<p>2.一般的原则： 对于使用引用的值而不做修改的函数：</p>
<p>如果数据对象很小，如内置数据类型或者小型结构，则按照值传递；</p>
<p>如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针；</p>
<p>如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的时间和空间；</p>
<p>如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）；</p>
<p>3.对于修改函数中数据的函数：</p>
<p>如果数据是内置数据类型，则使用指针</p>
<p>如果数据对象是结构，则使用引用或者指针</p>
<p>如果数据是类对象，则使用引用</p>
<p>也有一种说法认为：“如果数据对象是数组，则只能使用指针”，这是不对的，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T (&amp;a)[N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="107、你知道静态绑定和动态绑定吗？讲讲？"><a href="#107、你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="107、你知道静态绑定和动态绑定吗？讲讲？"></a>107、你知道静态绑定和动态绑定吗？讲讲？</h2><p>1.对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
<p>2.对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
<p>3.静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。)</p>
<p>4.动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。)</p>
<h2 id="108、如何设计一个计算仅单个子类的对象个数？"><a href="#108、如何设计一个计算仅单个子类的对象个数？" class="headerlink" title="108、如何设计一个计算仅单个子类的对象个数？"></a>108、如何设计一个计算仅单个子类的对象个数？</h2><p>1、为类设计一个static静态变量count作为计数器；</p>
<p>2、类定义结束后初始化count;</p>
<p>3、在构造函数中对count进行+1;</p>
<p>4、 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</p>
<p>5、设计赋值构造函数，在进行赋值函数中对count+1操作；</p>
<p>6、在析构函数中对count进行-1；</p>
<h2 id="109、怎么快速定位错误出现的地方"><a href="#109、怎么快速定位错误出现的地方" class="headerlink" title="109、怎么快速定位错误出现的地方?"></a>109、怎么快速定位错误出现的地方?</h2><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<p>2、对于复杂的模板错误，最好使用生成输出窗口。</p>
<p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p>
<h2 id="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"><a href="#110、成员初始化列表会在什么时候用到？它的调用过程是什么？" class="headerlink" title="110、成员初始化列表会在什么时候用到？它的调用过程是什么？"></a>110、成员初始化列表会在什么时候用到？它的调用过程是什么？</h2><ol>
<li>当初始化一个引用成员变量时；</li>
<li>初始化一个const成员变量时；</li>
<li>当调用一个基类的构造函数，而构造函数拥有一组参数时；</li>
<li>当调用一个成员类的构造函数，而他拥有一组参数；</li>
<li>编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。</li>
</ol>
<h2 id="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"><a href="#111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？" class="headerlink" title="111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？"></a>111、在进行函数参数以及返回值传递时，可以使用引用或者值传递，其中使用引用的好处有哪些？</h2><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参&#x3D;实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>
<h2 id="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#112、说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="112、说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>112、说一说strcpy、sprintf与memcpy这三个函数的不同之处</h2><p>1.操作对象不同</p>
<p>① strcpy的两个操作对象均为字符串</p>
<p>② sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p>
<p>③ memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p>
<p>2.执行效率不同</p>
<p>memcpy最高，strcpy次之，sprintf的效率最低。</p>
<p>3.实现功能不同</p>
<p>① strcpy主要实现字符串变量间的拷贝</p>
<p>② sprintf主要实现其他数据类型格式到字符串的转化</p>
<p>③ memcpy主要是内存块间的拷贝。</p>
<h2 id="113、将引用作为函数参数有哪些好处？"><a href="#113、将引用作为函数参数有哪些好处？" class="headerlink" title="113、将引用作为函数参数有哪些好处？"></a>113、将引用作为函数参数有哪些好处？</h2><p>1.传递引用给函数与传递指针的效果是一样的。</p>
<p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<p>2.使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</p>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<p>3.使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</p>
<p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h2 id="114、你知道数组和指针的区别吗？"><a href="#114、你知道数组和指针的区别吗？" class="headerlink" title="114、你知道数组和指针的区别吗？"></a>114、你知道数组和指针的区别吗？</h2><ol>
<li>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型)；</li>
<li>用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</li>
<li>编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用。</li>
<li>在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</li>
<li>在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。</li>
</ol>
<h2 id="115、如何阻止一个类被实例化？有哪些方法？"><a href="#115、如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="115、如何阻止一个类被实例化？有哪些方法？"></a>115、如何阻止一个类被实例化？有哪些方法？</h2><ol>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ol>
<h2 id="116、-如何禁止程序自动生成拷贝构造函数？"><a href="#116、-如何禁止程序自动生成拷贝构造函数？" class="headerlink" title="116、 如何禁止程序自动生成拷贝构造函数？"></a>116、 如何禁止程序自动生成拷贝构造函数？</h2><ol>
<li>为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况﻿下，为了避免调用拷贝构造函数和﻿拷贝赋值函数，我们需要将他们设置成private，防止被调用。</li>
<li>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一个连接错误；</li>
<li>针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作。</li>
</ol>
<h2 id="117、你知道Debug和Release的区别是什么吗？"><a href="#117、你知道Debug和Release的区别是什么吗？" class="headerlink" title="117、你知道Debug和Release的区别是什么吗？"></a>117、你知道Debug和Release的区别是什么吗？</h2><ol>
<li>调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息；</li>
<li>发布版本，不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的。（调试信息可在单独的PDB文件中生成）。Release模式下生成一个文件.exe或.dll文件。</li>
<li>实际上，Debug 和 Release 并没有本质的界限，他们只是一组编译选项的集合，编译器只是按照预定的选项行动。事实上，我们甚至可以修改这些选项，从而得到优化过的调试版本或是带跟踪语句的发布版本。</li>
</ol>
<h2 id="118、main函数的返回值有什么值得考究之处吗？"><a href="#118、main函数的返回值有什么值得考究之处吗？" class="headerlink" title="118、main函数的返回值有什么值得考究之处吗？"></a>118、main函数的返回值有什么值得考究之处吗？</h2><p>程序运行过程入口点main函数，main（）函数返回值类型必须是int，这样返回值才能传递给程序激活者（如操作系统）表示程序正常退出。</p>
<p>main（int args, char **argv） 参数的传递。参数的处理，一般会调用getopt（）函数处理，但实践中，这仅仅是一部分，不会经常用到的技能点。</p>
<h2 id="119、模板会写吗？写一个比较大小的模板函数"><a href="#119、模板会写吗？写一个比较大小的模板函数" class="headerlink" title="119、模板会写吗？写一个比较大小的模板函数"></a>119、模板会写吗？写一个比较大小的模板函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;<span class="comment">//函数模板 </span></span><br><span class="line"></span><br><span class="line"><span class="function">type1 <span class="title">Max</span><span class="params">(type1 a,type2 b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">return</span> a &gt; b ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Max = &quot;</span>&lt;&lt;<span class="built_in">Max</span>(<span class="number">5.5</span>,<span class="string">&#x27;a&#x27;</span>)&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a &gt; b 这一步是会报错的。</p>
<p>这个时候往往需要对于 &gt; 号进行重载，这代码量瞬间上来了。</p>
<h2 id="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#120、strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="120、strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>120、strcpy函数和strncpy函数的区别？哪个函数更安全？</h2><ol>
<li>函数原型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span></span><br></pre></td></tr></table></figure>

<ol>
<li><ul>
<li>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。</li>
<li>strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</li>
</ul>
</li>
<li><ul>
<li>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’</li>
<li>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’</li>
<li>如果指定长&gt;目标长，运行时错误 ；</li>
</ul>
</li>
</ol>
<h2 id="121、static-cast比C语言中的转换强在哪里？"><a href="#121、static-cast比C语言中的转换强在哪里？" class="headerlink" title="121、static_cast比C语言中的转换强在哪里？"></a>121、static_cast比C语言中的转换强在哪里？</h2><ol>
<li>更加安全；</li>
<li>更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图</li>
</ol>
<h2 id="122、成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#122、成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="122、成员函数里memset(this,0,sizeof(*this))会发生什么"></a>122、成员函数里memset(this,0,sizeof(*this))会发生什么</h2><ol>
<li>有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，我习惯在构造函数中将它们初始化为0，但是一句句的写太麻烦，所以直接就memset(this, 0, sizeof *this);将整个对象的内存全部置为0。对于这种情形可以很好的工作，但是下面几种情形是不可以这么使用的；</li>
<li>类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常；</li>
<li>类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。</li>
</ol>
<h2 id="123、你知道回调函数吗？它的作用？"><a href="#123、你知道回调函数吗？它的作用？" class="headerlink" title="123、你知道回调函数吗？它的作用？"></a>123、你知道回调函数吗？它的作用？</h2><ol>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ol>
<h2 id="124、什么是一致性哈希？"><a href="#124、什么是一致性哈希？" class="headerlink" title="124、什么是一致性哈希？"></a>124、什么是一致性哈希？</h2><p>一致性哈希</p>
<p>一致性哈希是一种哈希算法，就是<strong>在移除或者增加一个结点时，能够尽可能小的改变已存在key的映射关系</strong></p>
<p>尽可能少的改变已有的映射关系，一般是沿着顺时针进行操作，回答之前可以先想想，真实情况如何处理</p>
<p>一致性哈希将整个哈希值空间组<strong>织成一个虚拟的圆环</strong>，假设哈希函数的值空间为0~2^32-1，整个哈希空间环如下左图所示</p>
<p><img src="http://oss.interviewguide.cn/img/202205212342491.png" alt="img"></p>
<p>一致性hash的基本思想就是使用相同的hash算法将数据和结点都映射到图中的环形哈希空间中，上右图显示了4个数据object1-object4在环上的分布图</p>
<p><strong>结点和数据映射</strong></p>
<p>假如有一批服务器，可以根据IP或者主机名作为关键字进行哈希，根据结果映射到哈希环中，3台服务器分别是nodeA-nodeC</p>
<p>现在有一批的数据object1-object4需要存在服务器上，则可以使用相同的哈希算法对数据进行哈希，其结果必然也在环上，可以沿着顺时针方向寻找，找到一个结点（服务器）则将数据存在这个结点上，这样数据和结点就产生了一对一的关联，如下图所示：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212343455.png" alt="img"></p>
<p><strong>移除结点</strong></p>
<p>如果一台服务器出现问题，如上图中的nodeB，则受影响的是其逆时针方向至下一个结点之间的数据，只需将这些数据映射到它顺时针方向的第一个结点上即可，下左图</p>
<p><img src="http://oss.interviewguide.cn/img/202205212343330.png" alt="img"></p>
<p><strong>添加结点</strong></p>
<p>如果新增一台服务器nodeD，受影响的是其逆时针方向至下一个结点之间的数据，将这些数据映射到nodeD上即可，见上右图</p>
<p><strong>虚拟结点</strong></p>
<p>假设仅有2台服务器：nodeA和nodeC，nodeA映射了1条数据，nodeC映射了3条，这样数据分布是不平衡的。引入虚拟结点，假设结点复制个数为2，则nodeA变成：nodeA1和nodeA2，nodeC变成：nodeC1和nodeC2，映射情况变成如下：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212343034.png" alt="img"></p>
<p>这样数据分布就均衡多了，平衡性有了很大的提高</p>
<h2 id="125、C-从代码到可执行程序经历了什么？"><a href="#125、C-从代码到可执行程序经历了什么？" class="headerlink" title="125、C++从代码到可执行程序经历了什么？"></a>125、C++从代码到可执行程序经历了什么？</h2><h3 id="（1）预编译"><a href="#（1）预编译" class="headerlink" title="（1）预编译"></a>（1）预编译</h3><p>主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：</p>
<ol>
<li>删除所有的#define，展开所有的宏定义。</li>
<li>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</li>
<li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</li>
<li>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</li>
<li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</li>
<li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</li>
</ol>
<h3 id="（2）编译"><a href="#（2）编译" class="headerlink" title="（2）编译"></a>（2）编译</h3><p>把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应 的汇编代码文件。</p>
<ol>
<li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。</li>
<li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。</li>
<li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。</li>
<li>优化：源代码级别的一个优化过程。</li>
<li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。</li>
<li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。</li>
</ol>
<h3 id="（3）汇编"><a href="#（3）汇编" class="headerlink" title="（3）汇编"></a>（3）汇编</h3><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没 有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过 来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux 下)、xxx.obj(Window下)。</p>
<h3 id="（4）链接"><a href="#（4）链接" class="headerlink" title="（4）链接"></a>（4）链接</h3><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链 接：</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="#静态链接"></a>#静态链接</h3><p>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。</p>
<p>空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；</p>
<p>更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h2 id="126、为什么友元函数必须在类内部声明？"><a href="#126、为什么友元函数必须在类内部声明？" class="headerlink" title="126、为什么友元函数必须在类内部声明？"></a>126、为什么友元函数必须在类内部声明？</h2><p>因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。</p>
<p>有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分。</p>
<p><strong>勘误</strong></p>
<p>本题问题表达有误，实际上：</p>
<p>友元函数不一定要在类内声明，普通的友元函数可以在类外声明，也可以在类内声明。</p>
<p>只有友元工厂才必须用到类内声明友元函数。</p>
<h2 id="127、友元函数和友元类的基本情况"><a href="#127、友元函数和友元类的基本情况" class="headerlink" title="127、友元函数和友元类的基本情况"></a>127、友元函数和友元类的基本情况</h2><p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line"></span><br><span class="line">   c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>使用友元类时注意：</p>
<p>(1) 友元关系不能被继承。</p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h2 id="128、用C语言实现C-的继承"><a href="#128、用C语言实现C-的继承" class="headerlink" title="128、用C语言实现C++的继承"></a>128、用C语言实现C++的继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中的继承与多态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//C++中的多态:通过虚函数实现</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A:fun()&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A     <span class="comment">//C++中的继承:B类公有继承A类</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>  <span class="comment">//C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;B:fun()&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言模拟C++的继承与多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FUN)</span><span class="params">()</span></span>;   <span class="comment">//定义一个函数指针来实现对成员函数的继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_A</span>    <span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  FUN _fun;  <span class="comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span></span><br><span class="line">  <span class="type">int</span> _a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_B</span>     <span class="comment">//子类</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  _A _a_;   <span class="comment">//在子类中定义一个基类的对象即可实现对父类的继承</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fA()    <span class="comment">//父类的同名函数</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;_A:_fun()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fB()    <span class="comment">//子类的同名函数</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;_B:_fun()\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//测试C++中的继承与多态</span></span><br><span class="line"></span><br><span class="line">  A a;  <span class="comment">//定义一个父类对象a</span></span><br><span class="line"></span><br><span class="line">  B b;  <span class="comment">//定义一个子类对象b</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  A* p1 = &amp;a;  <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line"></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">//调用父类的同名函数</span></span><br><span class="line"></span><br><span class="line">  p1 = &amp;b;   <span class="comment">//让父类指针指向子类的对象</span></span><br><span class="line"></span><br><span class="line">  p1-&gt;<span class="built_in">fun</span>();  <span class="comment">//调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">//C语言模拟继承与多态的测试</span></span><br><span class="line"></span><br><span class="line">  _A _a;  <span class="comment">//定义一个父类对象_a</span></span><br><span class="line"></span><br><span class="line">  _B _b;  <span class="comment">//定义一个子类对象_b</span></span><br><span class="line"></span><br><span class="line">  _a._fun = _fA;    <span class="comment">//父类的对象调用父类的同名函数</span></span><br><span class="line"></span><br><span class="line">  _b._a_._fun = _fB;  <span class="comment">//子类的对象调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _A* p2 = &amp;_a;  <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line"></span><br><span class="line">  p2-&gt;_fun();   <span class="comment">//调用父类的同名函数</span></span><br><span class="line"></span><br><span class="line">  p2 = (_A*)&amp;_b; <span class="comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span></span><br><span class="line"></span><br><span class="line">  p2-&gt;_fun();   <span class="comment">//调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="129、动态编译与静态编译"><a href="#129、动态编译与静态编译" class="headerlink" title="129、动态编译与静态编译"></a>129、动态编译与静态编译</h2><ol>
<li>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</li>
<li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</li>
</ol>
<h2 id="130、hello-c-程序的编译过程"><a href="#130、hello-c-程序的编译过程" class="headerlink" title="130、hello.c 程序的编译过程"></a>130、hello.c 程序的编译过程</h2><p>以下是一个 hello.c 程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这个过程大致如下：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212343505.png" alt="img"></p>
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h3 id="静态链接-1"><a href="#静态链接-1" class="headerlink" title="静态链接"></a>静态链接</h3><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205212343130.png" alt="img"></p>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h3 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h3><p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205212343182.png" alt="img"></p>
<p><strong>源代码－－&gt;预处理－－&gt;编译－－&gt;优化－－&gt;汇编－－&gt;链接–&gt;可执行文件</strong></p>
<p>1.预处理</p>
<p>读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。 预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件。.i预处理后的c文件，.ii预处理后的C++文件。</p>
<p>2.编译阶段</p>
<p>编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。.s文件</p>
<p>3.汇编过程</p>
<p>汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。.o目标文件</p>
<p>4.链接阶段</p>
<p>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体。</p>
<h2 id="131、介绍一下几种典型的锁"><a href="#131、介绍一下几种典型的锁" class="headerlink" title="131、介绍一下几种典型的锁"></a>131、介绍一下几种典型的锁</h2><p><strong>读写锁</strong></p>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<p><strong>互斥锁</strong></p>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
<p><strong>条件变量</strong></p>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<p><strong>自旋锁</strong></p>
<p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<h2 id="132、delete和delete-区别？"><a href="#132、delete和delete-区别？" class="headerlink" title="132、delete和delete[]区别？"></a>132、delete和delete[]区别？</h2><ul>
<li>delete只会调用一次析构函数。</li>
<li>delete[]会调用数组中每个元素的析构函数。</li>
</ul>
<h2 id="133、为什么不能把所有的函数写成内联函数"><a href="#133、为什么不能把所有的函数写成内联函数" class="headerlink" title="133、为什么不能把所有的函数写成内联函数?"></a>133、为什么不能把所有的函数写成内联函数?</h2><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h2 id="134、为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#134、为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="134、为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>134、为什么C++没有垃圾回收机制？这点跟Java不太一样。</h2><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-操作系统</title>
    <url>/2023/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1、进程、线程和协程的区别和联系"><a href="#1、进程、线程和协程的区别和联系" class="headerlink" title="1、进程、线程和协程的区别和联系"></a>1、进程、线程和协程的区别和联系</h2><table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>资源分配和拥有的基本单位</td>
<td>程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td>切换情况</td>
<td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td>保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr>
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr>
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr>
<td>拥有资源</td>
<td>CPU资源、内存资源、文件资源和句柄等</td>
<td>程序计数器、寄存器、栈和状态字</td>
<td>拥有自己的寄存器上下文和栈</td>
</tr>
<tr>
<td>并发性</td>
<td>不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td>系统开销</td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td>通信方面</td>
<td>进程间通信需要借助操作系统</td>
<td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody></table>
<p>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序</p>
<p>2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位</p>
<h2 id="2、线程与进程的比较"><a href="#2、线程与进程的比较" class="headerlink" title="2、线程与进程的比较"></a>2、线程与进程的比较</h2><p>1、线程启动速度快，轻量级</p>
<p>2、线程的系统开销小</p>
<p>3、线程使用有一定难度，需要处理数据一致性问题</p>
<p>4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈</p>
<h2 id="2-2、补充另一种问法"><a href="#2-2、补充另一种问法" class="headerlink" title="2.2、补充另一种问法"></a>2.2、补充另一种问法</h2><p><strong>线程和进程的区别？</strong></p>
<ul>
<li>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</li>
<li>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</li>
<li>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</li>
<li>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</li>
</ul>
<h2 id="3、一个进程可以创建多少线程，和什么有关？"><a href="#3、一个进程可以创建多少线程，和什么有关？" class="headerlink" title="3、一个进程可以创建多少线程，和什么有关？"></a>3、一个进程可以创建多少线程，和什么有关？</h2><p>这个要分不同系统去看：</p>
<ul>
<li>如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li>
<li>如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</li>
</ul>
<p>顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁。</p>
<h2 id="4、外中断和异常有什么区别？"><a href="#4、外中断和异常有什么区别？" class="headerlink" title="4、外中断和异常有什么区别？"></a>4、外中断和异常有什么区别？</h2><p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h2 id="5、进程线程模型你知道多少？"><a href="#5、进程线程模型你知道多少？" class="headerlink" title="5、进程线程模型你知道多少？"></a>5、进程线程模型你知道多少？</h2><p>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i &#x3D; 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。</p>
<p>我们必须知道，做一次简单的i &#x3D; i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。</p>
<p>但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。</p>
<p>比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。</p>
<p>对于线程，我认为弄清以下两点非常重要：</p>
<ul>
<li>线程之间有无先后访问顺序（线程依赖关系）</li>
<li>多个线程共享访问同一变量（同步互斥问题）</li>
</ul>
<p>另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。</p>
<p>而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。</p>
<p>线程相关接口不少，主要需要了解各个参数意义和返回值意义。</p>
<ol>
<li><p>线程创建和结束</p>
<ul>
<li><p>背景知识：</p>
<p>在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。</p>
</li>
<li><p>相关接口：</p>
<ul>
<li><p>创建线程：int pthread_create(pthread_t *tidp,const pthread_attr_t <em>attr, void (start_rtn)(void</em>),void *arg);</p>
<p>创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。</p>
<ul>
<li>pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t &#x3D;&#x3D; unsigned long int。</li>
<li>attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。</li>
<li>start_routine：线程执行函数的首地址，传入函数指针。</li>
<li>arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。</li>
</ul>
</li>
<li><p>获得线程ID：pthread_t pthread_self();</p>
<p>调用时，会打印线程ID。</p>
</li>
<li><p>等待线程结束：int pthread_join(pthread_t tid, void** retval);</p>
<p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p>
<ul>
<li>tid：创建线程时通过指针得到tid值。</li>
<li>retval：指向返回值的指针。</li>
</ul>
</li>
<li><p>结束线程：pthread_exit(void *retval);</p>
<p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p>
<ul>
<li>retval：同上。</li>
</ul>
</li>
<li><p>分离线程：int pthread_detach(pthread_t tid);</p>
<p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程属性值修改</p>
<ul>
<li><p>背景知识：</p>
<p>线程属性对象类型为pthread_attr_t，结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> detachstate;    <span class="comment">// 线程分离的状态</span></span><br><span class="line">    <span class="type">int</span> schedpolicy;    <span class="comment">// 线程调度策略</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">schedparam</span>;</span>    <span class="comment">// 线程的调度参数</span></span><br><span class="line">    <span class="type">int</span> inheritsched;    <span class="comment">// 线程的继承性</span></span><br><span class="line">    <span class="type">int</span> scope;    <span class="comment">// 线程的作用域</span></span><br><span class="line">    <span class="comment">// 以下为线程栈的设置</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;    <span class="comment">// 线程栈末尾警戒缓冲大小</span></span><br><span class="line">    <span class="type">int</span> stackaddr_set;    <span class="comment">// 线程的栈设置</span></span><br><span class="line">    <span class="type">void</span> *    stackaddr;    <span class="comment">// 线程栈的位置</span></span><br><span class="line">    <span class="type">size_t</span> stacksize;    <span class="comment">// 线程栈大小</span></span><br><span class="line">&#125;<span class="type">pthread_attr_t</span>;</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><p>相关接口：</p>
<p>对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。这里不一一罗列。</p>
</li>
</ul>
<h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>每一个进程是资源分配的基本单位。</p>
<p>进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。</p>
<p>实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。</p>
<p>父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。</p>
<p>如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。</p>
<p>我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。</p>
<ol>
<li><p>进程创建与结束</p>
<ul>
<li><p>背景知识：</p>
<p>进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&gt; 1号内核进程 -&gt; 1号用户进程(init进程) -&gt; getty进程 -&gt; shell进程 -&gt; 命令行执行进程。所以我们在命令行中通过 .&#x2F;program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。</p>
</li>
<li><p>相关接口：</p>
<ul>
<li><p>创建进程：pid_t fork(void);</p>
<p>返回值：出错返回-1；父进程中返回pid &gt; 0；子进程中pid &#x3D;&#x3D; 0</p>
</li>
<li><p>结束进程：void exit(int status);</p>
<ul>
<li>status是退出状态，保存在全局变量中S?，通常0表示正常退出。</li>
</ul>
</li>
<li><p>获得PID：pid_t getpid(void);</p>
<p>返回调用者pid。</p>
</li>
<li><p>获得父进程PID：pid_t getppid(void);</p>
<p>返回父进程pid。</p>
</li>
</ul>
</li>
<li><p>其他补充：</p>
<ul>
<li><p>正常退出方式：exit()、_exit()、return（在main中）。</p>
<p>exit()和exit()区别：exit()是对__exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。</p>
<p>return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。</p>
</li>
<li><p>异常退出方式：abort()、终止信号。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux进程控制</p>
</li>
</ol>
<ul>
<li><p>进程地址空间（地址空间）</p>
<p>虚拟存储器为每个进程提供了独占系统地址空间的假象。</p>
<p>尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。</p>
<p>有一些”敏感”的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。</p>
<p>也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。</p>
</li>
<li><p>进程控制块（处理机）</p>
<p>进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。</p>
</li>
<li><p>上下文切换</p>
<p>内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。</p>
<p>进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。</p>
<p>一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。</p>
</li>
</ul>
<h2 id="6、进程调度算法你了解多少？"><a href="#6、进程调度算法你了解多少？" class="headerlink" title="6、进程调度算法你了解多少？"></a>6、进程调度算法你了解多少？</h2><h3 id="1、-先来先服务-first-come-first-serverd（FCFS）"><a href="#1、-先来先服务-first-come-first-serverd（FCFS）" class="headerlink" title="1、 先来先服务 first-come first-serverd（FCFS）"></a>1、 先来先服务 first-come first-serverd（FCFS）</h3><p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<h3 id="2、-短作业优先-shortest-job-first（SJF）"><a href="#2、-短作业优先-shortest-job-first（SJF）" class="headerlink" title="2、 短作业优先 shortest job first（SJF）"></a>2、 短作业优先 shortest job first（SJF）</h3><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<h3 id="3、最短剩余时间优先-shortest-remaining-time-next（SRTN）"><a href="#3、最短剩余时间优先-shortest-remaining-time-next（SRTN）" class="headerlink" title="3、最短剩余时间优先 shortest remaining time next（SRTN）"></a>3、最短剩余时间优先 shortest remaining time next（SRTN）</h3><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>
<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h3 id="4、时间片轮转"><a href="#4、时间片轮转" class="headerlink" title="4、时间片轮转"></a>4、时间片轮转</h3><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p>
<p>当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205220000782.png" alt="img"></p>
<h3 id="5、优先级调度"><a href="#5、优先级调度" class="headerlink" title="5、优先级调度"></a>5、<strong>优先级调度</strong></h3><p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h3 id="6、多级反馈队列"><a href="#6、多级反馈队列" class="headerlink" title="6、多级反馈队列"></a>6、多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p>这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220000527.png" alt="img"></p>
<h2 id="7、Linux下进程间通信方式？"><a href="#7、Linux下进程间通信方式？" class="headerlink" title="7、Linux下进程间通信方式？"></a>7、Linux下进程间通信方式？</h2><ul>
<li>管道：<ul>
<li>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</li>
</ul>
</li>
<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</li>
<li>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li>
<li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li>
</ul>
<h2 id="8、Linux下同步机制？"><a href="#8、Linux下同步机制？" class="headerlink" title="8、Linux下同步机制？"></a>8、Linux下同步机制？</h2><ul>
<li>POSIX信号量：可用于进程同步，也可用于线程同步。</li>
<li>POSIX互斥锁 + 条件变量：只能用于线程同步。</li>
</ul>
<h2 id="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#9、如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="9、如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>9、如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><blockquote>
<p>①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</p>
<p>③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</p>
</blockquote>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p>
<p>例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少? (1+100) * 0.9 + (1+100+100) * 0.1 &#x3D; 111 us 有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100) *0.1&#x3D;110.9 us 若未采用快表机制，则访问一个逻辑地址需要100+100 &#x3D; 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p>
<h2 id="10、内存交换和覆盖有什么区别？"><a href="#10、内存交换和覆盖有什么区别？" class="headerlink" title="10、内存交换和覆盖有什么区别？"></a>10、内存交换和覆盖有什么区别？</h2><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。</p>
<h2 id="11、动态分区分配算法有哪几种？可以分别说说吗？"><a href="#11、动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="11、动态分区分配算法有哪几种？可以分别说说吗？"></a>11、动态分区分配算法有哪几种？可以分别说说吗？</h2><h3 id="1、首次适应算法"><a href="#1、首次适应算法" class="headerlink" title="1、首次适应算法"></a>1、首次适应算法</h3><p>算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。</p>
<p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220001798.png" alt="img"></p>
<h3 id="2、最佳适应算法"><a href="#2、最佳适应算法" class="headerlink" title="2、最佳适应算法"></a>2、最佳适应算法</h3><p>算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。</p>
<p>如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="http://oss.interviewguide.cn/img/202205220001901.png" alt="img"></p>
<h3 id="3、最坏适应算法"><a href="#3、最坏适应算法" class="headerlink" title="3、最坏适应算法"></a>3、最坏适应算法</h3><p>又称最大适应算法(Largest Fit)</p>
<p>算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p>
<p>如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 <img src="http://oss.interviewguide.cn/img/202205220001434.png" alt="img"></p>
<h3 id="4、邻近适应算法"><a href="#4、邻近适应算法" class="headerlink" title="4、邻近适应算法"></a>4、邻近适应算法</h3><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>
<p>如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 <img src="http://oss.interviewguide.cn/img/202205220001500.png" alt="img"></p>
<h5 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h5><p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>
<p>最佳导致大量碎片，最坏导致没有大的空间。</p>
<p>进过实验，首次适应比最佳适应要好，他们都比最坏好。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td>空闲分区以地址递增次序排列</td>
<td>综合看性能最好。<strong>算法开销小</strong>，回收分区后一.般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;<strong>算法开销大</strong>，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程;<strong>算法开销大</strong>(原因同上)</td>
</tr>
<tr>
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)</td>
<td>不用每次都从低地址的小分区开始检索。<strong>算法开销小</strong>(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody></table>
<h2 id="12、虚拟技术你了解吗？"><a href="#12、虚拟技术你了解吗？" class="headerlink" title="12、虚拟技术你了解吗？"></a>12、虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p>
<p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
<p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h2 id="13、进程状态的切换你知道多少？"><a href="#13、进程状态的切换你知道多少？" class="headerlink" title="13、进程状态的切换你知道多少？"></a>13、进程状态的切换你知道多少？</h2><p><img src="http://oss.interviewguide.cn/img/202205220001439.png" alt="img"></p>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<blockquote>
<p>感谢微信好友“Beautiful”指出配图文字笔误，已改正，感谢！-2021.05.31</p>
</blockquote>
<h2 id="14、一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"><a href="#14、一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？" class="headerlink" title="14、一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"></a>14、一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h2><p>四个过程：</p>
<p><strong>（1）预编译</strong> 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<p>1、删除所有的#define，展开所有的宏定义。</p>
<p>2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
<p>3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p>
<p>4、删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</p>
<p>5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p>
<p>6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p>
<p><strong>（2）编译</strong> 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<p>1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
<p>2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
<p>3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
<p>4、优化：源代码级别的一个优化过程。</p>
<p>5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
<p>6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
<p><strong>（3）汇编</strong></p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p>
<p><strong>（4）链接</strong></p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<p><strong>1、静态链接：</strong> 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<p>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</p>
<p><strong>2、动态链接：</strong> 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
<p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
<p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
<h2 id="15、通过例子讲解逻辑地址转换为物理地址的基本过程"><a href="#15、通过例子讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="15、通过例子讲解逻辑地址转换为物理地址的基本过程"></a>15、通过例子讲解逻辑地址转换为物理地址的基本过程</h2><p>可以借助进程的页表将逻辑地址转换为物理地址。</p>
<p>通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<p>注意:页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下:</p>
<p><img src="http://oss.interviewguide.cn/img/202205220001941.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205220001638.png" alt="img"> 例:若页面大小L为1K字节，页号2对应的内存块号b&#x3D;8，将逻辑地址A&#x3D;2500转换为物理地址E。 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B &#x3D; 1KB)，页号2对应的内存块号 b&#x3D;8，将逻辑地址A&#x3D;2500转换为物理地址E。</p>
<blockquote>
<p>①计算页号、页内偏移量 页号P&#x3D;A&#x2F;L &#x3D; 2500&#x2F;1024 &#x3D; 2; 页内偏移量W&#x3D; A%L &#x3D; 2500%1024 &#x3D; 452</p>
<p>②根据题中条件可知，页号2没有越界，其存放的内存块号b&#x3D;8</p>
<p>③物理地址E&#x3D;b*L+W&#x3D;8 * 1024+ 425 &#x3D; 8644</p>
<p>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</blockquote>
<h2 id="16、进程同步的四种方法？"><a href="#16、进程同步的四种方法？" class="headerlink" title="16、进程同步的四种方法？"></a>16、进程同步的四种方法？</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>使用信号量实现生产者-消费者问题</strong></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。</p>
<p>其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p><strong>注意</strong>，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。</p>
<p>消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="type">int</span> item = produce_item();</span><br><span class="line">        down(&amp;empty);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;full);</span><br><span class="line">        down(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> item = remove_item();</span><br><span class="line">        consume_item(item);</span><br><span class="line">        up(&amp;mutex);</span><br><span class="line">        up(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>
<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生产者-消费者问题</strong></p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管程</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者客户端</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="17、操作系统在对内存进行管理的时候需要做些什么"><a href="#17、操作系统在对内存进行管理的时候需要做些什么" class="headerlink" title="17、操作系统在对内存进行管理的时候需要做些什么?"></a>17、操作系统在对内存进行管理的时候需要做些什么?</h2><ul>
<li>操作系统负责内存空间的分配与回收。</li>
<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充。</li>
<li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。</li>
<li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li>
</ul>
<h2 id="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"><a href="#18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）" class="headerlink" title="18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）"></a>18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）</h2><p><strong>进程通信方法</strong></p>
<p><img src="http://oss.interviewguide.cn/img/202205220001927.png" alt="img"></p>
<table>
<thead>
<tr>
<th>名称及方式</th>
</tr>
</thead>
<tbody><tr>
<td>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</td>
</tr>
<tr>
<td>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</td>
</tr>
<tr>
<td>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</td>
</tr>
<tr>
<td>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</td>
</tr>
<tr>
<td>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</td>
</tr>
<tr>
<td>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身</td>
</tr>
<tr>
<td>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</td>
</tr>
<tr>
<td>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</td>
</tr>
</tbody></table>
<p><strong>线程通信方法</strong></p>
<p><img src="http://oss.interviewguide.cn/img/202205220001656.png" alt="img"></p>
<table>
<thead>
<tr>
<th>名称及含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Linux：</strong></td>
</tr>
<tr>
<td>信号：类似进程间的信号处理</td>
</tr>
<tr>
<td>锁机制：互斥锁、读写锁和自旋锁</td>
</tr>
<tr>
<td>条件变量：使用通知的方式解锁，与互斥锁配合使用</td>
</tr>
<tr>
<td>信号量：包括无名线程信号量和命名线程信号量</td>
</tr>
<tr>
<td><strong>Windows：</strong></td>
</tr>
<tr>
<td>全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化</td>
</tr>
<tr>
<td>Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。</td>
</tr>
<tr>
<td>CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。</td>
</tr>
</tbody></table>
<h2 id="19、进程间通信有哪几种方式？把你知道的都说出来"><a href="#19、进程间通信有哪几种方式？把你知道的都说出来" class="headerlink" title="19、进程间通信有哪几种方式？把你知道的都说出来"></a>19、进程间通信有哪几种方式？把你知道的都说出来</h2><p>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li>无名管道<ul>
<li>无名管道特点：<ul>
<li>无名管道是一种特殊的文件，这种文件只存在于内存中。</li>
<li>无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。</li>
<li>无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。</li>
</ul>
</li>
<li>相关接口：<ul>
<li>int pipe(int fd[2]);<ul>
<li>fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>有名管道：<ul>
<li>有名管道特点：<ul>
<li>有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。</li>
<li>有名管道可以在不具有亲缘关系的进程间进行通信。</li>
</ul>
</li>
<li>相关接口：<ul>
<li>int mkfifo(const char *pathname, mode_t mode);<ul>
<li>pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。</li>
<li>mode：和open()中的参数相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。</p>
<ul>
<li><p>相关接口</p>
<ul>
<li><p>创建共享内存：int shmget(key_t key, int size, int flag);</p>
<p>成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。</p>
<ul>
<li>key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。</li>
<li>size：共享内存容量。</li>
<li>flag：权限标志位，和open的mode参数一样。</li>
</ul>
</li>
<li><p>连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);</p>
<p>返回值即共享内存实际地址。</p>
<ul>
<li>shmid：shmget()返回的标识。</li>
<li>addr：决定以什么方式连接地址。</li>
<li>flag：访问模式。</li>
</ul>
</li>
<li><p>从共享内存分离：int shmdt(const void *shmaddr);</p>
<p>调用成功返回0，失败返回-1。</p>
<ul>
<li>shmaddr：是shmat()返回的地址指针。</li>
</ul>
</li>
</ul>
</li>
<li><p>其他补充</p>
<p>共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。</p>
<p>但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。</p>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。</p>
<ul>
<li><p>相关接口</p>
<ul>
<li><p>创建信号量：int semget(key_t key, int nsems, int semflag);</p>
<p>创建成功返回信号量标识符，失败返回-1。</p>
<ul>
<li>key：进程pid。</li>
<li>nsems：创建信号量的个数。</li>
<li>semflag：指定信号量读写权限。</li>
</ul>
</li>
<li><p>改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);</p>
<p>我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。</p>
<p>struct sembuf结构体定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct sembuf&#123;</span><br><span class="line">    short sem_num;</span><br><span class="line">    short sem_op;</span><br><span class="line">    short sem_flg;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>成功返回信号量标识符，失败返回-1。</p>
<ul>
<li>semid：信号量集标识符，由semget()函数返回。</li>
<li>sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。</li>
<li>nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。</li>
</ul>
</li>
<li><p>直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);</p>
<ul>
<li>semid：信号量集标识符。</li>
<li>semnum：信号量集数组上的下标，表示某一个信号量。</li>
<li>arg：union semun类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h3><p>ipcs命令用于报告共享内存、信号量和消息队列信息。</p>
<ul>
<li>ipcs -a：列出共享内存、信号量和消息队列信息。</li>
<li>ipcs -l：列出系统限额。</li>
<li>ipcs -u：列出当前使用情况。</li>
</ul>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h2 id="20、虚拟内存的目的是什么？"><a href="#20、虚拟内存的目的是什么？" class="headerlink" title="20、虚拟内存的目的是什么？"></a>20、虚拟内存的目的是什么？</h2><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<img src="http://oss.interviewguide.cn/img/202205220001833.png" alt="img" style="zoom:80%;" />



<h2 id="21、说一下你理解中的内存？他有什么作用呢？"><a href="#21、说一下你理解中的内存？他有什么作用呢？" class="headerlink" title="21、说一下你理解中的内存？他有什么作用呢？"></a>21、说一下你理解中的内存？他有什么作用呢？</h2><p><img src="http://oss.interviewguide.cn/img/202205212343183.png" alt="img"></p>
<h2 id="22、操作系统经典问题之哲学家进餐问题"><a href="#22、操作系统经典问题之哲学家进餐问题" class="headerlink" title="22、操作系统经典问题之哲学家进餐问题"></a>22、操作系统经典问题之哲学家进餐问题</h2><p><img src="http://oss.interviewguide.cn/img/202205212343455.png" alt="img"></p>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think();</span><br><span class="line">        take(i);       <span class="comment">// 拿起左边的筷子</span></span><br><span class="line">        take((i+<span class="number">1</span>)%N); <span class="comment">// 拿起右边的筷子</span></span><br><span class="line">        eat();</span><br><span class="line">        put(i);</span><br><span class="line">        put((i+<span class="number">1</span>)%N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        think(i);</span><br><span class="line">        take_two(i);</span><br><span class="line">        eat(i);</span><br><span class="line">        put_two(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_two</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    check(i);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    down(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">put_two</span><span class="params">(i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    check(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    check(RIGHT);</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eat</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(i)</span> &#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="23、操作系统经典问题之读者-写者问题"><a href="#23、操作系统经典问题之读者-写者问题" class="headerlink" title="23、操作系统经典问题之读者-写者问题"></a>23、操作系统经典问题之读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);<span class="comment">//最后一个读者要对数据进行解锁，防止写进程无法访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>







<h2 id="24、介绍一下几种典型的锁？"><a href="#24、介绍一下几种典型的锁？" class="headerlink" title="24、介绍一下几种典型的锁？"></a>24、介绍一下几种典型的锁？</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<h2 id="24-1、你知道哪几种线程锁（POSIX）？"><a href="#24-1、你知道哪几种线程锁（POSIX）？" class="headerlink" title="24.1、你知道哪几种线程锁（POSIX）？"></a>24.1、你知道哪几种线程锁（POSIX）？</h2><h3 id="互斥锁（mutex）"><a href="#互斥锁（mutex）" class="headerlink" title="互斥锁（mutex）"></a>互斥锁（mutex）</h3><p>互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。</p>
<h3 id="条件变量-cond"><a href="#条件变量-cond" class="headerlink" title="条件变量(cond)"></a>条件变量(cond)</h3><h3 id="自旋锁-spin"><a href="#自旋锁-spin" class="headerlink" title="自旋锁(spin)"></a>自旋锁(spin)</h3><p>自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。</p>
<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>
<ul>
<li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li>
<li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li>
<li>自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。</li>
</ul>
<h2 id="25、逻辑地址VS物理地址"><a href="#25、逻辑地址VS物理地址" class="headerlink" title="25、逻辑地址VS物理地址"></a>25、逻辑地址VS物理地址</h2><p>Eg:编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。</p>
<h2 id="26、怎么回收线程？有哪几种方法？"><a href="#26、怎么回收线程？有哪几种方法？" class="headerlink" title="26、怎么回收线程？有哪几种方法？"></a>26、怎么回收线程？有哪几种方法？</h2><ul>
<li><p><strong>等待线程结束：</strong> int pthread_join(pthread_t tid, void** retval);</p>
<p>主线程调用，等待子线程退出并回收其资源，类似于进程中wait&#x2F;waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。</p>
<ul>
<li>tid：创建线程时通过指针得到tid值。</li>
<li>retval：指向返回值的指针。</li>
</ul>
</li>
<li><p><strong>结束线程：</strong> void pthread_exit(void *retval);</p>
<p>子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。</p>
<ul>
<li>retval：同上。</li>
</ul>
</li>
<li><p><strong>分离线程：</strong> int pthread_detach(pthread_t tid);</p>
<p>主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。</p>
<ul>
<li>tid：同上。</li>
</ul>
</li>
</ul>
<h2 id="27、内存的覆盖是什么？有什么特点？"><a href="#27、内存的覆盖是什么？有什么特点？" class="headerlink" title="27、内存的覆盖是什么？有什么特点？"></a>27、内存的覆盖是什么？有什么特点？</h2><p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。</p>
<h2 id="28、内存交换是什么？有什么特点？"><a href="#28、内存交换是什么？有什么特点？" class="headerlink" title="28、内存交换是什么？有什么特点？"></a>28、内存交换是什么？有什么特点？</h2><p><strong>交换(对换)技术的设计思想</strong>：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p>
<p>换入：把准备好竞争CPU运行的程序从辅存移到内存。 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。</p>
<h2 id="29、什么时候会进行内存的交换？"><a href="#29、什么时候会进行内存的交换？" class="headerlink" title="29、什么时候会进行内存的交换？"></a>29、什么时候会进行内存的交换？</h2><p>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。</p>
<h2 id="30、终端退出，终端运行的进程会怎样"><a href="#30、终端退出，终端运行的进程会怎样" class="headerlink" title="30、终端退出，终端运行的进程会怎样"></a>30、终端退出，终端运行的进程会怎样</h2><p>终端在退出时会发送SIGHUP给对应的bash进程，bash进程收到这个信号后首先将它发给session下面的进程，如果程序没有对SIGHUP信号做特殊处理，那么进程就会随着终端关闭而退出</p>
<h2 id="31、如何让进程后台运行"><a href="#31、如何让进程后台运行" class="headerlink" title="31、如何让进程后台运行"></a>31、如何让进程后台运行</h2><p>（1）命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p>
<p>（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p>
<p>（3）nohup + &amp;，将标准输出和标准错误缺省会被重定向到 nohup.out 文件中，忽略所有挂断（SIGHUP）信号</p>
<p>（4）运行指令前面 + setsid，使其父进程编程init进程，不受HUP信号的影响</p>
<p>（5）将 命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p>
<h2 id="32、什么是快表，你知道多少关于快表的知识？"><a href="#32、什么是快表，你知道多少关于快表的知识？" class="headerlink" title="32、什么是快表，你知道多少关于快表的知识？"></a>32、什么是快表，你知道多少关于快表的知识？</h2><p>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212343703.png" alt="img"></p>
<h2 id="33、地址变换中，有快表和没快表，有什么区别？"><a href="#33、地址变换中，有快表和没快表，有什么区别？" class="headerlink" title="33、地址变换中，有快表和没快表，有什么区别？"></a>33、地址变换中，有快表和没快表，有什么区别？</h2><table>
<thead>
<tr>
<th></th>
<th>地址变换过程</th>
<th>访问一个逻辑地址的访存次数</th>
</tr>
</thead>
<tbody><tr>
<td>基本地址变换机构</td>
<td>①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元</td>
<td>两次访存</td>
</tr>
<tr>
<td>具有快表的地址变换机构</td>
<td>①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元</td>
<td>快表命中，只需一次访存 快表未命中，需要两次访存</td>
</tr>
</tbody></table>
<h2 id="34、在执行malloc申请内存的时候，操作系统是怎么做的？"><a href="#34、在执行malloc申请内存的时候，操作系统是怎么做的？" class="headerlink" title="34、在执行malloc申请内存的时候，操作系统是怎么做的？"></a>34、在执行malloc申请内存的时候，操作系统是怎么做的？</h2><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h2 id="35、-守护进程、僵尸进程和孤儿进程"><a href="#35、-守护进程、僵尸进程和孤儿进程" class="headerlink" title="35、 守护进程、僵尸进程和孤儿进程"></a>35、 守护进程、僵尸进程和孤儿进程</h2><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p>
<p>创建守护进程要点：</p>
<p>（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。</p>
<p>（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。</p>
<p>（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。</p>
<p>（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。</p>
<p>（5）将当前目录更改为根目录。</p>
<p>（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。</p>
<p>（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。</p>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。</p>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。</p>
<p>设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID，进程的终止状态，以及该进程使用的CPU时间，所以当终止子进程的父进程调用wait或waitpid时就可以得到这些信息。如果一个进程终止，而该进程有子进程处于僵尸状态，那么它的所有僵尸子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。</p>
<h2 id="36、如何避免僵尸进程？"><a href="#36、如何避免僵尸进程？" class="headerlink" title="36、如何避免僵尸进程？"></a>36、如何避免僵尸进程？</h2><ul>
<li>通过signal(SIGCHLD, SIG_IGN)通知内核对子进程的结束不关心，由内核回收。如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。</li>
<li>父进程调用wait&#x2F;waitpid等函数等待子进程结束，如果尚无子进程退出wait会导致父进程阻塞。waitpid可以通过传递WNOHANG使父进程不阻塞立即返回。</li>
<li>如果父进程很忙可以用signal注册信号处理函数，在信号处理函数调用wait&#x2F;waitpid等待子进程退出。</li>
<li>通过两次调用fork。父进程首先调用fork创建一个子进程然后waitpid等待子进程退出，子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。</li>
</ul>
<p>第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。</p>
<h2 id="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"><a href="#37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？" class="headerlink" title="37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？"></a>37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？</h2><p>主要分为时间局部性和空间局部性。</p>
<p>时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)</p>
<p><img src="http://oss.interviewguide.cn/img/202205212344455.png" alt="img"></p>
<h2 id="38、父进程、子进程、进程组、作业和会话"><a href="#38、父进程、子进程、进程组、作业和会话" class="headerlink" title="38、父进程、子进程、进程组、作业和会话"></a>38、父进程、子进程、进程组、作业和会话</h2><h3 id="父进程"><a href="#父进程" class="headerlink" title="父进程"></a>父进程</h3><p>已创建一个或多个子进程的进程</p>
<h3 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h3><p>由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。</p>
<p>fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。</p>
<p>子进程从父进程继承的有：</p>
<p>1.进程的资格(真实(real)&#x2F;有效(effective)&#x2F;已保存(saved)用户号(UIDs)和组号(GIDs))</p>
<p>2.环境(environment)</p>
<p>3.堆栈</p>
<p>4.内存</p>
<p>5.进程组号</p>
<p>独有：</p>
<p>1.进程号；</p>
<p>2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；</p>
<p>3.资源使用(resource utilizations)设定为0</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。</p>
<p>一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制</p>
<h3 id="为什么只能运行一个前台作业？"><a href="#为什么只能运行一个前台作业？" class="headerlink" title="为什么只能运行一个前台作业？"></a>为什么只能运行一个前台作业？</h3><p>答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。</p>
<p>作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。</p>
<h2 id="39、进程终止的几种方式"><a href="#39、进程终止的几种方式" class="headerlink" title="39、进程终止的几种方式"></a>39、进程终止的几种方式</h2><p>1、main函数的自然返回，<code>return</code> 2、调用<code>exit</code>函数，属于c的函数库 3、调用<code>_exit</code>函数，属于系统调用 4、调用<code>abort</code>函数，异常程序终止，同时发送SIGABRT信号给调用进程。 5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)</p>
<p><strong>exit和_exit的区别</strong></p>
<p><img src="http://oss.interviewguide.cn/img/202205212344845.png" alt="img"></p>
<h2 id="40、Linux中异常和中断的区别"><a href="#40、Linux中异常和中断的区别" class="headerlink" title="40、Linux中异常和中断的区别"></a>40、Linux中异常和中断的区别</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212344538.png" alt="img"></p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>我们在学习《计算机组成原理》的时候会知道两个概念，CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常，下面这张图显示了异常处理的流程：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212344494.png" alt="img"></p>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>最后都是由CPU发送给内核，由内核去处理</li>
<li>处理程序的流程设计上是相似的</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li>
<li>内核需要根据是异常还是中断调用不同的处理程序</li>
<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>
<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>
</ul>
<h2 id="41、Windows和Linux环境下内存分布情况"><a href="#41、Windows和Linux环境下内存分布情况" class="headerlink" title="41、Windows和Linux环境下内存分布情况"></a>41、Windows和Linux环境下内存分布情况</h2><p><img src="http://oss.interviewguide.cn/img/202205212344868.png" alt="img"></p>
<p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p>
<ul>
<li>程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段，包括静态常量；</li>
<li>未初始化数据段，包括未初始化的静态变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h2 id="42、一个由C-C-编译的程序占用的内存分为哪几个部分？"><a href="#42、一个由C-C-编译的程序占用的内存分为哪几个部分？" class="headerlink" title="42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？"></a>42、一个由C&#x2F;C++编译的程序占用的内存分为哪几个部分？</h2><p>1、栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的数据结构中的栈，先进后出。</p>
<p>2、堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p>
<p>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放</p>
<p>4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放</p>
<p>5、程序代码区(text)—存放函数体的二进制代码。</p>
<h2 id="43、一般情况下在Linux-windows平台下栈空间的大小"><a href="#43、一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="43、一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>43、一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><p>Linux环境下有操作系统决定，一般是8MB，8192KB，通过ulimit命令查看以及修改</p>
<p>Windows环境下由编译器决定，VC++6.0一般是1M</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>linux下非编译器决定栈大小，而是由操作系统环境决定，默认是8192KB（8M）；而在Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。</p>
<p>在Linux下通过如下命令可查看和设置栈的大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -a            <span class="comment"># 显示当前栈的大小 （ulimit为系统命令，非编译器命令）</span></span>       </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -s 32768      <span class="comment"># 设置当前栈的大小为32M</span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>下程序栈空间的大小，VC++ 6.0 默认的栈空间是1M。</p>
<p>VC6.0中修改堆栈大小的方法：</p>
<ul>
<li>选择 “Project-&gt;Setting”</li>
<li>选择 “Link”</li>
<li>选择 “Category”中的 “Output”</li>
<li>在 “Stack allocations”中的”Reserve:”中输栈的大小</li>
</ul>
<h2 id="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"><a href="#44、程序从堆中动态分配内存时，虚拟内存上怎么操作的" class="headerlink" title="44、程序从堆中动态分配内存时，虚拟内存上怎么操作的"></a>44、程序从堆中动态分配内存时，虚拟内存上怎么操作的</h2><p>页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系</p>
<p>在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。</p>
<h2 id="45、常见的几种磁盘调度算法"><a href="#45、常见的几种磁盘调度算法" class="headerlink" title="45、常见的几种磁盘调度算法"></a>45、常见的几种磁盘调度算法</h2><p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h3 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h3><p>按照磁盘请求的顺序进行调度。</p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h3 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h3><p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212344899.png" alt="img"></p>
<h3 id="3-电梯扫描算法"><a href="#3-电梯扫描算法" class="headerlink" title="3. 电梯扫描算法"></a>3. 电梯扫描算法</h3><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212344070.png" alt="img"></p>
<h2 id="46、交换空间与虚拟内存的关系"><a href="#46、交换空间与虚拟内存的关系" class="headerlink" title="46、交换空间与虚拟内存的关系"></a>46、交换空间与虚拟内存的关系</h2><h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>Linux 中的交换空间（Swap space）在<strong>物理内存</strong>（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。 交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。 交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个”WIN386.SWP”文件，这个文件会不断地扩大和自动缩小。 就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是<strong>虚拟内存使用的是硬盘的空间</strong>，为什么我们要使用速度最慢的硬盘来做 为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M&#x2F;512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。</p>
<h2 id="47、抖动你知道是什么吗？它也叫颠簸现象"><a href="#47、抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="47、抖动你知道是什么吗？它也叫颠簸现象"></a>47、抖动你知道是什么吗？它也叫颠簸现象</h2><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p>
<p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念</p>
<h2 id="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"><a href="#48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）" class="headerlink" title="48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）"></a>48、从堆和栈上建立对象哪个快？（考察堆和栈的分配效率比较）</h2><p>从两方面来考虑：</p>
<ul>
<li>分配和释放，堆在分配和释放时都要调用函数（malloc,free)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。</li>
<li>访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</li>
</ul>
<h2 id="49、常见内存分配方式有哪些？"><a href="#49、常见内存分配方式有哪些？" class="headerlink" title="49、常见内存分配方式有哪些？"></a>49、常见内存分配方式有哪些？</h2><p>内存分配方式</p>
<p>（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</p>
<p>（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<h2 id="50、常见内存分配内存错误"><a href="#50、常见内存分配内存错误" class="headerlink" title="50、常见内存分配内存错误"></a>50、常见内存分配内存错误</h2><p>（1）内存分配未成功，却使用了它。</p>
<p>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!&#x3D;NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p&#x3D;&#x3D;NULL) 或if(p!&#x3D;NULL)进行防错处理。</p>
<p>（2）内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>
<p>（3）内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
<p>（4）忘记了释放内存，造成内存泄露。</p>
<p>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new&#x2F;delete同理）。</p>
<p>（5）释放了内存却继续使用它。常见于以下有三种情况：</p>
<ul>
<li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li>
<li>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li>
<li>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</li>
</ul>
<h2 id="51、内存交换中，被换出的进程保存在哪里？"><a href="#51、内存交换中，被换出的进程保存在哪里？" class="headerlink" title="51、内存交换中，被换出的进程保存在哪里？"></a>51、内存交换中，被换出的进程保存在哪里？</h2><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。</p>
<h2 id="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"><a href="#52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？" class="headerlink" title="52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？"></a>52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？</h2><p>可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… (注意: PCB 会常驻内存，不会被换出外存)</p>
<h2 id="53、ASCII、Unicode和UTF-8编码的区别？"><a href="#53、ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="53、ASCII、Unicode和UTF-8编码的区别？"></a>53、ASCII、Unicode和UTF-8编码的区别？</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>为了解决上述问题，又出现了把Unicode编码转化为“<strong>可变长编码</strong>”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p>
<h3 id="三者之间的联系"><a href="#三者之间的联系" class="headerlink" title="三者之间的联系"></a>三者之间的联系</h3><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<p>(1) 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</p>
<p>(2)用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图（截取他人图片）</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345239.png" alt="img"></p>
<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345501.png" alt="img"></p>
<h2 id="54、原子操作的是如何实现的"><a href="#54、原子操作的是如何实现的" class="headerlink" title="54、原子操作的是如何实现的"></a>54、原子操作的是如何实现的</h2><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p>（1）使用总线锁保证原子性 第一个机制是通过总线锁保证原子性。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i&#x3D;1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2，如图下图所示。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CPU1    CPU2</span><br><span class="line"> i=1     i=1</span><br><span class="line"> i+1     i+1</span><br><span class="line"> i=2     i=2</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>处理器使用总线锁就是来解决这个问题的。<strong>所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</strong></p>
<p>（2）使用缓存锁保证原子性 第二个机制是通过缓存锁定来保证原子性。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<strong>总线锁定把CPU和内存之间的通信锁住了</strong>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性。</p>
<p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。</strong></p>
<p>但是有两种情况下处理器不会使用缓存锁定。 第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。 第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</p>
<h2 id="55、内存交换你知道有哪些需要注意的关键点吗？"><a href="#55、内存交换你知道有哪些需要注意的关键点吗？" class="headerlink" title="55、内存交换你知道有哪些需要注意的关键点吗？"></a>55、内存交换你知道有哪些需要注意的关键点吗？</h2><ol>
<li>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。</li>
<li>如果换出进程，比如确保该进程的内存空间成正比。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。</li>
<li>普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。</li>
</ol>
<h2 id="56、系统并发和并行，分得清吗？"><a href="#56、系统并发和并行，分得清吗？" class="headerlink" title="56、系统并发和并行，分得清吗？"></a>56、系统并发和并行，分得清吗？</h2><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h2 id="57、可能是最全的页面置换算法总结了"><a href="#57、可能是最全的页面置换算法总结了" class="headerlink" title="57、可能是最全的页面置换算法总结了"></a>57、可能是最全的页面置换算法总结了</h2><h3 id="1、最佳置换法-OPT"><a href="#1、最佳置换法-OPT" class="headerlink" title="1、最佳置换法(OPT)"></a>1、最佳置换法(OPT)</h3><p>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。 <img src="http://oss.interviewguide.cn/img/202205212345108.png" alt="img"> 最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</p>
<h3 id="2、先进先出置换算法-FIFO"><a href="#2、先进先出置换算法-FIFO" class="headerlink" title="2、先进先出置换算法(FIFO)"></a>2、先进先出置换算法(FIFO)</h3><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。 <img src="http://oss.interviewguide.cn/img/202205212345413.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205212345552.png" alt="img">Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
<p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
<h3 id="3、最近最久未使用置换算法-LRU"><a href="#3、最近最久未使用置换算法-LRU" class="headerlink" title="3、最近最久未使用置换算法(LRU)"></a>3、最近最久未使用置换算法(LRU)</h3><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
<p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345619.png" alt="img"> 在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p>
<h3 id="4、时钟置换算法-CLOCK"><a href="#4、时钟置换算法-CLOCK" class="headerlink" title="4、时钟置换算法(CLOCK)"></a>4、时钟置换算法(CLOCK)</h3><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
<p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p>
<p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p>
<p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345526.png" alt="img"></p>
<h3 id="5、改进型的时钟置换算法"><a href="#5、改进型的时钟置换算法" class="headerlink" title="5、改进型的时钟置换算法"></a>5、改进型的时钟置换算法</h3><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p>
<p>为方便讨论，用(访问位，修改位)的形式表示各页面状态。如(1, 1)表示一个页面近期被访问过，且被修改过。</p>
<p>改进型的Clock算法需要综合考虑某一内存页面的访问位和修改位来判断是否置换该页面。在实际编写算法过程中，同样可以用一个等长的整型数组来标识每个内存块的修改状态。访问位A和修改位M可以组成一下四种类型的页面。</p>
<p>算法规则:将所有可能被置换的页面排成–个循环队列</p>
<blockquote>
<p>第一轮:从当前位置开始扫描到第一个(A &#x3D;0, M &#x3D; 0)的帧用于替换。表示该页面最近既未被访问，又未被修改，是最佳淘汰页 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(A &#x3D;1, M &#x3D; 0)的帧用于替换。本轮将所有扫描过的帧访问位设为0。表示该页面最近未被访问，但已被修改，并不是很好的淘汰页。 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(A &#x3D;0, M &#x3D; 1)的帧用于替换。本轮扫描不修改任何标志位。表示该页面最近已被访问，但未被修改，该页有可能再被访问。 第四轮:若第三轮扫描失败，则重新扫描，查找第一个A &#x3D;1, M &#x3D; 1)的帧用于替换。表示该页最近已被访问且被修改，该页可能再被访问。</p>
</blockquote>
<p>由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择- -个淘汰页面最多会进行四轮扫描</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345046.png" alt="img"> 算法规则：将所有可能被置换的页面排成一个循环队列 第一轮:从当前位置开始扫描到第-一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位。(第一优先级:最近没访问，且没修改的页面) 第二轮:若第一轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。本轮将所有扫描过的帧访问位设为0 (第二优先级: 最近没访问，但修改过的页面) 第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0, 0)的帧用于替换。本轮扫描不修改任何标志位(第三优先级:最近访问过，但没修改的页面) 第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0, 1)的帧用于替换。(第四优先级:最近访问过，且修改过的页面) 由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p>
<h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><table>
<thead>
<tr>
<th></th>
<th>算法规则</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>OPT</td>
<td>优先淘汰最长时间内不会被访问的页面</td>
<td>缺页率最小，性能最好;但无法实现</td>
</tr>
<tr>
<td>FIFO</td>
<td>优先淘汰最先进入内存的页面</td>
<td>实现简单;但性能很差，可能出现Belady异常</td>
</tr>
<tr>
<td>LRU</td>
<td>优先淘汰最近最久没访问的页面</td>
<td>性能很好;但需要硬件支持，算法开销大</td>
</tr>
<tr>
<td>CLOCK (NRU)</td>
<td>循环扫描各页面 第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td>
<td>实现简单，算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr>
<td>改进型CLOCK (改进型NRU)</td>
<td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td>
<td>算法开销较小，性能也不错</td>
</tr>
</tbody></table>
<h2 id="58、共享是什么？"><a href="#58、共享是什么？" class="headerlink" title="58、共享是什么？"></a>58、共享是什么？</h2><p>共享是指系统中的资源可以被多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p>
<h2 id="59、死锁相关问题大总结，超全！"><a href="#59、死锁相关问题大总结，超全！" class="headerlink" title="59、死锁相关问题大总结，超全！"></a>59、死锁相关问题大总结，超全！</h2><p>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。</p>
<h3 id="1、死锁产生原因"><a href="#1、死锁产生原因" class="headerlink" title="1、死锁产生原因"></a>1、死锁产生原因</h3><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p>
<p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p>
<ol>
<li><strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li>
<li><strong>不剥夺条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</li>
<li><strong>请求和保持条件</strong>：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
<h3 id="2、死锁演示"><a href="#2、死锁演示" class="headerlink" title="2、死锁演示"></a>2、死锁演示</h3><p>通过代码的形式进行演示，需要两个线程和两个互斥量。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;  //引入互斥量头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	//插入消息，模拟消息不断产生</span><br><span class="line">	void insertMsg() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;插入一条消息:&quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">			my_mutex1.lock(); //语句1</span><br><span class="line">			my_mutex2.lock(); //语句2</span><br><span class="line">			Msg.push_back(i);</span><br><span class="line">			my_mutex2.unlock();</span><br><span class="line">			my_mutex1.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//读取消息</span><br><span class="line">	void readMsg() &#123;</span><br><span class="line">		int MsgCom;</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			MsgCom = MsgLULProc(i);</span><br><span class="line">			if (MsgLULProc(MsgCom)) &#123;</span><br><span class="line">				//读出消息了</span><br><span class="line">				cout &lt;&lt; &quot;消息已读出&quot; &lt;&lt; MsgCom &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				//消息暂时为空</span><br><span class="line">				cout &lt;&lt; &quot;消息为空&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//加解锁代码</span><br><span class="line">	bool MsgLULProc(int &amp;command) &#123;</span><br><span class="line">		int curMsg;</span><br><span class="line">		my_mutex2.lock();   //语句3</span><br><span class="line">		my_mutex1.lock();   //语句4</span><br><span class="line">		if (!Msg.empty()) &#123;</span><br><span class="line">			//读取消息，读完删除</span><br><span class="line">			command = Msg.front();</span><br><span class="line">			Msg.pop_front();</span><br><span class="line">			</span><br><span class="line">			my_mutex1.unlock();</span><br><span class="line">			my_mutex2.unlock();</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		my_mutex1.unlock();</span><br><span class="line">		my_mutex2.unlock();</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	std::list&lt;int&gt; Msg;  //消息变量</span><br><span class="line">	std::mutex my_mutex1; //互斥量对象1</span><br><span class="line">	std::mutex my_mutex2; //互斥量对象2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	A a;</span><br><span class="line">	//创建一个插入消息线程</span><br><span class="line">	std::thread insertTd(&amp;A::insertMsg, &amp;a); //这里要传入引用保证是同一个对象</span><br><span class="line">	//创建一个读取消息线程</span><br><span class="line">	std::thread readTd(&amp;A::readMsg, &amp;a); //这里要传入引用保证是同一个对象</span><br><span class="line">	insertTd.join();</span><br><span class="line">	readTd.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>语句1和语句2表示线程A先锁资源1，再锁资源2，语句3和语句4表示线程B先锁资源2再锁资源1，具备死锁产生的条件。</p>
<h3 id="3、死锁的解决方案"><a href="#3、死锁的解决方案" class="headerlink" title="3、死锁的解决方案"></a>3、死锁的解决方案</h3><p> 保证上锁的顺序一致。</p>
<h3 id="4、死锁必要条件"><a href="#4、死锁必要条件" class="headerlink" title="4、死锁必要条件"></a>4、死锁必要条件</h3><ul>
<li>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</li>
<li>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放</li>
<li>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</li>
<li>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li>
</ul>
<h3 id="5、处理方法"><a href="#5、处理方法" class="headerlink" title="5、处理方法"></a>5、处理方法</h3><p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<p>1、每种类型一个资源的死锁检测</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345141.png" alt="img"></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<p>2、每种类型多个资源的死锁检测</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345141.png" alt="img"></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h3 id="6、死锁恢复"><a href="#6、死锁恢复" class="headerlink" title="6、死锁恢复"></a>6、死锁恢复</h3><ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="7、死锁预防"><a href="#7、死锁预防" class="headerlink" title="7、死锁预防"></a>7、死锁预防</h3><p>在程序运行之前预防发生死锁。</p>
<p>1.破坏互斥条件</p>
<p> 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<p>2.破坏请求和保持条件</p>
<p> 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<p>3.破坏不剥夺条件</p>
<p> 允许抢占资源</p>
<p>4.破坏循环请求等待</p>
<p> 给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h3 id="8、死锁避免"><a href="#8、死锁避免" class="headerlink" title="8、死锁避免"></a>8、死锁避免</h3><p>在程序运行时避免发生死锁。</p>
<h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1.安全状态"></a>1.安全状态</h4><p><img src="http://oss.interviewguide.cn/img/202205212345923.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p>
<h4 id="2-单个资源的银行家算法"><a href="#2-单个资源的银行家算法" class="headerlink" title="2.单个资源的银行家算法"></a>2.单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="http://oss.interviewguide.cn/img/202205212345716.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h4 id="3-多个资源的银行家算法"><a href="#3-多个资源的银行家算法" class="headerlink" title="3.多个资源的银行家算法"></a>3.多个资源的银行家算法</h4><p><img src="http://oss.interviewguide.cn/img/202205212345258.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p>
<h4 id="4-检查一个状态是否安全的算法如下："><a href="#4-检查一个状态是否安全的算法如下：" class="headerlink" title="4.检查一个状态是否安全的算法如下："></a>4.检查一个状态是否安全的算法如下：</h4><ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h2 id="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"><a href="#60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？" class="headerlink" title="60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？"></a>60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？</h2><p>分段式分配是按需分配，而固定式分配是固定分配的方式。</p>
<h2 id="61、内部碎片与外部碎片"><a href="#61、内部碎片与外部碎片" class="headerlink" title="61、内部碎片与外部碎片"></a>61、内部碎片与外部碎片</h2><p>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式</p>
<p>内存总量相同，100M</p>
<p>固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；</p>
<p>分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。</p>
<p>外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中</p>
<p>分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片</p>
<h2 id="62、如何消除碎片文件"><a href="#62、如何消除碎片文件" class="headerlink" title="62、如何消除碎片文件"></a>62、如何消除碎片文件</h2><p>对于外部碎片，通过<strong>紧凑技术</strong>消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑</p>
<p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p>
<p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>回收内存时要尽可能地将相邻的空闲空间合并。</p>
<h2 id="63、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"><a href="#63、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？" class="headerlink" title="63、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？"></a>63、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？</h2><ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong> 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h2 id="64、服务器高并发的解决方案你知道多少？"><a href="#64、服务器高并发的解决方案你知道多少？" class="headerlink" title="64、服务器高并发的解决方案你知道多少？"></a>64、服务器高并发的解决方案你知道多少？</h2><ul>
<li>应用数据与静态资源分离 将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</li>
<li>客户端缓存 因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</li>
<li>集群和分布式 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</li>
<li>反向代理 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</li>
</ul>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-计算机网络</title>
    <url>/2023/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、OSI-的七层模型分别是？各自的功能是什么？"><a href="#1、OSI-的七层模型分别是？各自的功能是什么？" class="headerlink" title="1、OSI 的七层模型分别是？各自的功能是什么？"></a>1、OSI 的七层模型分别是？各自的功能是什么？</h2><h3 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h3><ul>
<li>物理层：底层数据传输，如网线；网卡标准。</li>
<li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。</li>
<li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。</li>
<li>传输层：端到端传输数据的基本功能；如 TCP、UDP。</li>
<li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li>
<li>表示层：数据格式标识，基本压缩加密功能。</li>
<li>应用层：各种应用软件，包括 Web 应用。</li>
</ul>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在四层，既传输层数据被称作<strong>tcp报文段或udp用户数据报</strong>（Segments）；</li>
<li>三层网络层数据被称做<strong>包</strong>（Packages）；</li>
<li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li>
<li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>网络七层模型是一个标准，而非实现。</li>
<li>网络四层模型是一个实现的应用模型。</li>
<li>网络四层模型由七层模型简化合并而来。</li>
</ul>
<h2 id="2、说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#2、说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="2、说一下一次完整的HTTP请求过程包括哪些内容？"></a>2、说一下一次完整的HTTP请求过程包括哪些内容？</h2><h3 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a>第一种回答</h3><ul>
<li>建立起客户机和服务器连接。</li>
<li>建立连接后，客户机发送一个请求给服务器。</li>
<li>服务器收到请求给予响应信息。</li>
<li>客户端浏览器将返回的内容解析并呈现，断开连接。</li>
</ul>
<h3 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a>第二种回答</h3><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户。</p>
<h2 id="3、你知道DNS是什么？"><a href="#3、你知道DNS是什么？" class="headerlink" title="3、你知道DNS是什么？"></a>3、你知道DNS是什么？</h2><p><strong>官方解释</strong>：DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</a></p>
<h2 id="4、DNS的工作原理？"><a href="#4、DNS的工作原理？" class="headerlink" title="4、DNS的工作原理？"></a>4、DNS的工作原理？</h2><p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）</p>
<p><img src="http://oss.interviewguide.cn/img/202205220036790.png" alt="img"> 过程： 总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 一、主机向本地域名服务器的查询一般都是采用递归查询。 二、本地域名服务器向根域名服务器的查询的迭代查询。</p>
<ol>
<li>当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束。 2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 3）若无命中，则请求本地域名服务器解析（LDNS）。 4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。 5）此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 6）Name Server根据映射关系表找到目标ip，返回给LDNS</li>
<li>LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</li>
</ol>
<h2 id="5、为什么域名解析用UDP协议？"><a href="#5、为什么域名解析用UDP协议？" class="headerlink" title="5、为什么域名解析用UDP协议？"></a>5、为什么域名解析用UDP协议？</h2><p>因为UDP快啊！UDP的DNS协议只要一个请求、一个应答就好了。</p>
<p>而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。</p>
<p>不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。</p>
<h2 id="6、为什么区域传送用TCP协议？"><a href="#6、为什么区域传送用TCP协议？" class="headerlink" title="6、为什么区域传送用TCP协议？"></a>6、为什么区域传送用TCP协议？</h2><p>因为TCP协议可靠性好啊！</p>
<p>你要从主DNS上复制内容啊，你用不可靠的UDP？ 因为TCP协议传输的内容大啊，你用最大只能传512字节的UDP协议？万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！</p>
<h2 id="7、HTTP长连接和短连接的区别"><a href="#7、HTTP长连接和短连接的区别" class="headerlink" title="7、HTTP长连接和短连接的区别"></a>7、HTTP长连接和短连接的区别</h2><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。</p>
<h2 id="8、什么是TCP粘包-拆包？发生的原因？"><a href="#8、什么是TCP粘包-拆包？发生的原因？" class="headerlink" title="8、什么是TCP粘包&#x2F;拆包？发生的原因？"></a>8、什么是TCP粘包&#x2F;拆包？发生的原因？</h2><p>一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.</p>
<p>2、进行MSS大小的TCP分段。( MSS&#x3D;TCP报文段长度-TCP首部长度)</p>
<p>3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>1、消息定长。</p>
<p>2、在包尾部增加回车或者空格符等特殊字符进行分割</p>
<p>3、将消息分为消息头和消息尾</p>
<p>4、使用其它复杂的协议，如RTMP协议等。</p>
<h2 id="9、为什么服务器会缓存这一项功能-如何实现的？"><a href="#9、为什么服务器会缓存这一项功能-如何实现的？" class="headerlink" title="9、为什么服务器会缓存这一项功能?如何实现的？"></a>9、为什么服务器会缓存这一项功能?如何实现的？</h2><p><strong>原因</strong></p>
<ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<p><strong>实现方法</strong></p>
<ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h2 id="10、HTTP请求方法你知道多少？"><a href="#10、HTTP请求方法你知道多少？" class="headerlink" title="10、HTTP请求方法你知道多少？"></a>10、HTTP请求方法你知道多少？</h2><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th align="left">序 号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
<h2 id="11、GET-和-POST-的区别，你知道哪些？"><a href="#11、GET-和-POST-的区别，你知道哪些？" class="headerlink" title="11、GET 和 POST 的区别，你知道哪些？"></a>11、GET 和 POST 的区别，你知道哪些？</h2><ol>
<li><p>get是获取数据，post是修改数据</p>
</li>
<li><p>get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）</p>
</li>
<li><p>get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。</p>
</li>
<li><p>GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li><p>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</p>
</li>
<li><p>本质区别：GET是幂等的，而POST不是幂等的</p>
<blockquote>
<p>这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
</blockquote>
</li>
</ol>
<p>正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。</p>
<h2 id="12、一个TCP连接可以对应几个HTTP请求？"><a href="#12、一个TCP连接可以对应几个HTTP请求？" class="headerlink" title="12、一个TCP连接可以对应几个HTTP请求？"></a>12、一个TCP连接可以对应几个HTTP请求？</h2><p>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。</p>
<h2 id="13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"><a href="#13、一个-TCP-连接中-HTTP-请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？" class="headerlink" title="13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？"></a>13、一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</h2><p>HTTP&#x2F;1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。</p>
<p>在 HTTP&#x2F;1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。</p>
<p>那么在 HTTP&#x2F;1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：</p>
<ul>
<li>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</li>
<li>和服务器建立多个 TCP 连接。</li>
</ul>
<h2 id="14、浏览器对同一-Host-建立-TCP-连接到的数量有没有限制？"><a href="#14、浏览器对同一-Host-建立-TCP-连接到的数量有没有限制？" class="headerlink" title="14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？"></a>14、浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？</h2><p>假设我们还处在 HTTP&#x2F;1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。</p>
<p><strong>有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。</strong></p>
<p>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。</p>
<p>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP&#x2F;1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>
<blockquote>
<p>update1：微信好友“卷轴”提出勘误“连接到”-》“连接到的”</p>
</blockquote>
<h2 id="15、在浏览器中输入url地址后显示主页的过程"><a href="#15、在浏览器中输入url地址后显示主页的过程" class="headerlink" title="15、在浏览器中输入url地址后显示主页的过程?"></a>15、在浏览器中输入url地址后显示主页的过程?</h2><blockquote>
<ul>
<li>根据域名，进行DNS域名解析；</li>
<li>拿到解析的IP地址，建立TCP连接；</li>
<li>向IP地址，发送HTTP请求；</li>
<li>服务器处理请求；</li>
<li>返回响应结果；</li>
<li>关闭TCP连接；</li>
<li>浏览器解析HTML；</li>
<li>浏览器布局渲染；</li>
</ul>
</blockquote>
<h2 id="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"><a href="#16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？" class="headerlink" title="16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？"></a>16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？</h2><h3 id="第一种回答-1"><a href="#第一种回答-1" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>1、查浏览器缓存，看看有没有已经缓存好的，如果没有</p>
<p>2 、检查本机host文件，</p>
<p>3、调用API，Linux下Socket函数 gethostbyname</p>
<p>4、向DNS服务器发送DNS请求，查询本地DNS服务器，这其中用的是UDP的协议</p>
<p>5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）</p>
<p>6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，</p>
<p>7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，</p>
<p>8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，</p>
<p>9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，</p>
<p>10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。</p>
<p>11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页</p>
<h3 id="第二种回答-1"><a href="#第二种回答-1" class="headerlink" title="第二种回答"></a>第二种回答</h3><p>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome:&#x2F;&#x2F;net-internals&#x2F;#dns）。</p>
<p>如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。</p>
<p>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</p>
<p>查询本地 DNS 服务器</p>
<p>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</p>
<p>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</p>
<h2 id="17、谈谈DNS解析过程，具体一点"><a href="#17、谈谈DNS解析过程，具体一点" class="headerlink" title="17、谈谈DNS解析过程，具体一点"></a>17、谈谈DNS解析过程，具体一点</h2><p><img src="http://oss.interviewguide.cn/img/202205220036692.png" alt="img"></p>
<ul>
<li>请求一旦发起，若是chrome浏览器，先在浏览器找之前<strong>有没有缓存过的域名所对应的ip地址</strong>，有的话，直接跳过dns解析了，若是没有，就会<strong>找硬盘的hosts文件</strong>，看看有没有，有的话，直接找到hosts文件里面的ip</li>
<li>如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个<strong>dns请求到本地dns服务器</strong>，<strong>本地dns服务器一般都是你的网络接入服务器商提供</strong>，比如中国电信，中国移动等。</li>
<li>查询你输入的网址的DNS请求到达本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中有此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，本地DNS服务器还要向<strong>DNS根服务器</strong>进行查询。</li>
<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<h2 id="18、DNS负载均衡是什么策略？"><a href="#18、DNS负载均衡是什么策略？" class="headerlink" title="18、DNS负载均衡是什么策略？"></a>18、DNS负载均衡是什么策略？</h2><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在<strong>DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器</strong>,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h2 id="19、HTTPS和HTTP的区别"><a href="#19、HTTPS和HTTP的区别" class="headerlink" title="19、HTTPS和HTTP的区别"></a>19、HTTPS和HTTP的区别</h2><p>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<h2 id="20、什么是SSL-TLS-？"><a href="#20、什么是SSL-TLS-？" class="headerlink" title="20、什么是SSL&#x2F;TLS ？"></a>20、什么是SSL&#x2F;TLS ？</h2><p>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<p>SSL&#x2F;TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的</p>
<p>对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的，</p>
<h2 id="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"><a href="#21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）" class="headerlink" title="21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"></a>21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h2><p>（1）客户端向服务器端发起SSL连接请求； （2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 （3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 （4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密， （5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。</p>
<p>因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p>
<p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p><strong>补充</strong>：SSL&#x2F;TLS的四次握手，目前网上的主流答案都在重复阮一峰老师的博客，属于TLS 1.0版本的答案，使用RSA密钥交换算法。但是现在TLS 1.2已经成为主流，使用ECDHE算法，如果面试可以说出这个版本的答案，应该会更好。</p>
<h2 id="22、如何保证公钥不被篡改？"><a href="#22、如何保证公钥不被篡改？" class="headerlink" title="22、如何保证公钥不被篡改？"></a>22、如何保证公钥不被篡改？</h2><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。 （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成”对话密钥”。 （3） 双方采用”对话密钥”进行加密通信。上面过程的前两步，又称为”握手阶段”（handshake）。</p>
<h2 id="23、HTTP请求和响应报文有哪些主要字段？"><a href="#23、HTTP请求和响应报文有哪些主要字段？" class="headerlink" title="23、HTTP请求和响应报文有哪些主要字段？"></a>23、HTTP请求和响应报文有哪些主要字段？</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>简单来说：</p>
<ul>
<li>请求行：Request Line</li>
<li>请求头：Request Headers</li>
<li>请求体：Request Body</li>
</ul>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>简单来说：</p>
<ul>
<li>状态行：Status Line</li>
<li>响应头：Response Headers</li>
<li>响应体：Response Body</li>
</ul>
<h2 id="24、Cookie是什么？"><a href="#24、Cookie是什么？" class="headerlink" title="24、Cookie是什么？"></a>24、Cookie是什么？</h2><p>HTTP 协议是<strong>无状态</strong>的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p>
<p>新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。</p>
<p>抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name&#x3D;value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。</p>
<h2 id="25、Cookie有什么用途？用途"><a href="#25、Cookie有什么用途？用途" class="headerlink" title="25、Cookie有什么用途？用途"></a>25、Cookie有什么用途？用途</h2><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h2 id="26、Session知识大总结"><a href="#26、Session知识大总结" class="headerlink" title="26、Session知识大总结"></a>26、Session知识大总结</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ol>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ol>
<blockquote>
<p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
</blockquote>
<h2 id="27、Session-的工作原理是什么？"><a href="#27、Session-的工作原理是什么？" class="headerlink" title="27、Session 的工作原理是什么？"></a>27、Session 的工作原理是什么？</h2><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h2 id="28、Cookie与Session的对比"><a href="#28、Cookie与Session的对比" class="headerlink" title="28、Cookie与Session的对比"></a>28、Cookie与Session的对比</h2><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p>
<ul>
<li><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>Cookie是客户端保持状态的方法。</p>
<p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p>
<p>除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p>
</li>
<li><p>Session</p>
<p>Session是服务器保持状态的方法。</p>
<p>首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p>
</li>
</ul>
<p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>
<h2 id="29、SQL注入攻击了解吗？"><a href="#29、SQL注入攻击了解吗？" class="headerlink" title="29、SQL注入攻击了解吗？"></a>29、SQL注入攻击了解吗？</h2><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’&#x3D;’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name &#x3D; ‘lianggzone’ and password &#x3D; ‘’ or ‘1’&#x3D;‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 Web端 1）有效性检验。 2）限制字符串输入的长度。 服务端 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</p>
<h2 id="30、网络的七层模型与各自的功能（图片版）"><a href="#30、网络的七层模型与各自的功能（图片版）" class="headerlink" title="30、网络的七层模型与各自的功能（图片版）"></a>30、网络的七层模型与各自的功能（图片版）</h2><p><img src="http://oss.interviewguide.cn/img/202205072300304.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205072300887.png" alt="img"></p>
<h2 id="31、什么是RARP？工作原理"><a href="#31、什么是RARP？工作原理" class="headerlink" title="31、什么是RARP？工作原理"></a>31、什么是RARP？工作原理</h2><p>概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 原理： (1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。</p>
<p>(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。</p>
<p>(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。</p>
<h2 id="32、端口有效范围是多少到多少？"><a href="#32、端口有效范围是多少到多少？" class="headerlink" title="32、端口有效范围是多少到多少？"></a>32、端口有效范围是多少到多少？</h2><p>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p>
<p>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p>
<h2 id="33、为何需要把-TCP-IP-协议栈分成-5-层（或7层）？开放式回答。"><a href="#33、为何需要把-TCP-IP-协议栈分成-5-层（或7层）？开放式回答。" class="headerlink" title="33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？开放式回答。"></a>33、为何需要把 TCP&#x2F;IP 协议栈分成 5 层（或7层）？开放式回答。</h2><p>答：ARPANET 的研制经验表明，对于复杂的计算机网络协议，其结构应该是层次式的。</p>
<p>分层的好处：</p>
<p>①隔层之间是独立的</p>
<p>②灵活性好</p>
<p>③结构上可以分隔开</p>
<p>④易于实现和维护</p>
<p>⑤能促进标准化工作。</p>
<h2 id="34、DNS查询方式有哪些？"><a href="#34、DNS查询方式有哪些？" class="headerlink" title="34、DNS查询方式有哪些？"></a>34、DNS查询方式有哪些？</h2><h3 id="递归解析"><a href="#递归解析" class="headerlink" title="递归解析"></a>递归解析</h3><p>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>
<h3 id="迭代解析"><a href="#迭代解析" class="headerlink" title="迭代解析"></a>迭代解析</h3><p>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p>
<h2 id="35、HTTP中缓存的私有和共有字段？知道吗？"><a href="#35、HTTP中缓存的私有和共有字段？知道吗？" class="headerlink" title="35、HTTP中缓存的私有和共有字段？知道吗？"></a>35、HTTP中缓存的私有和共有字段？知道吗？</h2><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="36、GET-方法参数写法是固定的吗？"><a href="#36、GET-方法参数写法是固定的吗？" class="headerlink" title="36、GET 方法参数写法是固定的吗？"></a>36、GET 方法参数写法是固定的吗？</h2><p>在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。</p>
<p>我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。</p>
<p>比如header请求头中添加token，来验证用户是否登录等权限问题。</p>
<p>也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。</p>
<h2 id="37、GET-方法的长度限制是怎么回事？"><a href="#37、GET-方法的长度限制是怎么回事？" class="headerlink" title="37、GET 方法的长度限制是怎么回事？"></a>37、GET 方法的长度限制是怎么回事？</h2><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p>
<p>首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p>
<p>浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p>
<h2 id="38、POST-方法比-GET-方法安全？"><a href="#38、POST-方法比-GET-方法安全？" class="headerlink" title="38、POST 方法比 GET 方法安全？"></a>38、POST 方法比 GET 方法安全？</h2><p>有人说POST 比 GET 安全，因为数据在地址栏上不可见。</p>
<p>然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</p>
<p>要想安全传输，就只有加密，也就是 HTTPS。</p>
<h2 id="39、POST-方法会产生两个-TCP-数据包？你了解吗？"><a href="#39、POST-方法会产生两个-TCP-数据包？你了解吗？" class="headerlink" title="39、POST 方法会产生两个 TCP 数据包？你了解吗？"></a>39、POST 方法会产生两个 TCP 数据包？你了解吗？</h2><p>有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p>
<p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。</p>
<p>所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p>
<h2 id="40、Session是什么？"><a href="#40、Session是什么？" class="headerlink" title="40、Session是什么？"></a>40、Session是什么？</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<h2 id="41、使用-Session-的过程是怎样的？"><a href="#41、使用-Session-的过程是怎样的？" class="headerlink" title="41、使用 Session 的过程是怎样的？"></a>41、使用 Session 的过程是怎样的？</h2><p>过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h2 id="42、Session和cookie应该如何去选择（适用场景）？"><a href="#42、Session和cookie应该如何去选择（适用场景）？" class="headerlink" title="42、Session和cookie应该如何去选择（适用场景）？"></a>42、Session和cookie应该如何去选择（适用场景）？</h2><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="43、Cookies和Session区别是什么？"><a href="#43、Cookies和Session区别是什么？" class="headerlink" title="43、Cookies和Session区别是什么？"></a>43、Cookies和Session区别是什么？</h2><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案 1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全 2，存储的数据类型不同 两者都是key-value的结构，但针对value的类型是有差异的 cookie：value只能是字符串类型，session：value是Object类型 3，存储的数据大小限制不同 cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制， 4，生命周期的控制 cookie的生命周期当浏览器关闭的时候，就消亡了 (1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束， (2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁</p>
<h2 id="44、DDos-攻击了解吗？"><a href="#44、DDos-攻击了解吗？" class="headerlink" title="44、DDos 攻击了解吗？"></a>44、DDos 攻击了解吗？</h2><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 没有彻底根治的办法，除非不使用TCP DDos 预防： 1）限制同时打开SYN半链接的数目 2）缩短SYN半链接的Time out 时间 3）关闭不必要的服务</p>
<h2 id="45、MTU和MSS分别是什么？"><a href="#45、MTU和MSS分别是什么？" class="headerlink" title="45、MTU和MSS分别是什么？"></a>45、MTU和MSS分别是什么？</h2><p>MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。</p>
<p>MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</p>
<h2 id="46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）"><a href="#46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）" class="headerlink" title="46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）"></a>46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）</h2><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<ul>
<li>在 HTTP&#x2F;1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP&#x2F;1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<h2 id="47、TCP头部中有哪些信息？"><a href="#47、TCP头部中有哪些信息？" class="headerlink" title="47、TCP头部中有哪些信息？"></a>47、TCP头部中有哪些信息？</h2><ul>
<li>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 &#x3D; ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN &#x3D; 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</li>
<li>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</li>
<li>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</li>
<li>标志位（6bit）：<ul>
<li>URG：标志紧急指针是否有效。</li>
<li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li>
<li>PSH：提示接收端立即从缓冲读走数据。</li>
<li>RST：表示要求对方重新建立连接（复位报文段）。</li>
<li>SYN：表示请求建立一个连接（连接报文段）。</li>
<li>FIN：表示关闭连接（断开报文段）。</li>
</ul>
</li>
<li>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</li>
<li>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</li>
</ul>
<h2 id="48、常见TCP的连接状态有哪些？"><a href="#48、常见TCP的连接状态有哪些？" class="headerlink" title="48、常见TCP的连接状态有哪些？"></a>48、常见TCP的连接状态有哪些？</h2><ul>
<li>CLOSED：初始状态。</li>
<li>LISTEN：服务器处于监听状态。</li>
<li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li>
</ul>
<h2 id="49、网络的七层-五层模型主要的协议有哪些？"><a href="#49、网络的七层-五层模型主要的协议有哪些？" class="headerlink" title="49、网络的七层&#x2F;五层模型主要的协议有哪些？"></a>49、网络的七层&#x2F;五层模型主要的协议有哪些？</h2><p><img src="http://oss.interviewguide.cn/img/202205072300758.png" alt="img"></p>
<h2 id="50、TCP是什么？"><a href="#50、TCP是什么？" class="headerlink" title="50、TCP是什么？"></a>50、TCP是什么？</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h2 id="51、TCP头部报文字段介绍几个？各自的功能？"><a href="#51、TCP头部报文字段介绍几个？各自的功能？" class="headerlink" title="51、TCP头部报文字段介绍几个？各自的功能？"></a>51、TCP头部报文字段介绍几个？各自的功能？</h2><p>source port 和 destination port</p>
<blockquote>
<p>两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口。</p>
</blockquote>
<p>可以这么理解，我们有很多软件，每个软件都对应一个端口，假如，你想和我数据交互，咱们得互相知道你我的端口号。</p>
<p>再来一个很官方的：</p>
<blockquote>
<p>扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p>
</blockquote>
<p>Sequence Number</p>
<blockquote>
<p>称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x &#x3D; ACK_y (x 的序列号 &#x3D; y 发给 x 的 ACK)。</p>
</blockquote>
<p>说白了，类似于身份证一样，而且还得发送此时此刻的所在的位置，就相当于身份证上的地址一样。</p>
<p>Acknowledge Number</p>
<blockquote>
<p>称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。</p>
</blockquote>
<p>TCP Flag</p>
<p>TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。</p>
<p>当然只介绍三个：</p>
<ol>
<li>ACK：这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。</li>
<li>SYN：表示「同步序列号」，是 TCP 握手的发送的第一个数据包。用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN&#x3D;1，ACK&#x3D;0连接被响应的时候，SYN&#x3D;1，ACK&#x3D;1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。</li>
<li>FIN：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了；TCP四次分手必然问。</li>
</ol>
<p>Window size</p>
<blockquote>
<p>称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。</p>
</blockquote>
<h2 id="52、OSI-的七层模型的主要功能？"><a href="#52、OSI-的七层模型的主要功能？" class="headerlink" title="52、OSI 的七层模型的主要功能？"></a>52、OSI 的七层模型的主要功能？</h2><p><img src="http://oss.interviewguide.cn/img/202205072300329.png" alt="img"></p>
<p><strong>物理层：</strong>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 <strong>数据链路层：</strong>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层 <strong>网络层：</strong>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 <strong>传输层：</strong>在源端与目的端之间提供可靠的透明数据传输 <strong>会话层：</strong>负责在网络中的两节点之间建立、维持和终止通信 <strong>表示层：</strong>处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密 <strong>应用层：</strong>为用户的应用进程提供网络通信服务</p>
<h2 id="53、应用层常见协议知道多少？了解几个？"><a href="#53、应用层常见协议知道多少？了解几个？" class="headerlink" title="53、应用层常见协议知道多少？了解几个？"></a>53、应用层常见协议知道多少？了解几个？</h2><table>
<thead>
<tr>
<th>协议</th>
<th>名称</th>
<th>默认端口</th>
<th>底层协议</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>超文本传输协议</td>
<td>80</td>
<td>TCP</td>
</tr>
<tr>
<td>HTTPS</td>
<td>超文本传输安全协议</td>
<td>443</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>远程登录服务的标准协议</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>FTP</td>
<td>文件传输协议</td>
<td>20传输和21连接</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>简单文件传输协议</td>
<td>69</td>
<td>UDP</td>
</tr>
<tr>
<td>SMTP</td>
<td>简单邮件传输协议（发送用）</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP</td>
<td>邮局协议（接收用）</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>DNS</td>
<td>域名解析服务</td>
<td>53</td>
<td>服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP</td>
</tr>
</tbody></table>
<h2 id="54、浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#54、浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP&#x2F;1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，<strong>某些服务器对 Connection: keep-alive 的 Header 进行了支持</strong>。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。</p>
<p><strong>持久连接</strong>：既然维持 TCP 连接好处这么多，HTTP&#x2F;1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p>
<p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p>
<h2 id="55、三次握手相关内容"><a href="#55、三次握手相关内容" class="headerlink" title="55、三次握手相关内容"></a>55、三次握手相关内容</h2><p><img src="http://oss.interviewguide.cn/img/202205072301822.png" alt="img"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<h3 id="第一种回答-2"><a href="#第一种回答-2" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p>
<ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p>在socket编程中，客户端执行connect()时，将触发三次握手。</p>
<h3 id="第二种回答-2"><a href="#第二种回答-2" class="headerlink" title="第二种回答"></a>第二种回答</h3><ul>
<li>初始状态：客户端处于 closed(关闭)状态，服务器处于 listen(监听) 状态。</li>
<li>第一次握手：客户端发送请求报文将 SYN &#x3D; 1同步序列号和初始化序列号seq &#x3D; x发送给服务端，发送完之后客户端处于SYN_Send状态。（验证了客户端的发送能力和服务端的接收能力）</li>
<li>第二次握手：服务端受到 SYN 请求报文之后，如果同意连接，会以自己的同步序列号SYN(服务端) &#x3D; 1、初始化序列号 seq &#x3D; y和确认序列号（期望下次收到的数据包）ack &#x3D; x+ 1 以及确认号ACK &#x3D; 1报文作为应答，服务器为SYN_Receive状态。（问题来了，两次握手之后，站在客户端角度上思考：我发送和接收都ok，服务端的发送和接收也都ok。但是站在服务端的角度思考：哎呀，我服务端接收ok，但是我不清楚我的发送ok不ok呀，而且我还不知道你接受能力如何呢？所以老哥，你需要给我三次握手来传个话告诉我一声。你要是不告诉我，万一我认为你跑了，然后我可能出于安全性的考虑继续给你发一次，看看你回不回我。）</li>
<li>第三次握手： 客户端接收到服务端的 SYN + ACK之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 ack &#x3D; y + 1和数据包的序列号 seq &#x3D; x + 1以及确认号ACK &#x3D; 1确认包作为应答，客户端转为established状态。（分别站在双方的角度上思考，各自ok）</li>
</ul>
<h2 id="56、为什么需要三次握手，两次不行吗？"><a href="#56、为什么需要三次握手，两次不行吗？" class="headerlink" title="56、为什么需要三次握手，两次不行吗？"></a>56、为什么需要三次握手，两次不行吗？</h2><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<h2 id="57、什么是半连接队列？"><a href="#57、什么是半连接队列？" class="headerlink" title="57、什么是半连接队列？"></a>57、什么是半连接队列？</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s……</p>
<h2 id="58、-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#58、-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="58、 ISN(Initial Sequence Number)是固定的吗？"></a>58、 ISN(Initial Sequence Number)是固定的吗？</h2><p>当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN，ISN是一个有可以看作是一个32比特的计数器，但并不是简单的计数器，大概每4ms加1 。</p>
<blockquote>
<p>ISN &#x3D; M + F(localhost, localport, remotehost, remoteport)(M为计数器)，ISN应该由这个公式确定，F为哈希算法，不是一个简单计数器。</p>
</blockquote>
<p>这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。</p>
<p><strong>三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</strong></p>
<h2 id="59、-三次握手过程中可以携带数据吗？"><a href="#59、-三次握手过程中可以携带数据吗？" class="headerlink" title="59、 三次握手过程中可以携带数据吗？"></a>59、 三次握手过程中可以携带数据吗？</h2><p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>
<p>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p>
<p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p>
<h2 id="60、SYN攻击是什么？"><a href="#60、SYN攻击是什么？" class="headerlink" title="60、SYN攻击是什么？"></a>60、SYN攻击是什么？</h2><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br><span class="line">复制代码</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="61、-四次挥手相关内容"><a href="#61、-四次挥手相关内容" class="headerlink" title="61、 四次挥手相关内容"></a>61、 四次挥手相关内容</h2><p><img src="http://oss.interviewguide.cn/img/202205220036404.png" alt="img"></p>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<h3 id="第一种回答-3"><a href="#第一种回答-3" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 <code>FIN_WAIT1</code> 状态。 即发出<strong>连接释放报文段</strong>（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。 即服务端收到连接释放报文段后即发出<strong>确认报文段</strong>（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。 即服务端没有要向客户端发出的数据，服务端发出<strong>连接释放报文段</strong>（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的确认号值，此时客户端处于 <code>TIME_WAIT</code> 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。 即客户端收到服务端的连接释放报文段后，对此发出<strong>确认报文段</strong>（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</li>
</ul>
<p>收到一个FIN只意味着在这一方向上没有数据流动。<strong>客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。</strong></p>
<p>在socket编程中，任何一方执行close()操作即可产生挥手操作。</p>
<h3 id="第二种回答-3"><a href="#第二种回答-3" class="headerlink" title="第二种回答"></a>第二种回答</h3><ul>
<li><strong>初始化状态</strong>：客户端和服务端都在连接状态，接下来开始进行四次分手断开连接操作。</li>
<li><strong>第一次分手</strong>：第一次分手无论是客户端还是服务端都可以发起，因为 TCP 是全双工的。</li>
</ul>
<blockquote>
<p>假如客户端发送的数据已经发送完毕，发送FIN &#x3D; 1 <strong>告诉服务端，客户端所有数据已经全发完了</strong>，<strong>服务端你可以关闭接收了</strong>，但是如果你们服务端有数据要发给客户端，客户端照样可以接收的。此时客户端处于FIN &#x3D; 1等待服务端确认释放连接状态。</p>
</blockquote>
<ul>
<li><strong>第二次分手</strong>：服务端接收到客户端的释放请求连接之后，<strong>知道客户端没有数据要发给自己了</strong>，<strong>然后服务端发送ACK &#x3D; 1告诉客户端收到你发给我的信息</strong>，此时服务端处于 CLOSE_WAIT 等待关闭状态。（服务端先回应给客户端一声，我知道了，但服务端的发送数据能力即将等待关闭，于是接下来第三次就来了。）</li>
<li><strong>第三次分手</strong>：此时服务端向客户端把所有的数据发送完了，然后发送一个FIN &#x3D; 1，<strong>用于告诉客户端，服务端的所有数据发送完毕</strong>，<strong>客户端你也可以关闭接收数据连接了</strong>。此时服务端状态处于LAST_ACK状态，来等待确认客户端是否收到了自己的请求。（服务端等客户端回复是否收到呢，不收到的话，服务端不知道客户端是不是挂掉了还是咋回事呢，所以服务端不敢关闭自己的接收能力，于是第四次就来了。）</li>
<li><strong>第四次分手</strong>：此时如果客户端收到了服务端发送完的信息之后，就发送ACK &#x3D; 1，告诉服务端，客户端已经收到了你的信息。<strong>有一个 2 MSL 的延迟等待</strong>。</li>
</ul>
<h2 id="62、挥手为什么需要四次？"><a href="#62、挥手为什么需要四次？" class="headerlink" title="62、挥手为什么需要四次？"></a>62、挥手为什么需要四次？</h2><h3 id="第一种回答-4"><a href="#第一种回答-4" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</p>
<h3 id="第二种回答-4"><a href="#第二种回答-4" class="headerlink" title="第二种回答"></a>第二种回答</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h2 id="63、2MSL等待状态？"><a href="#63、2MSL等待状态？" class="headerlink" title="63、2MSL等待状态？"></a>63、2MSL等待状态？</h2><p>TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</p>
<p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p>
<p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p>
<h2 id="64、四次挥手释放连接时，等待2MSL的意义"><a href="#64、四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="64、四次挥手释放连接时，等待2MSL的意义?"></a>64、四次挥手释放连接时，等待2MSL的意义?</h2><blockquote>
<p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
</blockquote>
<p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<h3 id="两个理由"><a href="#两个理由" class="headerlink" title="两个理由"></a>两个理由</h3><ol>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h2 id="65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#65、为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>65、为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><h3 id="第一种回答-5"><a href="#第一种回答-5" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以<strong>TIME_WAIT状态就是用来重发可能丢失的ACK报文</strong>。</p>
<h3 id="第二种回答-5"><a href="#第二种回答-5" class="headerlink" title="第二种回答"></a>第二种回答</h3><p>对应这样一种情况，最后客户端发送的ACK &#x3D; 1给服务端的<strong>过程中丢失</strong>了，服务端没收到，服务端怎么认为的？我已经发送完数据了，怎么客户端没回应我？是不是中途丢失了？然后服务端再次发起断开连接的请求，一个来回就是2MSL。</p>
<p>客户端给服务端发送的ACK &#x3D; 1丢失，<strong>服务端等待 1MSL没收到</strong>，<strong>然后重新发送消息需要1MSL</strong>。如果再次接收到服务端的消息，则<strong>重启2MSL计时器</strong>，<strong>发送确认请求</strong>。客户端只需等待2MSL，如果没有再次收到服务端的消息，就说明服务端已经接收到自己确认消息；此时双方都关闭的连接，TCP 四次分手完毕</p>
<h2 id="66、TCP粘包问题是什么？你会如何去解决它？"><a href="#66、TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="66、TCP粘包问题是什么？你会如何去解决它？"></a>66、TCP粘包问题是什么？你会如何去解决它？</h2><p><strong>TCP粘包</strong>是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<ul>
<li><p>由TCP<strong>连接复用</strong>造成的粘包问题。</p>
</li>
<li><p>因为TCP默认会使用</p>
<p>Nagle算法</p>
<p>，此算法会导致粘包问题。</p>
<ul>
<li>只有上一个分组得到确认，才会发送下一个分组；</li>
<li>收集多个小分组，在一个确认到来时一起发送。</li>
</ul>
</li>
<li><p><strong>数据包过大</strong>造成的粘包问题。</p>
</li>
<li><p>流量控制，<strong>拥塞控制</strong>也可能导致粘包。</p>
</li>
<li><p><strong>接收方不及时接收缓冲区的包，造成多个包接收</strong></p>
</li>
</ul>
<p><strong>解决</strong>：</p>
<ol>
<li><strong>Nagle算法</strong>问题导致的，需要结合应用场景适当关闭该算法</li>
<li>尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li>
<li>头部标记分步接收。在TCP报文的头部加上表示数据长度。</li>
<li>应用层发送数据时<strong>定长</strong>发送。</li>
</ol>
<h2 id="67、OSI七层模型中表示层和会话层功能是什么？"><a href="#67、OSI七层模型中表示层和会话层功能是什么？" class="headerlink" title="67、OSI七层模型中表示层和会话层功能是什么？"></a>67、OSI七层模型中表示层和会话层功能是什么？</h2><ul>
<li>表示层：图像、视频编码解，数据加密。</li>
<li>会话层：建立会话，如session认证、断点续传。</li>
</ul>
<h2 id="68、三次握手四次挥手的变迁图"><a href="#68、三次握手四次挥手的变迁图" class="headerlink" title="68、三次握手四次挥手的变迁图"></a>68、三次握手四次挥手的变迁图</h2><p>《TCP&#x2F;IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220036408.png" alt="img"></p>
<h2 id="69、对称密钥加密的优点缺点？"><a href="#69、对称密钥加密的优点缺点？" class="headerlink" title="69、对称密钥加密的优点缺点？"></a>69、对称密钥加密的优点缺点？</h2><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：无法安全地将密钥传输给通信方</li>
</ul>
<h2 id="70、非对称密钥加密你了解吗？优缺点？"><a href="#70、非对称密钥加密你了解吗？优缺点？" class="headerlink" title="70、非对称密钥加密你了解吗？优缺点？"></a>70、非对称密钥加密你了解吗？优缺点？</h2><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，<strong>通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密</strong>，<strong>接收方收到通信内容后使用私有密钥解密</strong>。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<h2 id="71、HTTPS是什么？"><a href="#71、HTTPS是什么？" class="headerlink" title="71、HTTPS是什么？"></a>71、HTTPS是什么？</h2><p>HTTPS 并不是新协议，而是让 <strong>HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信</strong>。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h2 id="72、HTTP的缺点有哪些？"><a href="#72、HTTP的缺点有哪些？" class="headerlink" title="72、HTTP的缺点有哪些？"></a>72、HTTP的缺点有哪些？</h2><ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<h2 id="73、HTTPS采用的加密方式有哪些？是对称还是非对称？"><a href="#73、HTTPS采用的加密方式有哪些？是对称还是非对称？" class="headerlink" title="73、HTTPS采用的加密方式有哪些？是对称还是非对称？"></a>73、HTTPS采用的加密方式有哪些？是对称还是非对称？</h2><p>HTTPS 采用混合的加密机制，使用<strong>非对称密钥加密用于传输对称密钥来保证传输过程的安全性</strong>，之后使用<strong>对称密钥加密进行通信来保证通信过程的效率</strong>。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220036403.png" alt="img"></p>
<p>确保传输安全过程（其实就是rsa原理）：</p>
<ol>
<li>Client给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>Client确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。</li>
<li>Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。</li>
<li>Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ol>
<h2 id="74、为什么有的时候刷新页面不需要重新建立-SSL-连接？"><a href="#74、为什么有的时候刷新页面不需要重新建立-SSL-连接？" class="headerlink" title="74、为什么有的时候刷新页面不需要重新建立 SSL 连接？"></a>74、为什么有的时候刷新页面不需要重新建立 SSL 连接？</h2><p>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。</p>
<h2 id="75、SSL中的认证中的证书是什么？了解过吗？"><a href="#75、SSL中的认证中的证书是什么？了解过吗？" class="headerlink" title="75、SSL中的认证中的证书是什么？了解过吗？"></a>75、SSL中的认证中的证书是什么？了解过吗？</h2><p>通过使用 证书 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<h2 id="76、HTTP如何禁用缓存？如何确认缓存？"><a href="#76、HTTP如何禁用缓存？如何确认缓存？" class="headerlink" title="76、HTTP如何禁用缓存？如何确认缓存？"></a>76、HTTP如何禁用缓存？如何确认缓存？</h2><p>HTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>强制确认缓存</p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line"> </span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="77、GET与POST传递数据的最大长度能够达到多少呢？"><a href="#77、GET与POST传递数据的最大长度能够达到多少呢？" class="headerlink" title="77、GET与POST传递数据的最大长度能够达到多少呢？"></a>77、GET与POST传递数据的最大长度能够达到多少呢？</h2><p>get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</p>
<p>很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。</p>
<p>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p>
<p>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p>
<p>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。</p>
<p>以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。</p>
<h2 id="78、网络层常见协议？可以说一下吗？"><a href="#78、网络层常见协议？可以说一下吗？" class="headerlink" title="78、网络层常见协议？可以说一下吗？"></a>78、网络层常见协议？可以说一下吗？</h2><table>
<thead>
<tr>
<th>协议</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>IP</td>
<td>网际协议</td>
<td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td>
</tr>
<tr>
<td>ICMP</td>
<td>Internet控制报文协议</td>
<td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td>
</tr>
<tr>
<td>RIP</td>
<td>路由信息协议</td>
<td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td>
</tr>
<tr>
<td>IGMP</td>
<td>Internet组管理协议</td>
<td>用于实现组播、广播等通信</td>
</tr>
</tbody></table>
<h2 id="79、TCP四大拥塞控制算法总结？（极其重要）"><a href="#79、TCP四大拥塞控制算法总结？（极其重要）" class="headerlink" title="79、TCP四大拥塞控制算法总结？（极其重要）"></a>79、TCP四大拥塞控制算法总结？（极其重要）</h2><h3 id="四大算法"><a href="#四大算法" class="headerlink" title="四大算法"></a>四大算法</h3><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220036635.png" alt="img"></p>
<h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h3><p>所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。</p>
<p>慢启动算法：</p>
<ol>
<li>连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd大小加一，呈线性上升。</li>
<li>每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;&#x3D; ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li>
</ol>
<h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h3><p>如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：</p>
<ol>
<li>收到一个ACK，则cwnd &#x3D; cwnd + 1 &#x2F; cwnd</li>
<li>每当过了一个往返延迟时间RTT，cwnd大小加一。</li>
</ol>
<p>过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。</p>
<h3 id="拥塞发生状态时的算法"><a href="#拥塞发生状态时的算法" class="headerlink" title="拥塞发生状态时的算法"></a>拥塞发生状态时的算法</h3><p>一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。</p>
<p>超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p>
<p>但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫 做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。</p>
<p>超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：</p>
<ul>
<li>由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh &#x3D; cwnd &#x2F; 2.</li>
<li>cwnd重置为1</li>
<li>进入慢启动过程</li>
</ul>
<p>最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。</p>
<p>所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：</p>
<ul>
<li>cwnd大小缩小为当前的一半</li>
<li>ssthresh设置为缩小后的cwnd大小</li>
<li>然后进入快速恢复算法Fast Recovery。</li>
</ul>
<p><img src="http://oss.interviewguide.cn/img/202205220036573.png" alt="img"></p>
<h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h3><p>TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：</p>
<ul>
<li><p>cwnd &#x3D; cwnd + 3 <em>MSS，加3</em> MSS的原因是因为收到3个重复的ACK。</p>
</li>
<li><p>重传DACKs指定的数据包。</p>
</li>
<li><p>如果再收到DACKs，那么cwnd大小增加一。</p>
</li>
<li><p>如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。</p>
<p><img src="http://oss.interviewguide.cn/img/202205220036984.png" alt="img"></p>
</li>
</ul>
<p>如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6&#x2F;2 &#x3D; 3，cwnd设置为3 + 3 &#x3D; 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。</p>
<h2 id="80、为何快速重传是选择3次ACK？"><a href="#80、为何快速重传是选择3次ACK？" class="headerlink" title="80、为何快速重传是选择3次ACK？"></a>80、为何快速重传是选择3次ACK？</h2><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p>
<p>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p>
<p>在没有fast retransmit &#x2F; recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因</p>
<p>1）包checksum 出错</p>
<p>2）网络拥塞</p>
<p>3）网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1&#x2F;2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。</p>
<p>于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到&gt; 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；</p>
<p>而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。</p>
<p>而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。</p>
<h2 id="81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少"><a href="#81、对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少" class="headerlink" title="81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?"></a>81、对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2><ul>
<li>FIN_WAIT_2：<ul>
<li>半关闭状态。</li>
<li>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</li>
</ul>
</li>
<li>CLOSE_WAIT状态：<ul>
<li>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</li>
<li>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</li>
</ul>
</li>
<li>TIME_WAIT状态：<ul>
<li>又叫2MSL等待状态。</li>
<li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li>
<li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li>
</ul>
</li>
</ul>
<h2 id="82、你了解流量控制原理吗？"><a href="#82、你了解流量控制原理吗？" class="headerlink" title="82、你了解流量控制原理吗？"></a>82、你了解流量控制原理吗？</h2><ul>
<li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
</ul>
</li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 &#x3D; 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 &#x3D; 未接收但准备接收部分。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
<h2 id="83、建立TCP服务器的各个系统调用过程是怎样的？"><a href="#83、建立TCP服务器的各个系统调用过程是怎样的？" class="headerlink" title="83、建立TCP服务器的各个系统调用过程是怎样的？"></a>83、建立TCP服务器的各个系统调用过程是怎样的？</h2><p><img src="http://oss.interviewguide.cn/img/202205220023934.png" alt="img"></p>
<p><img src="http://oss.interviewguide.cn/img/202205220023348.png" alt="img"></p>
<ul>
<li><p>服务器：</p>
<ul>
<li><p>创建socket -&gt; int socket(int domain, int type, int protocol);</p>
<ul>
<li>domain：协议域，决定了socket的地址类型，IPv4为AF_INET。</li>
<li>type：指定socket类型，SOCK_STREAM为TCP连接。</li>
<li>protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。</li>
</ul>
</li>
<li><p>绑定socket和端口号 -&gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</p>
<ul>
<li>sockfd：socket返回的套接字描述符，类似于文件描述符fd。</li>
<li>addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// IPv4的sockaddr地址结构</span><br><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t sin_family;    // 协议类型，AF_INET</span><br><span class="line">    in_port_t sin_port;    // 端口号</span><br><span class="line">    struct in_addr sin_addr;    // IP地址</span><br><span class="line">&#125;;</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t s_addr;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>addrlen：地址长度。</li>
</ul>
</li>
<li><p>监听端口号 -&gt; int listen(int sockfd, int backlog);</p>
<ul>
<li>sockfd：要监听的sock描述字。</li>
<li>backlog：socket可以排队的最大连接数。</li>
</ul>
</li>
<li><p>接收用户请求 -&gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<ul>
<li>sockfd：服务器socket描述字。</li>
<li>addr：指向地址结构指针。</li>
<li>addrlen：协议地址长度。</li>
<li>注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。</li>
</ul>
</li>
<li><p>从socket中读取字符 -&gt; ssize_t read(int fd, void *buf, size_t count);</p>
<ul>
<li>fd：连接描述字。</li>
<li>buf：缓冲区buf。</li>
<li>count：缓冲区长度。</li>
<li>注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。</li>
</ul>
</li>
<li><p>关闭socket -&gt; int close(int fd);</p>
<ul>
<li>fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。</li>
<li>注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>客户机：</p>
<ul>
<li>创建socket -&gt; int socket(int domain, int type, int protocol);</li>
<li>连接指定计算机 -&gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<ul>
<li>sockfd客户端的sock描述字。</li>
<li>addr：服务器的地址。</li>
<li>addrlen：socket地址长度。</li>
</ul>
</li>
<li>向socket写入信息 -&gt; ssize_t write(int fd, const void *buf, size_t count);<ul>
<li>fd、buf、count：同read中意义。</li>
<li>大于0表示写了部分或全部数据，小于0表示出错。</li>
</ul>
</li>
<li>关闭oscket -&gt; int close(int fd);<ul>
<li>fd：同服务器端fd。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="84、TCP-协议如何保证可靠传输？"><a href="#84、TCP-协议如何保证可靠传输？" class="headerlink" title="84、TCP 协议如何保证可靠传输？"></a>84、TCP 协议如何保证可靠传输？</h2><h3 id="第一种回答-6"><a href="#第一种回答-6" class="headerlink" title="第一种回答"></a>第一种回答</h3><ul>
<li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li>
<li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li>
<li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li>
<li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li>
</ul>
<h3 id="第二种回答-6"><a href="#第二种回答-6" class="headerlink" title="第二种回答"></a>第二种回答</h3><ul>
<li>建立连接（标志位）：通信前确认通信实体存在。</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li>
<li>数据校验（校验和）：CRC校验全部数据。</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li>
<li>窗口机制（窗口）：提供流量控制，避免过量发送。</li>
<li>拥塞控制：同上。</li>
</ul>
<h3 id="第三种回答"><a href="#第三种回答" class="headerlink" title="第三种回答"></a>第三种回答</h3><p><strong>首部校验</strong> 这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p>
<p><strong>原因</strong></p>
<p>TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。</p>
<p>这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？<strong>显然不能</strong>。</p>
<p>因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B&#x3D;B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。</p>
<p><strong>解决方案</strong></p>
<p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题</p>
<h2 id="85、UDP是什么？"><a href="#85、UDP是什么？" class="headerlink" title="85、UDP是什么？"></a>85、UDP是什么？</h2><p>提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</p>
<h2 id="86、TCP和UDP的区别"><a href="#86、TCP和UDP的区别" class="headerlink" title="86、TCP和UDP的区别"></a>86、TCP和UDP的区别</h2><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p>
<p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p>
<p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</p>
<p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<p>7、UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p>
<p>TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p>
<h2 id="补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？"><a href="#补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？" class="headerlink" title="补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？"></a>补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2><p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h2 id="87、UDP的特点有哪些（附赠TCP的特点）？"><a href="#87、UDP的特点有哪些（附赠TCP的特点）？" class="headerlink" title="87、UDP的特点有哪些（附赠TCP的特点）？"></a>87、UDP的特点有哪些（附赠TCP的特点）？</h2><ul>
<li>UDP是<strong>无连接的</strong>；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是<strong>面向报文</strong>的；</li>
<li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<p>那么，再说一次TCP的特点：</p>
<ul>
<li><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</li>
<li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ul>
<h2 id="88、TCP对应的应用层协议"><a href="#88、TCP对应的应用层协议" class="headerlink" title="88、TCP对应的应用层协议"></a>88、TCP对应的应用层协议</h2><p>FTP：定义了文件传输协议，使用21端口. Telnet：它是一种用于远程登陆的端口,23端口 SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。</p>
<h2 id="89、UDP对应的应用层协议"><a href="#89、UDP对应的应用层协议" class="headerlink" title="89、UDP对应的应用层协议"></a>89、UDP对应的应用层协议</h2><p>DNS：用于域名解析服务，用的是53号端口 SNMP：简单网络管理协议，使用161号端口 TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</p>
<h2 id="90、数据链路层常见协议？可以说一下吗？"><a href="#90、数据链路层常见协议？可以说一下吗？" class="headerlink" title="90、数据链路层常见协议？可以说一下吗？"></a>90、数据链路层常见协议？可以说一下吗？</h2><table>
<thead>
<tr>
<th>协议</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ARP</td>
<td>地址解析协议</td>
<td>根据IP地址获取物理地址</td>
</tr>
<tr>
<td>RARP</td>
<td>反向地址转换协议</td>
<td>根据物理地址获取IP地址</td>
</tr>
<tr>
<td>PPP</td>
<td>点对点协议</td>
<td>主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</td>
</tr>
</tbody></table>
<h2 id="91、Ping命令基于什么协议？原理是什么？"><a href="#91、Ping命令基于什么协议？原理是什么？" class="headerlink" title="91、Ping命令基于什么协议？原理是什么？"></a>91、Ping命令基于什么协议？原理是什么？</h2><p>ping是基于网络层的ICMP协议实现的。通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。</p>
<p>扩展：ICMP报文的介绍。ICMP报文分为两个种类：</p>
<ol>
<li>ICMP差错报告报文，常见的有<ol>
<li>终点不可达</li>
<li>时间超过</li>
<li>参数问题</li>
<li>改变路由</li>
</ol>
</li>
<li>ICMP询问报文<ol>
<li>回送请求和回答：向特定主机发出<strong>回送请求报文</strong>，收到回送请求报文的主机响应<strong>回送回答报文</strong>。</li>
<li>时间戳请求和回答：询问对方当前的时间，返回的是一个32位的时间戳。</li>
</ol>
</li>
</ol>
<h2 id="92、在进行UDP编程的时候，一次发送多少bytes好"><a href="#92、在进行UDP编程的时候，一次发送多少bytes好" class="headerlink" title="92、在进行UDP编程的时候，一次发送多少bytes好?"></a>92、在进行UDP编程的时候，一次发送多少bytes好?</h2><p>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。</p>
<p>我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP&#x2F;IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,</p>
<p>下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.</p>
<p>所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。</p>
<p>当我们发送的UDP数据大于1472的时候会怎样呢？ 这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation). 把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组. 这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便 无法重组数据报.将导致丢弃整个UDP数据报。</p>
<p>因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.</p>
<p>进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值. 如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机 制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.</p>
<p>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时. 最好将UDP的数据长度控件在548字节(576-8-20)以内</p>
<h2 id="93、TCP-利用滑动窗口实现流量控制的机制？"><a href="#93、TCP-利用滑动窗口实现流量控制的机制？" class="headerlink" title="93、TCP 利用滑动窗口实现流量控制的机制？"></a>93、TCP 利用滑动窗口实现流量控制的机制？</h2><blockquote>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p>
</blockquote>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</p>
<blockquote>
<p>例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
</blockquote>
<h2 id="94、可以解释一下RTO，RTT和超时重传分别是什么吗？"><a href="#94、可以解释一下RTO，RTT和超时重传分别是什么吗？" class="headerlink" title="94、可以解释一下RTO，RTT和超时重传分别是什么吗？"></a>94、可以解释一下RTO，RTT和超时重传分别是什么吗？</h2><ul>
<li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul>
<li>发送的数据没能到达接收端，所以对方没有响应。</li>
<li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li>
<li>接收端拒绝或丢弃数据。</li>
</ul>
</li>
<li>RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<ul>
<li>通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……</li>
<li>重传次数到达上限之后停止重传。</li>
</ul>
</li>
<li>RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。</li>
</ul>
<h2 id="95、XSS攻击是什么？（低频）"><a href="#95、XSS攻击是什么？（低频）" class="headerlink" title="95、XSS攻击是什么？（低频）"></a>95、XSS攻击是什么？（低频）</h2><p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击 1）前端，服务端，同时需要字符串输入的长度限制。 2）前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。 防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h2 id="96、CSRF攻击？你知道吗？"><a href="#96、CSRF攻击？你知道吗？" class="headerlink" title="96、CSRF攻击？你知道吗？"></a>96、CSRF攻击？你知道吗？</h2><p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</p>
<h2 id="97、如何防范CSRF攻击"><a href="#97、如何防范CSRF攻击" class="headerlink" title="97、如何防范CSRF攻击"></a>97、如何防范CSRF攻击</h2><p><strong>安全框架</strong>，例如Spring Security。 <strong>token机制</strong>。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。 <strong>验证码</strong>。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。 <strong>referer识别</strong>。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。 1）验证请求来源地址； 2）关键操作添加验证码； 3）在请求地址添加 token 并验证。</p>
<h2 id="98、文件上传漏洞是如何发生的？你有经历过吗？"><a href="#98、文件上传漏洞是如何发生的？你有经历过吗？" class="headerlink" title="98、文件上传漏洞是如何发生的？你有经历过吗？"></a>98、文件上传漏洞是如何发生的？你有经历过吗？</h2><p>文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。 许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。</p>
<h2 id="99、如何防范文件上传漏洞"><a href="#99、如何防范文件上传漏洞" class="headerlink" title="99、如何防范文件上传漏洞"></a>99、如何防范文件上传漏洞</h2><p>文件上传的目录设置为不可执行。</p>
<p>1）判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</p>
<p>2）对上传的文件类型进行白名单校验，只允许上传可靠类型。</p>
<p>3）上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。</p>
<p>4）限制上传文件的大小。</p>
<p>5）单独设置文件服务器的域名。</p>
<h2 id="100、拥塞控制原理听说过吗？"><a href="#100、拥塞控制原理听说过吗？" class="headerlink" title="100、拥塞控制原理听说过吗？"></a>100、拥塞控制原理听说过吗？</h2><ul>
<li>拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li>
<li>TCP拥塞控制算法：<ul>
<li>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行增加，这个过程为拥塞避免。</li>
<li>快速重传 &amp; 快速恢复：略。</li>
<li>最终拥塞窗口会收敛于稳定值。</li>
</ul>
</li>
</ul>
<h2 id="101、如何区分流量控制和拥塞控制？"><a href="#101、如何区分流量控制和拥塞控制？" class="headerlink" title="101、如何区分流量控制和拥塞控制？"></a>101、如何区分流量控制和拥塞控制？</h2><ul>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</li>
</ul>
<h2 id="102、常见的HTTP状态码有哪些？"><a href="#102、常见的HTTP状态码有哪些？" class="headerlink" title="102、常见的HTTP状态码有哪些？"></a>102、常见的HTTP状态码有哪些？</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出</td>
</tr>
</tbody></table>
<h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx 信息"></a>1xx 信息</h2><p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h2><ul>
<li>200 OK</li>
<li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h2><ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向</li>
<li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h2><ul>
<li>400 Bad Request ：请求报文中存在语法错误。</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden ：请求被拒绝。</li>
<li>404 Not Found</li>
</ul>
<h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h2><ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h2 id="103、服务器出现大量close-wait的连接的原因是什么？有什么解决方法？"><a href="#103、服务器出现大量close-wait的连接的原因是什么？有什么解决方法？" class="headerlink" title="103、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？"></a>103、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h2><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h2 id="104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"><a href="#104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？" class="headerlink" title="104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"></a>104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？</h2><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
]]></content>
      <categories>
        <category>八股</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
