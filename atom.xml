<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wave Blog</title>
  
  <subtitle>BETTER AND BETTER</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-10T18:30:24.439Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wave</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://example.com/2023/08/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/08/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-10T16:00:00.000Z</published>
    <updated>2023-08-10T18:30:24.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/bubbleSort.gif" alt="img"></p><h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</p><h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</p><h3 id="5-C-代码实现"><a href="#5-C-代码实现" class="headerlink" title="5. C++ 代码实现"></a>5. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n²)空间复杂度O(1)</p><hr><h2 id="1-2-选择排序"><a href="#1-2-选择排序" class="headerlink" title="1.2 选择排序"></a>1.2 选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><p>注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p><h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/selectionSort.gif" alt="img"></p><h3 id="3-C-代码实现"><a href="#3-C-代码实现" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; L[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-3-插入排序"><a href="#1-3-插入排序" class="headerlink" title="1.3 插入排序"></a>1.3 插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h3 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h3 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/insertionSort.gif" alt="img"></p><h3 id="3-C-代码实现-1"><a href="#3-C-代码实现-1" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><blockquote><p>while循环版</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循环版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123; <span class="comment">//0 ~ i 做到有序</span></span><br><span class="line"><span class="type">int</span> key = arr[i]; <span class="comment">//哨兵位</span></span><br><span class="line">        <span class="type">int</span> p = i ;</span><br><span class="line"><span class="keyword">while</span>((p &gt; <span class="number">0</span>) &amp;&amp; (arr[p<span class="number">-1</span>] &gt; key))&#123;</span><br><span class="line">            arr[p] = arr[p<span class="number">-1</span>];</span><br><span class="line">        p = p - <span class="number">1</span>; <span class="comment">//往左移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[p] = key; <span class="comment">//把哨兵插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>for循环版</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i <span class="number">-1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j+<span class="number">1</span>]; j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(j, j+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-4-希尔排序"><a href="#1-4-希尔排序" class="headerlink" title="1.4 希尔排序"></a>1.4 希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h3 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p>数组由{7,3,1,9,5,4,2,8,6) 这9个无序元素组成</p><p>第一次:gap &#x3D; 9&#x2F;2 &#x3D; 4 动画:</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/Shell_Sort1.webp" alt="Shell_Sort1"></p><p>第二次:gap &#x3D; 4&#x2F;2 &#x3D; 2 动画:</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/Shell_Sort2.webp" alt="Shell_Sort2"></p><p>第三次:gap &#x3D; 2&#x2F;2 &#x3D; 1 动画:</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/Shell_Sort3.webp" alt="Shell_Sort3"></p><h3 id="3-C-代码实现-2"><a href="#3-C-代码实现-2" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//初始增量：n/2， 每一趟之后除以2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">//每一趟采用插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++)&#123; <span class="comment">//往右移动</span></span><br><span class="line"><span class="type">int</span> key = arr[i]; <span class="comment">//哨兵位</span></span><br><span class="line">        <span class="type">int</span> p = i;</span><br><span class="line"><span class="keyword">while</span>((p &gt; <span class="number">0</span>) &amp;&amp; (arr[p-gap] &gt; key))&#123;</span><br><span class="line">           arr[p] = arr[p-gap];</span><br><span class="line">        p = p - gap; <span class="comment">//往左移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[p] = key; <span class="comment">//把哨兵插入到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先写一遍插入排序，然后写希尔排序的for循环，然后把插入排序放进去，插入排序相当于间隔是1，把间隔改成gap</span></span><br></pre></td></tr></table></figure><hr><h2 id="1-5-归并排序⭐"><a href="#1-5-归并排序⭐" class="headerlink" title="1.5 归并排序⭐"></a>1.5 归并排序⭐</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="2-图片演示"><a href="#2-图片演示" class="headerlink" title="2. 图片演示"></a>2. 图片演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/3a8fbf58c8dbfab5f3b0997849be76a.jpg" alt="3a8fbf58c8dbfab5f3b0997849be76a"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1024555-20161218194508761-468169540.png" alt="img"></p><h3 id="3-C-代码实现-3"><a href="#3-C-代码实现-3" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; <span class="comment">//让arr在left到right上有序</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123; <span class="comment">//left = right只有一个数自然有序，返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//求中点</span></span><br><span class="line"><span class="built_in">MergeSort</span>(arr, left, mid); <span class="comment">//递归划分左半区</span></span><br><span class="line"><span class="built_in">MergeSort</span>(arr, mid + <span class="number">1</span>, right); <span class="comment">//递归划分右半区</span></span><br><span class="line"><span class="built_in">Merge</span>(arr, left, mid, right); <span class="comment">//合并已经排序的部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right-left+<span class="number">1</span>)</span></span>; <span class="comment">//临时数组，right到left上的数</span></span><br><span class="line">    <span class="type">int</span> leftInPos = left; <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line"><span class="type">int</span> rightPos = mid + <span class="number">1</span>; <span class="comment">//标记右半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> tempPos = <span class="number">0</span>; <span class="comment">//临时数组元素的下标</span></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="keyword">while</span> (leftInPos &lt;= mid &amp;&amp; rightPos &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[leftInPos] &lt;= arr[rightPos])&#123; <span class="comment">//左半区第一个剩余元素更小</span></span><br><span class="line">temp[tempPos++] = arr[leftInPos++];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">//右半区第一个剩余元素更小</span></span><br><span class="line">temp[tempPos++] = arr[rightPos++];</span><br><span class="line">&#125;</span><br><span class="line">&#125; ⭐<span class="comment">//用三元运算符写：temp[i++] = arr[leftInPos] &lt;= arr[rightPos] ? arr[leftInPos++] : arr[rightPos++];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并左半区剩余元素</span></span><br><span class="line"><span class="keyword">while</span> (leftInPos &lt;= mid) &#123;</span><br><span class="line">temp[tempPos++] = arr[leftInPos++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//合并右半区剩余元素</span></span><br><span class="line"><span class="keyword">while</span> (rightPos &lt;= right) &#123;</span><br><span class="line">temp[tempPos++] = arr[rightPos++];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//把临时数组中合并后的元素复制回原来的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">arr[left + i] = temp[i]; <span class="comment">//L+i因为在left到right的范围上Merge</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-6-快速排序"><a href="#1-6-快速排序" class="headerlink" title="1.6 快速排序"></a>1.6 快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然最坏运行情况的时间复杂度达到了 O(n²)，但是在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，原因如下：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><h3 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h3 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/quicksort.gif" alt="quicksort"></p><h3 id="3-C-代码实现-4"><a href="#3-C-代码实现-4" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//递归结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left]; <span class="comment">//将数组的第一个元素作为pivot寻找它的位置</span></span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">     <span class="comment">//从最右往左找到第一个小于p的位置right</span></span><br><span class="line">     <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">       j--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//从最左往右找到第一个大于p的位置left</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">if</span>(i &lt; j)&#123; <span class="comment">//指针没越界</span></span><br><span class="line">         <span class="built_in">swap</span>(i, j);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//left和right相遇，说明p的左边的数都小于等于p;右边都大于等于p。交换基数和相遇位置的数</span></span><br><span class="line"><span class="built_in">swap</span>(i, left);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, left, i - <span class="number">1</span>);<span class="comment">// &lt; 区</span></span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, i + <span class="number">1</span>, right);<span class="comment">// &gt; 区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>严蔚敏《数据结构》标准分割函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Paritition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = arrlow];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">//low和high重合中间没有元素退出循环</span></span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     arr[low] = arr[high]; <span class="comment">//后面搬一个小的到前面</span></span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     arr[high] = arr[low]; <span class="comment">//前面搬一个大的到后面</span></span><br><span class="line">   &#125;</span><br><span class="line">   arr[low] = pivot; <span class="comment">//low的位置也是high的位置，把哨兵拿到中心点指针重合的位置，左边比它小，右边比它大。</span></span><br><span class="line">   <span class="keyword">return</span> low;<span class="comment">//返回low的值，中心点元素所在的下标，获得中心点的位置把表继续往下分开，然后递归。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span></span>&#123; <span class="comment">//快排母函数</span></span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition</span>(arr, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(arr, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(arr, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-7-堆排序"><a href="#1-7-堆排序" class="headerlink" title="1.7 堆排序"></a>1.7 堆排序</h2><p>堆排序实际上是利用堆的性质来进行排序的，要知道堆排序的原理我们首先一定要知道什么是堆。<br>堆的定义：<br>堆实际上是一棵完全二叉树。<br>堆满足两个性质: </p><ul><li><p>堆的每一个父节点都大于（或小于）其子节点； </p></li><li><p>堆的每个左子树和右子树也是一个堆。</p></li></ul><p>堆的分类： 堆分为两类： </p><ul><li><p>大根堆（大顶堆）：堆的每个父节点都大于其孩子节点； </p></li><li><p>小根堆（小顶堆）：堆的每个父节点都小于其孩子节点；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808082128983.png" alt="image-20230808082128983"></p><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h3 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>堆的存储：<br>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) &#x2F; 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如下图所示： </p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808082628218.png" alt="image-20230808082628218"></p><p>堆排序： </p><p>由上面的介绍我们可以看出堆的第一个元素要么是大根堆，要么是小根堆，这样在排序的时候（假设共n个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第n-1个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆。 </p><p>堆排序的步骤分为三步: </p><ol><li>建堆（升序建大堆，降序建小堆）； </li><li>交换数据； </li><li>向下调整。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808083131416.png" alt="image-20230808083131416"></p><h3 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/heapSort.gif" alt="img"></p><h3 id="3-C-代码实现-5"><a href="#3-C-代码实现-5" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index, <span class="type">int</span> heapsize)</span> </span>&#123; <span class="comment">//heapsize管数组大小</span></span><br><span class="line">    <span class="type">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapsize) &#123; <span class="comment">//左下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">//两个孩子中谁的值大，把下标给largest</span></span><br><span class="line">        <span class="type">int</span> largest = left + <span class="number">1</span> &lt; heapsize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">//父节点和较大孩子中谁的值大，把下标给largest</span></span><br><span class="line"><span class="type">int</span> largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span>(largest == index)&#123;<span class="comment">//父节点是最大值，不用往下走了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//否则较大的孩子比父亲大</span></span><br><span class="line">            <span class="built_in">swap</span>(largest, index]); <span class="comment">//交换较大的孩子largest和父节点index</span></span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>; / 新的左孩子</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个节点开始调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, arr.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//while循环版</span></span><br><span class="line">    <span class="type">int</span> heapsize = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">swap</span>(arr[<span class="number">0</span>], --heapsize); <span class="comment">//0位置的数和堆上最后一个位置的数交换，交换完成后堆大小--</span></span><br><span class="line">    <span class="keyword">while</span>(heapsize &gt; <span class="number">0</span>)&#123; <span class="comment">//直到堆的大小为0</span></span><br><span class="line">    <span class="built_in">heapify</span>(arr, i, arr.<span class="built_in">size</span>())； </span><br><span class="line">        <span class="built_in">swap</span>(<span class="number">0</span>, --heapsize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环版</span></span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-8-计数排序"><a href="#1-8-计数排序" class="headerlink" title="1.8 计数排序"></a>1.8 计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><ol><li>计数排序的特征</li></ol><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><h3 id="1-算法步骤-7"><a href="#1-算法步骤-7" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><p>算法的步骤如下：</p><ol><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ol><h3 id="2-动图演示-6"><a href="#2-动图演示-6" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/countingSort.gif" alt="img"></p><h3 id="3-C-代码实现-6"><a href="#3-C-代码实现-6" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配一个长度为最大值+1的数组存储计数，并初始化为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(maxVal + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cnt[arr[i]]++; <span class="comment">//每个数出现了多少次，再以这个数为下标值记录在新数组中（计数数组）</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt[i])&#123;</span><br><span class="line">            arr[k++] = i; <span class="comment">//每有一个i这个数，放入arr数组中，把下标往后移一位</span></span><br><span class="line">            cnt[i]--; <span class="comment">//每写一个把这个数--，直到用完为止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-9-基数排序"><a href="#1-9-基数排序" class="headerlink" title="1.9 基数排序"></a>1.9 基数排序</h2><p>基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。<br>排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="2-动图演示-7"><a href="#2-动图演示-7" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/radixSort.gif" alt="radixSort"></p><h3 id="3-C-代码实现-7"><a href="#3-C-代码实现-7" class="headerlink" title="3. C++ 代码实现"></a>3. C++ 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        x /=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> x % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//数有3位数，最多排3次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">            cnt[j].<span class="built_in">clear</span>(); <span class="comment">//每次循环前把每个cnt清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123; <span class="comment">//第一次按个位排序</span></span><br><span class="line">            <span class="comment">//每次按照第i位数字，依次放入桶中</span></span><br><span class="line">            cnt[<span class="built_in">get</span>(arr[j], i)].<span class="built_in">push_back</span>(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, k = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)&#123; <span class="comment">//0~9个数值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x : cnt[j])&#123; <span class="comment">//按顺序遍历数组里的元素</span></span><br><span class="line">                q[k++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-1-冒泡排序&quot;&gt;&lt;a href=&quot;#1-1-冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;1.1 冒泡排序&quot;&gt;&lt;/a&gt;1.1 冒泡排序&lt;/h2&gt;&lt;p&gt;冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Shell</title>
    <link href="http://example.com/2023/08/10/Shell/"/>
    <id>http://example.com/2023/08/10/Shell/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2023-08-30T18:16:37.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h1><p>shell是一个命令行解释器，它接收应用程序&#x2F;用户命令，然后调用操作系统内核。</p><p>shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性强</p><hr><h1 id="Shell脚本入门"><a href="#Shell脚本入门" class="headerlink" title="Shell脚本入门"></a>Shell脚本入门</h1><p><strong>1）脚本格式</strong></p><p>脚本以<font color=Red>#!&#x2F;bin&#x2F;bash</font>开头（指定解析器）</p><p><strong>2）第一个 Shell 脚本：helloworld.sh</strong></p><p>（1）需求：创建一个 Shell 脚本，输出 helloworld</p><p>（2）案例实操：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch helloworld.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.sh</span><br><span class="line"></span><br><span class="line">在 helloworld.sh 中输入如下内容</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld</span><br></pre></td></tr></table></figure><p>（3）脚本的常用执行方式</p><p>​第一种：采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限)</p><p>​sh+脚本的相对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​sh+脚本的绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sh /home/atguigu/shells/helloworld.sh</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>​bash+脚本的相对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​bash+脚本的绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash /home/atguigu/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​第二种：采用输入脚本的绝对路径或相对路径执行脚本<font color=Red>（必须具有可执行权限+x）</font></p><p>​①首先要赋予 helloworld.sh 脚本的+x 权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ chmod +x helloworld.sh</span><br></pre></td></tr></table></figure><p>​②执行脚本</p><p>​相对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ /home/atguigu/shells/helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​注意：第一种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执行 权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。</p><p>​【了解】第三种：在脚本的路径前加上“.”或者 source</p><p>​①有以下脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat test.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=5</span><br><span class="line">echo $A</span><br></pre></td></tr></table></figure><p>​②分别使用 sh，bash，.&#x2F; 和 . 的方式来执行，结果如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ bash test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ sh test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ ./test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">[atguigu@hadoop101 shells]$ . test.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​原因： </p><p>​前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则 子 shell 关闭，回到父 shell 中。</p><p>​第三种，也就是使用在脚本路径前加“.”或者 source 的方式，可以使脚本内容在当前 shell 里执行，而无需打开子 shell！这也是为什么我们每次要修改完&#x2F;etc&#x2F;profile 文件以后，需 要 source 一下的原因。 </p><p>​开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的 当前变量，父 shell 是不可见的。</p><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h3 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h3><p><strong>1）常用系统变量</strong></p><p>​$HOME、$PWD、$SHELL、$USER 等</p><p><strong>2）案例实操</strong></p><p>（1）查看系统变量的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $HOME</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><p>（2）显示当前 Shell 中所有变量：set</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ set</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p><strong>1）基本语法</strong></p><p>​（1）定义变量：变量名&#x3D;变量值， <font color=Red>注意，&#x3D;号前后不能有空格</font></p><p>​（2）撤销变量：unset 变量名</p><p>​（3）声明静态变量：readonly 变量，注意：不能 unset</p><p><strong>2）变量定义规则</strong></p><p>​（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头， <font color=Red>环境变量名建议大写</font>。</p><p>​（2）等号两侧不能有空格。</p><p>​（3）在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。 </p><p>​（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><p><strong>3）案例实操</strong></p><p>​（1）定义变量 A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=5</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​（2）给变量 A 重新赋值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ A=8</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>​（3）撤销变量 A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ unset A</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $A</span><br></pre></td></tr></table></figure><p>​（4）声明静态的变量 B&#x3D;2，不能 unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ readonly B=2</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $B</span><br><span class="line">2</span><br><span class="line">[atguigu@hadoop101 shells]$ B=9</span><br><span class="line">-bash: B: readonly variable</span><br></pre></td></tr></table></figure><p>​（5）在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ C=1+2</span><br><span class="line">[atguigu@hadoop102 ~]$ echo $C</span><br><span class="line">1+2</span><br></pre></td></tr></table></figure><p>​（6）变量的值如果有空格，需要使用双引号或单引号括起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 ~]$ D=I love banzhang</span><br><span class="line">-bash: world: command not found</span><br><span class="line">[atguigu@hadoop102 ~]$ D=&quot;I love banzhang&quot;</span><br><span class="line">[atguigu@hadoop102 ~]$ echo $D</span><br><span class="line">I love banzhang</span><br></pre></td></tr></table></figure><p>​（7）可把变量提升为全局环境变量，可供其他 Shell 程序使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export 变量名</span><br><span class="line">[atguigu@hadoop101 shells]$ vim helloworld.sh</span><br></pre></td></tr></table></figure><p>​在 helloworld.sh 文件中增加echo $B</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;helloworld&quot;</span><br><span class="line">echo $B</span><br><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>​发现并没有打印输出变量 B 的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ export B</span><br><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">helloworld</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><h4 id="n"><a href="#n" class="headerlink" title="$n"></a>$n</h4><p><strong>1）基本语法</strong></p><p>​$n （功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}） </p><p><strong>2）案例实操</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls</span><br><span class="line">xz</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="$#"></a>$#</h4><p><strong>1）基本语法</strong></p><p>​$#（功能描述：获取所有 <font color=Red>输入参数个数</font>，常用于循环,判断参数的个数是否正确以及 加强脚本的健壮性）。</p><p><strong>2）案例实操</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27;</span><br><span class="line">echo $#</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 parameter.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh cls xz</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">cls</span><br><span class="line">xz</span><br><span class="line">==========$#==========</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="、"><a href="#、" class="headerlink" title="$*、$@"></a>$*、$@</h4><p><strong>1）基本语法</strong></p><p>​$* （功能描述：这个变量代表命令行中所有的参数，<font color=Red>$*把所有的参数看成一个整体</font>）</p><p> $@ （功能描述：这个变量也代表命令行中所有的参数，不过<font color=Red>$@把每个参数区分对待</font>）</p><p><strong>2）案例实操</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim parameter.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;==========$n==========&#x27;</span><br><span class="line">echo $0</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">echo &#x27;==========$#==========&#x27;</span><br><span class="line">echo $#</span><br><span class="line">echo &#x27;==========$*==========&#x27;</span><br><span class="line">echo $*</span><br><span class="line">echo &#x27;==========$@==========&#x27;</span><br><span class="line">echo $@</span><br><span class="line">[atguigu@hadoop101 shells]$ ./parameter.sh a b c d e f g</span><br><span class="line">==========$n==========</span><br><span class="line">./parameter.sh</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">==========$#==========</span><br><span class="line">7</span><br><span class="line">==========$*==========</span><br><span class="line">a b c d e f g</span><br><span class="line">==========$@==========</span><br><span class="line">a b c d e f g</span><br></pre></td></tr></table></figure><h4 id="？"><a href="#？" class="headerlink" title="$？"></a>$？</h4><p><strong>1）基本语法</strong></p><p>​$？ （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明 上一个命令执行不正确了。）</p><p><strong>2）案例实操</strong></p><p>​判断 helloworld.sh 脚本是否正确执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ./helloworld.sh</span><br><span class="line">hello world</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><hr><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>1）基本语法</strong></p><p>​“$((运算式))” 或 “$[运算式]”</p><p><strong>2）案例实操</strong></p><p>​计算（2+3）* 4 的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]# S=$[(2+3)*4]</span><br><span class="line">[atguigu@hadoop101 shells]# echo $S</span><br></pre></td></tr></table></figure><hr><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p><strong>1）基本语法</strong></p><p>​（1）test condition </p><p>​（2）[ condition ]（<font color=Red>注意 condition 前后要有空格</font>)</p><p>​ 注意：条件非空即为 true，[ atguigu ]返回 true，[   ]返回 false.</p><p><strong>2）常用条件判断</strong></p><p>​（1）两个整数之间比较 </p><p>​-eq 等于（equal）</p><p>​-ne 不等于（not equal） </p><p>​-lt 小于（less than） </p><p>​-le 小于等于（less equal）</p><p>​ -gt 大于（greater than） </p><p>​-ge 大于等于（greater equal） </p><p>​注：如果是字符串之间的比较 ，用等号“&#x3D;”判断相等；用“!&#x3D;”判断不等。 </p><p>​（2）按照文件权限进行判断</p><p>​-r 有读的权限（read）</p><p>​-w 有写的权限（write） </p><p>​-x 有执行的权限（execute） </p><p>​（3）按照文件类型进行判断 </p><p>​-e 文件存在（existence） </p><p>​-f 文件存在并且是一个常规的文件（file）</p><p>​-d 文件存在并且是一个目录（directory）</p><p><strong>3）案例实操</strong></p><p>（1）23 是否大于等于 22</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ 23 -ge 22 ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（2）helloworld.sh 是否具有写权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -w helloworld.sh ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（3）&#x2F;home&#x2F;atguigu&#x2F;cls.txt 目录中的文件是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ [ -e /home/atguigu/cls.txt ]</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一 条命令执行失败后，才执行下一条命令）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ [ atguigu ] &amp;&amp; echo OK || echo notOK</span><br><span class="line">OK</span><br><span class="line">[atguigu@hadoop101 shells]$ [ ] &amp;&amp; echo OK || echo notOK</span><br><span class="line">notOK</span><br></pre></td></tr></table></figure><hr><h1 id="流程控制（重点）"><a href="#流程控制（重点）" class="headerlink" title="流程控制（重点）"></a>流程控制（重点）</h1><h3 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h3><p><strong>1）基本语法</strong></p><p>​（1）单分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>（2）多分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">else</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>​注意事项： </p><p>​①[ 条件判断式 ]，中括号和条件判断式之间必须有空格 </p><p>​②if 后要有空格</p><p><strong>2）案例实操</strong></p><p>​输入一个数字，如果是 1，则输出 banzhang zhen shuai，如果是 2，则输出 cls zhen mei， 如果是其它，什么也不输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch if.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim if.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ $1 -eq 1 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;banzhang zhen shuai&quot;</span><br><span class="line">elif [ $1 -eq 2 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;cls zhen mei&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 if.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./if.sh 1</span><br><span class="line">banzhang zhen shua</span><br></pre></td></tr></table></figure><h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><p><strong>1）基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值 1&quot;）</span><br><span class="line">如果变量的值等于值 1，则执行程序 1</span><br><span class="line">;;</span><br><span class="line">&quot;值 2&quot;）</span><br><span class="line">如果变量的值等于值 2，则执行程序 2</span><br><span class="line">;;</span><br><span class="line">…省略其他分支…</span><br><span class="line">*）</span><br><span class="line">如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>​（1）case 行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。 </p><p>​（2）双分号“;;”表示命令序列结束，相当于 java 中的 break。 </p><p>​（3）最后的“*）”表示默认模式，相当于 java 中的 default。</p><p><strong>2）案例实操</strong></p><p>​输入一个数字，如果是 1，则输出 banzhang，如果是 2，则输出 cls，如果是其它，输出 renyao。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim case.sh</span><br><span class="line"></span><br><span class="line">!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;banzhang&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;cls&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;renyao&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 case.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./case.sh 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><strong>1）基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>2）案例实操</strong></p><p>​从 1 加到 100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for1.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sum=0</span><br><span class="line">for((i=0;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">sum=$[$sum+$i]</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for1.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for1.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>3）基本语法2</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值 1 值 2 值 3…</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>2）案例实操</strong></p><p>​（1）打印所有输入参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for2.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for2.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印数字</span></span><br><span class="line"></span><br><span class="line">for i in cls mly wls</span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for2.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for2.sh</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love mly</span><br><span class="line">ban zhang love wls</span><br></pre></td></tr></table></figure><p>​（2）比较$<em>和$@区别</em></p><p>​$*和$@都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以$1 $2 …$n 的形式输出所有参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim for3.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;=============$*=============&#x27;</span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line">echo &#x27;=============$@=============&#x27;</span><br><span class="line">for j in $@</span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for3.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for3.sh cls mly wls</span><br><span class="line">=============$*=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br></pre></td></tr></table></figure><p>​当它们被双引号“”包含时，$*会将所有的参数作为一个整体，以“$1 $2 …$n”的形式输 出所有参数；$@会将各个参数分开，以“$1” “$2”…“$n”的形式输出所有参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ vim for4.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &#x27;=============$*=============&#x27;</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">$*中的所有参数看成是一个整体，所以这个 <span class="keyword">for</span> 循环只会循环一次</span></span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;=============$@=============&#x27;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="variable">$@</span>中的每个参数都看成是独立的，所以“<span class="variable">$@</span>”中有几个参数，就会循环几次</span></span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 for4.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./for4.sh cls mly wls</span><br><span class="line">=============$*=============</span><br><span class="line">banzhang love cls mly wls</span><br><span class="line">=============$@=============</span><br><span class="line">banzhang love cls</span><br><span class="line">banzhang love mly</span><br><span class="line">banzhang love wls</span><br></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><strong>1）基本语法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>2）案例实操</strong></p><p>​从 1 加到 100</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim while.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sum=0</span><br><span class="line">i=1</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">sum=$[$sum+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 while.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./while.sh</span><br><span class="line">5050</span><br></pre></td></tr></table></figure><hr><h1 id="read-读取控制台输"><a href="#read-读取控制台输" class="headerlink" title="read 读取控制台输"></a>read 读取控制台输</h1><p><strong>1）基本语法</strong></p><p>​read (选项) (参数) </p><p>​①选项： </p><p>​-p：指定读取值时的提示符； </p><p>​-t：指定读取值时等待的时间（秒）如果-t 不加表示一直等待 </p><p>​②参数 </p><p>​变量：指定读取值的变量名</p><p><strong>2）案例实操</strong></p><p>​提示 7 秒内，读取控制台输入的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch read.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim read.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">read -t 7 -p &quot;Enter your name in 7 seconds :&quot; NN</span><br><span class="line">echo $NN</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ ./read.sh</span><br><span class="line">Enter your name in 7 seconds : atguigu</span><br><span class="line">atguigu</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p><strong>1）基本语法</strong></p><p>​basename [string &#x2F; pathname] [suffix] （功能描述：basename 命令会删掉所有的前 缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。 </p><p>​basename 可以理解为取路径里的文件名称 </p><p>​选项： </p><p>​suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉。</p><p><strong>2）案例实操</strong></p><p>​截取该&#x2F;home&#x2F;atguigu&#x2F;banzhang.txt 路径的文件名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt</span><br><span class="line">banzhang.txt</span><br><span class="line">[atguigu@hadoop101 shells]$ basename /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><h4 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h4><p><strong>1）基本语法</strong></p><p>​dirname 文件绝对路径 （功能描述：从给定的包含绝对路径的文件名中去除文件名 （非目录的部分），然后返回剩下的路径（目录的部分）） </p><p>​dirname 可以理解为取文件路径的绝对路径名称</p><p><strong>2）案例实操</strong></p><p>​获取 banzhang.txt 文件的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 ~]$ dirname /home/atguigu/banzhang.txt</span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><h3 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h3><p><strong>1）基本语法</strong></p><p>​[ function ] funname[()] </p><p>​{ </p><p>​Action; </p><p>​[return int;] </p><p>​}</p><p><strong>2）经验技巧</strong></p><p>​（1）必须在调用函数地方之前，先声明函数，shell 脚本是逐行运行。不会像其它语言一 样先编译。 </p><p>​（2）函数返回值，只能通过$?系统变量获得，可以显示加：return 返回，如果不加，将 以最后一条命令运行结果，作为返回值。return 后跟数值 n(0-255)</p><p><strong>3）案例实操</strong></p><p>​计算两个输入参数的和。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ vim fun.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function sum()</span><br><span class="line">&#123;</span><br><span class="line">s=0</span><br><span class="line">s=$[$1+$2]</span><br><span class="line">echo &quot;$s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input the number1: &quot; n1;</span><br><span class="line">read -p &quot;Please input the number2: &quot; n2;</span><br><span class="line">sum $n1 $n2;</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop101 shells]$ chmod 777 fun.sh</span><br><span class="line">[atguigu@hadoop101 shells]$ ./fun.sh</span><br><span class="line">Please input the number1: 2</span><br><span class="line">Please input the number2: 5</span><br><span class="line">7</span><br></pre></td></tr></table></figure><hr><h1 id="正则表达式入门"><a href="#正则表达式入门" class="headerlink" title="正则表达式入门"></a>正则表达式入门</h1><h3 id="常规匹配"><a href="#常规匹配" class="headerlink" title="常规匹配"></a>常规匹配</h3><p>​一串不包含特殊字符的正则表达式匹配它自己，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep atguigu </span><br></pre></td></tr></table></figure><p>​就会匹配所有包含 atguigu 的行。</p><h3 id="常用特殊字符"><a href="#常用特殊字符" class="headerlink" title="常用特殊字符"></a>常用特殊字符</h3><p><strong>1）特殊字符：^</strong></p><p>​^ 匹配一行的开头，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ^a </span><br></pre></td></tr></table></figure><p>​会匹配出所有以 a 开头的行</p><p><strong>2）特殊字符：$</strong></p><p>​$ 匹配一行的结束，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep t$ </span><br></pre></td></tr></table></figure><p>​会匹配出所有以 t 结尾的行</p><p>​<strong>思考：^$ 匹配什么？</strong></p><p><strong>3）特殊字符：.</strong></p><p>​. 匹配一个任意的字符，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r..t </span><br></pre></td></tr></table></figure><p>​会匹配包含 rabt,rbbt,rxdt,root 等的所有行</p><p><strong>4）特殊字符：</strong>*</p><p>​不单独使用，他和上一个字符连用，表示匹配上一个字符 0 次或多次，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ro*t </span><br></pre></td></tr></table></figure><p>​会匹配 rt, rot, root, rooot, roooot等所有行</p><p>​<em><em>思考：.</em> 匹配什么</em>*</p><p><strong>5）字符区间（中括号）：[ ]</strong></p><p>​[ ] 表示匹配某个范围内的一个字符，例如：</p><p>​ [6,8]——匹配 6 或者 8</p><p>​ [0-9]——匹配一个 0-9 的数字 </p><p>​[0-9]*——匹配任意长度的数字字符串 *</p><p>​[a-z]——匹配一个 a-z 之间的字符*</p><p>​[a-z]* ——匹配任意长度的字母字符串</p><p>​[a-c, e-f]-匹配 a-c 或者 e-f 之间的任意字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep r[a,b,c]*t</span><br></pre></td></tr></table></figure><p>​会匹配 rt,rat, rbt, rabt, rbact,rabccbaaacbt 等等所有行</p><p><strong>5）特殊字符：\ </strong></p><p>​\ 表示转义，并不会单独使用。由于所有特殊字符都有其特定匹配模式，当我们想匹配 某一特殊字符本身时（例如，我想找出所有包含 ‘$’ 的行），就会碰到困难。此时我们就要 将转义字符和特殊字符连用，来表示特殊字符本身，例如 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat /etc/passwd | grep ‘a\$b’ </span><br></pre></td></tr></table></figure><p>​就会匹配所有包含 a$b 的行。注意需要使用单引号将表达式引起来。</p><hr><h1 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h1><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>​cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每 一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p><p><strong>1）基本用法</strong></p><p>​cut [选项参数] filename </p><p>​说明：默认分隔符是制表符 </p><p><strong>2）选项参数说明</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列，默认是制表符“\t”</td></tr><tr><td>-c</td><td>按字符进行切割 后加加 n 表示取第几列 比如 -c 1</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p>​（1）数据准备 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ touch cut.txt</span><br><span class="line">[atguigu@hadoop101 shells]$ vim cut.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo wo</span><br><span class="line">lai lai</span><br><span class="line">le le</span><br></pre></td></tr></table></figure><p>​（2）切割 cut.txt 第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 1 cut.txt</span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><p>​（3）切割 cut.txt 第二、三列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cut -d &quot; &quot; -f 2,3 cut.txt</span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><p>​（4）在 cut.txt 文件中切割出 guan</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ cat cut.txt |grep guan | cut -d &quot; &quot; -f 1</span><br><span class="line">guan</span><br></pre></td></tr></table></figure><p>​（5）选取系统 PATH 变量值，第 2 个“：”开始后的所有路径： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/</span><br><span class="line">home/atguigu/bin</span><br><span class="line">[atguigu@hadoop101 shells]$ echo $PATH | cut -d &quot;:&quot; -f 3-</span><br><span class="line">/usr/local/sbin:/usr/sbin:/home/atguigu/.local/bin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><p>​（6）切割 ifconfig 后打印的 IP 地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | grep netmask | cut -d &quot; &quot; -f 10</span><br><span class="line">192.168.111.101</span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>​一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开 的部分再进行分析处理。</p><p><strong>1）基本用法</strong></p><p>​awk  [选项参数]  ‘&#x2F;pattern1&#x2F;{action1} &#x2F;pattern2&#x2F;{action2}…’  filename</p><p>​pattern：表示 awk 在数据中查找的内容，就是匹配模式</p><p>​action：在找到匹配内容时所执行的一系列命令</p><p><strong>2）选项参数说明</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件分隔符</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p>​（1）数据准备 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ sudo cp /etc/passwd ./</span><br><span class="line">passwd 数据的含义</span><br><span class="line">用户名:密码(加密过后的):用户 id:组 id:注释:用户家目录:sh</span><br></pre></td></tr></table></figure><p>​（2）搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 7 列。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $7&#125;&#x27; passwd</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>​（3）搜索 passwd 文件以 root 关键字开头的所有行，并输出该行的第 1 列和第 7 列， 中间以“，”号分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27; passwd</span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure><p>​注意：只有匹配了 pattern 的行才会执行 action。</p><p>​（4）只显示&#x2F;etc&#x2F;passwd 的第一列和第七列，以逗号分割，且在所有行前面添加列名 user， shell 在最后一行添加”dahaige，&#x2F;bin&#x2F;zuishuai”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125;</span><br><span class="line">END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27; passwd</span><br><span class="line">user, shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">bin,/sbin/nologin 。。。</span><br><span class="line">atguigu,/bin/bash</span><br><span class="line">dahaige,/bin/zuishuai</span><br></pre></td></tr></table></figure><p>​注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p><p>​（5）将 passwd 文件中的用户 id 增加数值 1 并输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -v i=1 -F : &#x27;&#123;print $3+i&#125;&#x27; passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>4）awk 的内置变量</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数（行号）</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><p><strong>5）案例实操</strong></p><p>​（1）统计 passwd 文件名，每行的行号，每行的列数 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ awk -F : &#x27;&#123;print &quot;filename:&quot; FILENAME &quot;,linenum:&quot;</span><br><span class="line">NR &quot;,col:&quot;NF&#125;&#x27; passwd</span><br><span class="line">filename:passwd,linenum:1,col:7</span><br><span class="line">filename:passwd,linenum:2,col:7</span><br><span class="line">filename:passwd,linenum:3,col:7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>​（2）搜查询 ifconfig 命令输出结果中的空行所在的行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig | awk &#x27;/^$/&#123;print NR&#125;&#x27;</span><br><span class="line">9</span><br><span class="line">18</span><br><span class="line">26</span><br></pre></td></tr></table></figure><p>​（3）切割 IP</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop101 shells]$ ifconfig ens33 | awk &#x27;/netmask/ &#123;print $2&#125;&#x27;</span><br><span class="line">192.168.6.101</span><br></pre></td></tr></table></figure><hr><h1 id="综合应用案例"><a href="#综合应用案例" class="headerlink" title="综合应用案例"></a>综合应用案例</h1><h3 id="归档文件"><a href="#归档文件" class="headerlink" title="归档文件"></a>归档文件</h3><p>​实际生产应用中，往往需要对重要数据进行归档备份。 </p><p>​需求：实现一个每天对指定目录归档备份的脚本，输入一个目录名称（末尾不带&#x2F;）， 将目录下所有文件按天归档保存，并将归档日期附加在归档文件名上，放在&#x2F;root&#x2F;archive 下。 </p><p>​这里用到了归档命令：tar</p><p>​后面可以加上-c 选项表示归档，加上-z 选项表示同时进行压缩，得到的文件后缀名 为.tar.gz。 </p><p>​脚本实现如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先判断输入参数个数是否为1</span></span><br><span class="line">if [ $# -ne 1 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;参数个数错误！应该输入一个参数，作为归档目录名&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从参数中获取目录名称</span></span><br><span class="line">if [ -d $1 ]</span><br><span class="line">then</span><br><span class="line">echo</span><br><span class="line">else</span><br><span class="line">echo</span><br><span class="line">echo &quot;目录不存在！&quot;</span><br><span class="line">echo</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">DIR_NAME=$(basename $1)</span><br><span class="line">DIR_PATH=$(cd $(dirname $1); pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前日期</span></span><br><span class="line">DATE=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义生成的归档文件名称</span></span><br><span class="line">FILE=archive_$&#123;DIR_NAME&#125;_$DATE.tar.gz</span><br><span class="line">DEST=/root/archive/$FILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始归档目录文件</span></span><br><span class="line"></span><br><span class="line">echo &quot;开始归档...&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">tar -czf $DEST $DIR_PATH/$DIR_NAME</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then</span><br><span class="line">echo</span><br><span class="line">echo &quot;归档成功！&quot;</span><br><span class="line">echo &quot;归档文件为：$DEST&quot;</span><br><span class="line">echo</span><br><span class="line">else</span><br><span class="line">echo &quot;归档出现问题！&quot;</span><br><span class="line">echo</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>​我们可以利用 Linux 自带的 mesg 和 write 工具，向其它用户发送消息。</p><p>​需求：实现一个向某个用户快速发送消息的脚本，输入用户名作为第一个参数，后面直 接跟要发送的消息。脚本需要检测用户是否登录在系统中、是否打开消息功能，以及当前发 送消息是否为空。</p><p>​脚本实现如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">login_user=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $login_user ]</span><br><span class="line">then</span><br><span class="line">echo &quot;$1 不在线！&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">is_allowed=$(who -T | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">if [ $is_allowed != &quot;+&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;$1 没有开启消息功能&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z $2 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;没有消息发出&quot;</span><br><span class="line">echo &quot;脚本退出..&quot;</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">whole_msg=$(echo $* | cut -d &quot; &quot; -f 2- )</span><br><span class="line"></span><br><span class="line">user_terminal=$(who | grep -i -m 1 $1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">echo $whole_msg | write $login_user $user_terminal</span><br><span class="line"></span><br><span class="line">if [ $? != 0 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;发送失败！&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;发送成功！&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell概述&quot;&gt;&lt;a href=&quot;#Shell概述&quot; class=&quot;headerlink&quot; title=&quot;Shell概述&quot;&gt;&lt;/a&gt;Shell概述&lt;/h1&gt;&lt;p&gt;shell是一个命令行解释器，它接收应用程序&amp;#x2F;用户命令，然后调用操作系统内核。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="http://example.com/tags/Shell/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="系统" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/2023/08/08/Linux/"/>
    <id>http://example.com/2023/08/08/Linux/</id>
    <published>2023-08-07T16:00:00.000Z</published>
    <updated>2023-08-30T18:16:27.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h1><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092049628.png" alt="image-20230808092049628"></p><h3 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092036780.png" alt="image-20230808092036780"></p><h3 id="Linux与Windows的区别"><a href="#Linux与Windows的区别" class="headerlink" title="Linux与Windows的区别"></a>Linux与Windows的区别</h3><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092003642.png" alt="image-20230808092003642"></p><hr><h1 id="Linux文件与目录结构"><a href="#Linux文件与目录结构" class="headerlink" title="Linux文件与目录结构"></a>Linux文件与目录结构</h1><blockquote><p>Ctrl + ALT + F2 由Linux的图形化桌面—→命令行模式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666887161931-bb67d150-f484-47f3-86b0-11c1330f170d.png" alt="img"></p><blockquote><p>Ctrl + Alt + F1 由命令行模式—→图形化模式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666887342842-bd7612b4-fa97-4d4e-9905-4765a61e6c46.png" alt="img"></p><h3 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h3><p>Linux系统中一切皆文件</p><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>层级式目录文件</p><p>&#x2F; 根目录</p><blockquote><p>Linux的目录关系是虚拟的，逻辑上的关系。在现实物理实际中，各个磁盘目录可能不在一个物理区域</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808092842962.png" alt="image-20230808092842962"></p><blockquote><p>cd &#x2F;<br>ls</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1666888964619-8f388d58-7642-43df-9e93-bb1ad0043a78.png" alt="img"></p><p><font color=Red>&#x2F;bin</font></p><ul><li>是Binary的缩写，这个目录存放着最经常使用的命令。</li></ul><p><font color=Red>红色</font></p><p>&#x2F;sbin</p><ul><li>s是super user的意思，存放系统管理员可以操作的系统管理程序。</li></ul><p><font color=Red>&#x2F;home</font></p><ul><li>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li></ul><p><font color=Red>&#x2F;root</font></p><ul><li>该目录为系统管理员，也称作超级权限者的用户主目录。</li></ul><p>&#x2F;lib</p><ul><li>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li></ul><p><font color=Red>&#x2F;etc</font></p><ul><li>存放系统环境所需要的配置文件和对应的子目录。</li></ul><p><font color=Red>&#x2F;usr</font></p><ul><li>用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li></ul><p><font color=Red>&#x2F;boot</font></p><ul><li>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。</li></ul><p>&#x2F;proc</p><ul><li>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li></ul><p>&#x2F;srv</p><ul><li>service缩写，该目录存放一些服务启动之后需要提取的数据。</li></ul><p>&#x2F;sys</p><ul><li>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。</li></ul><p>&#x2F;tmp</p><ul><li>这个目录是用来存放一些临时文件的。</li></ul><p>&#x2F;dev</p><ul><li>类似于windows的设备管理器，把所有的硬件用文件的形式存储</li></ul><p><font color=Red>&#x2F;media(CentOS 6)</font></p><ul><li>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后linux会把识别的设备挂载到这个目录下。</li><li>CentOS 7迁移到&#x2F;run&#x2F;media</li></ul><p><font color=Red>&#x2F;mnt</font></p><ul><li>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。</li></ul><p><font color=Red>&#x2F;opt</font></p><ul><li>这是给主机额外安装软件所摆放的目录。比如你安装一个mysql数据库则就可以放到这个目录下。默认是空的。</li></ul><p><font color=Red>&#x2F;var</font></p><ul><li>我们习惯将那些经常被修改的目这个目录中存放着在不断扩充着的东西录放在这个目录下。包括各种日志文件。</li></ul><hr><h1 id="VI-VIM-编辑器⭐"><a href="#VI-VIM-编辑器⭐" class="headerlink" title="VI&#x2F;VIM 编辑器⭐"></a>VI&#x2F;VIM 编辑器⭐</h1><p>VI 是 Unix 操作系统和类 Unix 操作系统中最通用的文本编辑器。 </p><p>VIM 编辑器是从 VI 发展出来的一个性能更强大的文本编辑器。可以主动的以字体颜 色辨别语法的正确性，方便程序设计。VIM 与 VI 编辑器完全兼容、</p><h3 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h3><p>VI &#x2F; VIM有三种模式</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808095737948.png" alt="image-20230808095737948"></p><h4 id="一般模式常用语法"><a href="#一般模式常用语法" class="headerlink" title="一般模式常用语法"></a>一般模式常用语法</h4><ol><li><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808095937262.png" alt="image-20230808095937262"></li></ol><blockquote><dl><dt>w 移动一个词<br>e 移动到一个词的词尾<br>b 调到上一个词的词头<br>gg 移动到当前文档的开头<br>H 移动到当前文档的开头<br>L&#x2F;G 移动到当前文档的行尾<br>3G 跳转到第三行的行头<br>: set nu 显示行号</dt><dd>set nonu 隐藏行号</dd></dl></blockquote><h4 id="编辑模式常用语法"><a href="#编辑模式常用语法" class="headerlink" title="编辑模式常用语法"></a>编辑模式常用语法</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808100238706.png" alt="image-20230808100238706"></p><h4 id="命令模式常用语法"><a href="#命令模式常用语法" class="headerlink" title="命令模式常用语法"></a>命令模式常用语法</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808100349741.png" alt="image-20230808100349741"></p><hr><h1 id="网络配置和系统管理操作"><a href="#网络配置和系统管理操作" class="headerlink" title="网络配置和系统管理操作"></a>网络配置和系统管理操作</h1><p>VMware提供了三种网络连接模式：</p><ol><li>桥接模式：虚拟机直接连接外部物理网络的模式，主机起到了网桥的作用。在这种模式下，虚拟机可以直接访问外部网络，并且对外部网络是可见的</li><li>NAT模式：虚拟机和主机构建一个专用网络，并通过虚拟网络地址转换（NAT）设备对IP进行转换。虚拟机通过共享主机IP可以访问外部网络，但外部网络无法访问虚拟机。</li><li>仅主机模式：虚拟机只与主机共享一个专用网络，与外部网络无法通信</li></ol><h3 id="配置网络ip地址"><a href="#配置网络ip地址" class="headerlink" title="配置网络ip地址"></a>配置网络ip地址</h3><h4 id="ifconfig配置网络接口"><a href="#ifconfig配置网络接口" class="headerlink" title="ifconfig配置网络接口"></a>ifconfig配置网络接口</h4><p>ifconfig :network interfaces configuring 网络接口配</p><p>**1）基本语法 **</p><p>​ifconfig （功能描述：显示所有网络接口的配置信息）</p><p><strong>2）案例实操</strong></p><p>​ 查看当前网络 ip</p><p><code>&#39;[root@hadoop100 桌面]# ifconfig&#39;</code></p><h4 id="ping-测试主机之间网络连通性"><a href="#ping-测试主机之间网络连通性" class="headerlink" title="ping 测试主机之间网络连通性"></a>ping 测试主机之间网络连通性</h4><p>**1）基本语法 **</p><p>​ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）</p><p>**2）案例实操 **</p><p>​测试当前服务器是否可以连接百度</p><p><code>[root@hadoop100 桌面]# ping www.baidu.com</code></p><h4 id="修改IP地址"><a href="#修改IP地址" class="headerlink" title="修改IP地址"></a>修改IP地址</h4><p><strong>1） 查看 IP 配置文件，如图所示</strong></p><p><code>[root@hadoop100  桌面]#vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101708745.png" alt="image-20230808101708745"></p><p>以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101835983.png" alt="image-20230808101835983"></p><p>修改后，如图 所示</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101906031.png" alt="image-20230808101906031"></p><p>编辑完后，按键盘 esc ，然后输入 :wq 回车即可。</p><p><strong>2）执行 service network restart 重启网络,如图所示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808101950224.png" alt="image-20230808101950224"></p><hr><h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><h4 id="修改主机名-1"><a href="#修改主机名-1" class="headerlink" title="修改主机名"></a>修改主机名</h4><p>**1） 基本语法 **</p><p>​hostname （功能描述：查看当前服务器的主机名称）</p><p> <strong>2） 案例实操</strong></p><p>​（1）查看当前服务器主机名称</p><p><code>[root@hadoop100 桌面]# hostname</code></p><p>​（2）如果感觉此主机名不合适，我们可以进行修改。通过编辑&#x2F;etc&#x2F;hostname 文件</p><p><code>[root@hadoop100 桌面]# vi /etc/hostname</code></p><p>​修改完成后重启生效。</p><h4 id="修改-hosts-映射文件"><a href="#修改-hosts-映射文件" class="headerlink" title="修改 hosts 映射文件"></a>修改 hosts 映射文件</h4><p>**1）修改 linux 的主机映射文件（hosts 文件） **</p><p>​后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置， 比较简单方便。 不用刻意记 ip 地址。 </p><p>​（1）打开&#x2F;etc&#x2F;hosts</p><p><code>[root@hadoop100 桌面]# vim /etc/hosts</code></p><p>​添加如下内容</p><blockquote><p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p></blockquote><p>​（2）重启设备，重启后，查看主机名，已经修改成功</p><p><strong>2）修改 windows 的主机映射文件（hosts 文件)</strong></p><p>​（1）进入 C:\Windows\System32\drivers\etc 路径 </p><p>​（2）打开 hosts 文件并添加如下内容</p><blockquote><p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p></blockquote><p>**3）修改 window10 的主机映射文件（hosts 文件） **</p><p>​（1）进入 C:\Windows\System32\drivers\etc 路径 </p><p>​（2）拷贝 hosts 文件到桌面 </p><p>​（3）打开桌面 hosts 文件并添加如下内</p><blockquote><p>192.168.2.100 hadoop100<br>192.168.2.101 hadoop101<br>192.168.2.102 hadoop102<br>192.168.2.103 hadoop103<br>192.168.2.104 hadoop104<br>192.168.2.105 hadoop105</p></blockquote><p><strong>（4）将桌面 hosts 文件覆盖 C:\Windows\System32\drivers\etc 路径 hosts 文件</strong></p><hr><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>使用xshell7这个软件进行演示</p><ol><li>创建一个新的会话连接，输入此次会话的名称，选择SSH协议，端口号默认</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210185493-a72d3b6d-4c11-4fea-9e5f-91146051454f.png" alt="img"></p><ol><li>用户身份登录验证，选择password</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210268385-cdd119da-d98a-40e8-8db7-ae4cd23c019b.png" alt="img"></p><p>也可以在外观选项中，修改控制台的字体大小颜色</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667210323737-fdd6192a-c6f7-46a5-8ed8-cb1fcbafd7af.png" alt="img"></p><p>设置复制粘贴快捷方式</p><p>工具–&gt;选项–&gt;键盘和鼠标</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808151347728.png" alt="image-20230808151347728"></p><p>图形化传输LinuxOS中的文件，使用Xftp7软件演示。</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808103010077.png" alt="image-20230808103010077"></p><hr><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h3 id="Linux中的进程和服务"><a href="#Linux中的进程和服务" class="headerlink" title="Linux中的进程和服务"></a>Linux中的进程和服务</h3><p>​计算机中，一个正在执行的程序或命令，被叫做“进程”（process）</p><p>​启动之后一直存在、常驻内存的进程，一般被称为”服务” （service）</p><h3 id="systemctl-CentOS-7版本"><a href="#systemctl-CentOS-7版本" class="headerlink" title="systemctl (CentOS 7版本)"></a>systemctl (CentOS 7版本)</h3><p><strong>1） 基本语法</strong></p><p>​systemctl  start|stop|restart|status  服务名</p><p><code>[root@hadoop100 桌面]# ls /usr/lib/systemd/</code><br><code>[root@hadoop100 桌面]# systemctl status network</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270350370-d255b364-2135-4609-8ead-4dd9d94282ea.png" alt="img"></p><p><code>[root@hadoop100 桌面]# systemctl restart NetworkManager</code></p><p><strong>2）案例实操</strong></p><p>（1）查看防火墙服务的状态 </p><p><code>[root@hadoop100 桌面]# systemctl status firewalld </code></p><p>（2）停止防火墙服务</p><p><code>[root@hadoop100 桌面]# systemctl stop firewalld</code></p><p>（3）启动防火墙服务</p><p><code>[root@hadoop100 桌面]# systemctl start firewalld </code></p><p>（4）重启防火墙服务 </p><p><code>[root@hadoop100 桌面]# systemctl restart firewalld</code></p><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p><strong>1）Linux 运行级别[CentOS 6]</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808104026046.png" alt="image-20230808104026046"></p><p><strong>2）CentOS7 的运行级别简化为:</strong></p><p>​multi-user.target  等价于原运行级别3 （多用户有网，无图形界面）</p><p>​graphical.target    等价于原运行级别5 （多用户有网，图形化界面）</p><p><strong>3） 查看当前运行级别</strong></p><p>​systemctl get-default</p><p><strong>4）修改当前运行级别</strong></p><p>​systemctl set-default TARGET.target  (这里TARGET取multi-user或者graphical)</p><h3 id="配置服务开机启动"><a href="#配置服务开机启动" class="headerlink" title="配置服务开机启动"></a>配置服务开机启动</h3><p><code>[root@hadoop100 桌面]# chkconfig --list</code><br><code>[root@hadoop100 桌面]# chkconfig --level 3 network off 网络服务运行级别3 关闭</code><br><code>[root@hadoop100 桌面]# chkconfig --level 2 newwork on  网络服务运行级别2 开启</code><br><code>[root@hadoop100 桌面]# chkconfig network off  关闭所有网络服务运行级别</code><br><code>[root@hadoop100 桌面]# chkconfig network on   开启默认网络服务运行级别</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667273528151-9d914b96-92d4-4b77-8d97-e515f0cfba0e.png" alt="img"></p><p><strong>设置网络服务开机不自启动</strong></p><p><code>systemctl disable NetworkManager</code>   默认设置NetworkManager开机不自启动</p><blockquote><p>命令行输出框中：vendor present：enabled  标识默认是开启的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667282032875-7f811c4f-c2f6-44bf-87b5-0780f560c91e.png" alt="img"></p><p><code>systemctl enable NetworkMangaer</code><br><code>systemctl status NetworkManager</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667282201194-ec3e225d-e9bb-4382-8231-aded4867610c.png" alt="img"></p><p><code>systemctl list-unit-files</code><br>在Linux中所有的service和target等都被称为unit 单元</p><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><p>1） 临时关闭防火墙 </p><p>​（1）查看防火墙状态 </p><p><code>[root@hadoop100 桌面]# systemctl status firewalld </code></p><p>​（2）临时关闭防火墙 </p><p><code>[root@hadoop100 桌面]# systemctl stop firew</code></p><p>2）开机启动时关闭防火墙 </p><p>​（1）查看防火墙开机启动状态</p><p><code>[root@hadoop100 桌面]# systemctl enable firewalld.service </code></p><p>​（2）设置开机时关闭防火墙</p><p><code>[root@hadoop100 桌面]# systemctl disable </code></p><p>根据下面截图说明</p><ol><li>一开始查看防火墙状态：开机不自启动，不是运行的</li><li>使其开机自启，查看状态，开机自启完成，但此时还没有在运行</li><li>开启防火墙运行，查看状态，在运行了（running）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667286917290-6e226281-4e0b-4463-a67f-292e102a0f7a.png" alt="img"></p><h3 id="开机自启动服务"><a href="#开机自启动服务" class="headerlink" title="开机自启动服务"></a>开机自启动服务</h3><blockquote><p>setup  命令行终端敲setup之后，会出现下图情况</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270640955-cc97d012-1aed-43c5-ac5c-d76b463aa728.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667270851633-e659a1c7-370d-480c-b95c-7ad24a1bfc8a.png" alt="img"></p><p>选择【系统服务】找到某个服务，选中【*】按空格，即可变成开机不启动设置</p><p>在Linux领域内大多数用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境，除非特殊情况下，不得已才会关机</p><p><strong>1)基本语法描述</strong></p><p>sync            (将数据由内存同步到硬盘中) </p><p>halt             (停机，关闭系统，但不断电)</p><p>poweroff   (关机，断电)</p><p>reboot        (就是重启，相当于shutdown -r now)</p><p>shutdown[选项] 时间</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-H</td><td>相当于–halt，停机</td></tr><tr><td>-r</td><td>-r&#x3D;reboot重启</td></tr></tbody></table><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>now</td><td>立刻关机</td></tr><tr><td>时间</td><td>等待多久后关机（时间单位是分钟)</td></tr></tbody></table><p><strong>2)经验技巧</strong></p><p>Linux系统中为了提高磁盘的读写效率，对磁盘采取了”预读迟写“操作方式。当用户保存文件时，Linux核心并不一定立即将保存数据写入物理磁盘中，而是将数据保存在缓冲区中，等缓冲区满时再写入磁盘。这种方式可以极大的提高磁盘写入数据的效率。但是也带来了安全隐患。如果数据还没写入磁盘时，系统掉电或者其他严重问题出现，则将导致数据丢失。使用<code>sync</code>指令可以立即将缓冲区的数据写入磁盘</p><p><code>shutdown </code>       关机 会默认等待1min才会关机<br><code>shutdown now</code>    立即关机<br><code>shutdown 3 </code>     3min之后关机<br><code>shutdown -c </code>    取消关机<br><code>shutdown 16:20</code>  计划16:20关机</p><p><strong>3)案例实操</strong></p><p>（1）将数据由内存同步到硬盘中</p><p><code>[root@hadoop100 桌面]#sync </code></p><p>（2）重启 </p><p><code>[root@hadoop100 桌面]# reboot </code></p><p>（3）停机（不断电） </p><p><code>[root@hadoop100 桌面]#halt </code></p><p>（4）计算机将在 1 分钟后关机，并且会显示在登录用户的当前屏幕</p><p><code>[root@hadoop100 桌面]#shutdown -h 1 ‘This server will shutdown after 1 mins’ </code></p><p>（5）立马关机（等同于 poweroff）</p><p><code>[root@hadoop100 桌面]# shutdown -h now </code></p><p>（6）系统立马重启（等同于 reboot） </p><p><code>[root@hadoop100 桌面]# shutdown -r now</code></p><hr><h1 id="常用基本命令⭐"><a href="#常用基本命令⭐" class="headerlink" title="常用基本命令⭐"></a>常用基本命令⭐</h1><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><h4 id="pwd-显示当前工作目录的绝对路径"><a href="#pwd-显示当前工作目录的绝对路径" class="headerlink" title="pwd  显示当前工作目录的绝对路径"></a>pwd  显示当前工作目录的绝对路径</h4><p>pwd:print working directory 打印工作目录</p><p>**1）基本语法 **</p><p>​pwd （功能描述：显示当前工作目录的绝对路径） </p><p>**2）案例实操 **</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667355600456-8b48d580-85ac-4a39-a34a-f2acf48b6575.png" alt="image.png"></p><h4 id="ls-列出目录的内"><a href="#ls-列出目录的内" class="headerlink" title="ls 列出目录的内"></a>ls 列出目录的内</h4><p>ls:list 列出目录内容</p><p>**1）基本语法 **</p><p>​ls [选项] [目录或是文件] </p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>全部的文件，联通隐藏档（开头为.的文件）一起列出来（常用）</td></tr><tr><td>-l</td><td>长数据串列出，包含文件的数据与权限等等数据；(常用)等价于”ll”</td></tr></tbody></table><p>**3）显示说明 **</p><p>​每行列出的信息依次是： <font color=Red>文件类型与权限 链接数 文件属主 文件属组 文件大小用byte 来表示 建立或最近修改的时间 名字</font></p><p><strong>4）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667357550167-0835e617-f31e-46b4-8a52-758daa9bbf09.png" alt="image.png"></p><h4 id="cd-切换目"><a href="#cd-切换目" class="headerlink" title="cd 切换目"></a>cd 切换目</h4><p>cd:Change Directory 切换路径</p><p>**1）基本语法 **</p><p>​cd [参数] </p><p><strong>2）参数说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>cd 绝对路径</td><td>切换路径</td></tr><tr><td>cd 相对路径</td><td>切换路径</td></tr><tr><td>cd ~或者 cd</td><td>回到自己的家目录</td></tr><tr><td>cd -</td><td>回到上一次所在目录</td></tr><tr><td>cd ..</td><td>回到当前目录的上一级目录</td></tr><tr><td>cd -P</td><td>跳转到实际物理路径，而非快捷方式路径</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112335725.png" alt="image-20230808112335725"></p><h4 id="mkdir-创建一个新的目录"><a href="#mkdir-创建一个新的目录" class="headerlink" title="mkdir 创建一个新的目录"></a>mkdir 创建一个新的目录</h4><p>mkdir:Make directory 建立目录</p><p><strong>1）基本语法 mkdir</strong></p><p>​ [选项] 要创建的目录 </p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>创建多层目录</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112646870.png" alt="image-20230808112646870"></p><h4 id="rmdir删除一个空的目录"><a href="#rmdir删除一个空的目录" class="headerlink" title="rmdir删除一个空的目录"></a>rmdir删除一个空的目录</h4><p>​rmdir:Remove directory 移除目录</p><p>**1）基本语法 **</p><p>​rmdir 要删除的空目录 </p><p>**2）案例实操 **</p><p>​（1）删除一个空的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808112826606.png" alt="image-20230808112826606"></p><h4 id="touch-创建空文件"><a href="#touch-创建空文件" class="headerlink" title="touch 创建空文件"></a>touch 创建空文件</h4><p>**1）基本语法 **</p><p>​touch 文件名称</p><p>**2）案例实操 **</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667368541688-b1f7299f-8483-4998-a564-aa8483e5e47b.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667368756484-403dd29e-4d1a-4a48-a58b-136ea76bc032.png" alt="image.png"></p><h4 id="cp复制文件或目录"><a href="#cp复制文件或目录" class="headerlink" title="cp复制文件或目录"></a>cp复制文件或目录</h4><p>**1）基本语法 ** </p><p>cp [选项] source dest （功能描述：复制source文件到dest）</p><p><strong>1）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归复制整个文件夹</td></tr></tbody></table><p><strong>3）参数说明</strong></p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>递归复制整个文件夹</td></tr><tr><td>source</td><td>源文件</td></tr><tr><td>dest</td><td>目标文件</td></tr></tbody></table><p>**4）经验技巧 **</p><p>​强制覆盖不提示的方法：\cp</p><p>**5）案例实操 **</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113223773.png" alt="image-20230808113223773"></p><h4 id="rm-删除文件或目录"><a href="#rm-删除文件或目录" class="headerlink" title="rm 删除文件或目录"></a>rm 删除文件或目录</h4><p>**1）基本语法 **</p><p>​rm [选项] deleteFile （功能描述：递归删除目录中所有内容）</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>-r</td><td>递归删除目录中所有内容</td></tr><tr><td>-f</td><td>强制执行删除操作，而不提示用于进行确认。</td></tr><tr><td>-v</td><td>显示指令的详细执行过程</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p>​（1）删除目录中的内容</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113548955.png" alt="image-20230808113548955"></p><p>​（2）递归删除目录中所有内容</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808113556942.png" alt="image-20230808113556942"></p><h4 id="mv-移动文件与目录或重命名"><a href="#mv-移动文件与目录或重命名" class="headerlink" title="mv 移动文件与目录或重命名"></a>mv 移动文件与目录或重命名</h4><p>1）基本语法 </p><p>（1）<code>mv oldNameFile newNameFile</code> （功能描述：重命名） </p><p>（2）<code>mv /temp/movefile /targetFolder</code> （功能描述：移动文件）</p><p>将&#x2F;root目录下的 initial-setup-ks.cfg 文件，移动到 &#x2F;home&#x2F;atguigu&#x2F;下，此时&#x2F;root目录就没有该文件了</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667384782286-06471e0a-c547-4be4-9967-ef7084283174.png" alt="img"></p><p>mv 还可以将移动文件改名字</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667385292203-a61a3d21-f7c8-43a0-a559-4d7fc4913828.png" alt="img"></p><p>mv 也可以在本目录下，修改文件名</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667385393980-56887eb5-22ee-4191-bffb-8197b3405bb1.png" alt="img"></p><h4 id="cat查看文件内容"><a href="#cat查看文件内容" class="headerlink" title="cat查看文件内容"></a>cat查看文件内容</h4><p>​查看文件内容，从第一行开始显示。</p><p><strong>1）基本语法</strong></p><p>​ cat [选项] 要查看的文件 </p><p>**）选项说明 **</p><table><thead><tr><th>选项</th><th>功能描述</th></tr></thead><tbody><tr><td>-n</td><td>显示所有行的行号，包括空行。</td></tr></tbody></table><p>**3）经验技巧 **</p><p>一般查看比较小的文件，一屏幕能显示全的。 </p><p>**4）案例实操 **</p><p>​（1）查看文件内容并显示行号</p><p><code>[atguigu@hadoop101 ~]$ cat -n houge.txt</code></p><h4 id="more-文件内容分屏查看器"><a href="#more-文件内容分屏查看器" class="headerlink" title="more  文件内容分屏查看器"></a>more  文件内容分屏查看器</h4><p>​more指令是一个基于VI编辑器的文件过滤器。它以全屏幕的方式按页显示文本文件的内容。more指令中内置了若干快捷键，详见操作说明。</p><p><strong>1）基本语法</strong></p><p>​more 要查看的文件</p><p>**2）选项说明 **</p><p>在Linux系统的控制台中输入 <code>more  查看的文件</code>，会进入类似vim编辑器的效果页面。按照下面的操作，即可产生响应的效果。如果翻看的内容结束了，就会直接退出了。</p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键（space）</td><td>向下翻一页</td></tr><tr><td>Enter</td><td>向下翻一行</td></tr><tr><td>q</td><td>立刻离开more，不再显示该文件内容</td></tr><tr><td>CTRL + F</td><td>向下翻滚一屏幕</td></tr><tr><td>CTRL + B</td><td>返回上一屏幕</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><h4 id="less-分屏显示文件内容"><a href="#less-分屏显示文件内容" class="headerlink" title="less  分屏显示文件内容"></a>less  分屏显示文件内容</h4><p>​less指令用来分屏查看文件内容，他的功能和more指令类似，但是比more更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><p><strong>1）基本语法</strong></p><p>less  要查看的文件</p><p><strong>2)操作说明</strong></p><table><thead><tr><th>操作</th><th>功能说明</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻动一页；</td></tr><tr><td>[pagedown]</td><td>向下翻动一页</td></tr><tr><td>[pageup]</td><td>向上翻动一页；</td></tr><tr><td>&#x2F;字串</td><td>&#x2F;字串 向下搜寻『字串』的功能；n：向下查找；N：向上查找；</td></tr><tr><td>?字串</td><td>向上搜寻『字串』的功能；n：向上查找；</td></tr><tr><td>q</td><td>离开 less 这个程序</td></tr></tbody></table><h4 id="echo-输出内容到控制台"><a href="#echo-输出内容到控制台" class="headerlink" title="echo  输出内容到控制台"></a>echo  输出内容到控制台</h4><p><strong>1）基本语法</strong></p><p>​echo [选项] [输出内容]</p><p>​选项:<br>​-e:支持反斜线控制的字符转换</p><p>​控制字符        作用<br>​\\     输出 \ 本身<br>​\n        换行符<br>​\t     制表符，也就是tab键</p><p>**2）案例实操 **</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667397186741-61cfce42-5bd9-4605-ab90-4d3b21da8b90.png" alt="img"></p><h4 id="head显示文件头部内容"><a href="#head显示文件头部内容" class="headerlink" title="head显示文件头部内容"></a>head显示文件头部内容</h4><p>head用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容</p><p><strong>1）基本语法</strong></p><p><code>head 文件 </code>      查看文件头10行内容<br><code>head -n 5 文件 </code> 查看文件头5行内容，5可以是任意行数</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n&lt;行数&gt;</td><td>指定显示头部内容的行数</td></tr></tbody></table><p>**3）案例实操 **</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667407519246-22afffda-8fd4-420c-a7ef-d7a808578a3d.png" alt="img"></p><h4 id="tail-输出文件尾部内容"><a href="#tail-输出文件尾部内容" class="headerlink" title="tail  输出文件尾部内容"></a>tail  输出文件尾部内容</h4><p>tail用于输出文件中尾部的内容，默认情况下tail指令显示文件的后10行内容</p><p><strong>1）基本语法</strong></p><p><code>tail 文件</code>        查看文件尾部10行内容<br><code>tail -n 5 文件  </code>  查看文件尾部5行内容，5可以是任意行数<br><code>tail -f 文件   </code>     实时追踪该文档的所有更新</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-n&lt;行数&gt;</td><td>输出文件尾部 n 行内容</td></tr><tr><td>-f</td><td>显示文件最新追加的内容，监视文件变化</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667407607225-c71126f6-639f-4434-b78a-57000de68a04.png" alt="img"></p><h4 id="输出重定向和-追加"><a href="#输出重定向和-追加" class="headerlink" title="&gt; 输出重定向和 &gt;&gt; 追加"></a>&gt; 输出重定向和 &gt;&gt; 追加</h4><p><strong>1）基本语法</strong></p><p><code>ls -1 &gt; 文件    </code>  列表的内容写入文件a.txt中（覆盖写）</p><p><code>ls -al &gt;&gt; 文件 </code>   列表的内容追加到文件aa.txt的末尾</p><p><code>cat 文件1 &gt; 文件2 </code>   将文件1的内容覆盖到文件2</p><p><code>echo &quot;内容&quot;&gt;&gt; 文件</code></p><p><strong>2）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808122053437.png" alt="image-20230808122053437"></p><h4 id="ln-软链接"><a href="#ln-软链接" class="headerlink" title="ln  软链接"></a>ln  软链接</h4><p>软链接也成为符号链接，类似于win里的快捷方式，有自己的数据块，主要存放了链接其他文件的路径。</p><p><strong>1）基本语法</strong></p><p><code>ln -s[原文件或目录][软链接名] </code>  给原文件创建一个软链接</p><p><strong>2）说明</strong></p><p>删除软链接： rm -rf 软链接名，而不是 rm -rf 软链接名&#x2F; </p><p>如果使用 rm -rf 软链接名&#x2F; 删除，会把软链接对应的真实目录下内容删掉 </p><p>查询：通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向</p><p> <strong>3）案例实操</strong></p><p>下图说明</p><ol><li>ln -s &#x2F;root&#x2F;info myInfo   将&#x2F;root目录下的info文件  在&#x2F;home &#x2F;atguigu目录下创建一个对应的软链接，软链接名称叫 myInfo</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667409997562-bb842d5f-c741-4fc6-aacb-48c9d5ab2b4d.png" alt="img"></p><p>下图说明：</p><ol><li>mkdir folder   创建了一个名叫 folder 的文件夹</li><li>touch folder&#x2F;file  在folder文件夹下创建了一个名叫 file 的文件</li><li>ln -s &#x2F;root&#x2F;folder&#x2F; &#x2F;home&#x2F;atguigu&#x2F;myFolder  将&#x2F;roor&#x2F;folder&#x2F;文件夹下的目录，创建一个软链接名为myFolder在&#x2F;home&#x2F;atguigu目录下</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667410348543-93096a3e-5b7d-4ec3-9792-547dfb5320b1.png" alt="img"></p><p>-P  显示物理上的绝对路径</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667410759094-81323d5b-e80b-4093-bda2-840727a4ebef.png" alt="img"></p><p>ln 文件 链接   这种方式叫硬链接</p><h4 id="history-查看已经执行过历史命令"><a href="#history-查看已经执行过历史命令" class="headerlink" title="history  查看已经执行过历史命令"></a>history  查看已经执行过历史命令</h4><p><strong>1）基本语法</strong></p><p>history （功能描述：查看已经执行过历史命令）</p><p> <strong>2）案例实操</strong></p><p><code>history</code> 查看过去在Linux中已经执行过得命令</p><p><code>history 10</code> 查看过去倒数的10个命令</p><p><code>！+ 历史命令编号</code>  相当于重复执行这个命令</p><p><code>history -c</code> 清理掉历史命令记录</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667411425793-c543aaa6-c7b5-4cb5-b9a4-371f856c49fb.png" alt="img"></p><hr><h3 id="date-时间日期类"><a href="#date-时间日期类" class="headerlink" title="date  时间日期类"></a>date  时间日期类</h3><p><strong>1）基本语法</strong></p><p>date [OPTION] [FORMAT]</p><p><strong>2)选项说明</strong><br>-d&lt;时间字符串&gt;    显示指定的“时间字符串”表示的时间，而非当前时间<br>-s&lt;日期时间&gt;        设置系统日期时间</p><p><strong>3)参数说明</strong><br>&lt;+日期时间格式&gt;   指定显示时间的格式形式</p><h4 id="date-显示当前时间"><a href="#date-显示当前时间" class="headerlink" title="date 显示当前时间"></a>date 显示当前时间</h4><p><strong>1）基本语法</strong></p><p><code>date</code>         显示当前日期<br><code>date +%Y</code>     显示当前年份<br><code>date +%m</code>         显示当前月份<br><code>date +%d</code>     显示当前是哪一天<br><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>         显示年月日时分秒</p><p><code>date +%S</code> 显示当前秒<br><code>date +%s</code> 显示当前的时间戳</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455064284-51e97f80-7981-4997-8fa2-900a8f8262e4.png" alt="img"></p><h4 id="date-显示非当前时间"><a href="#date-显示非当前时间" class="headerlink" title="date 显示非当前时间"></a>date 显示非当前时间</h4><p><code>date -d &quot;1 day ago&quot;</code>    显示前一天时间，昨天<br><code>date -d &quot;-1 day ago&quot;</code>   显示明天时间</p><h4 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a>设置系统时间</h4><p><code>date -s &quot;2000-01-01 12:10:30&quot; </code> 设置系统时间为 </p><p><code>ntpdate 同步时间的服务器名称</code>  即可恢复成现实世界时间</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455241629-38a56406-7d98-4a9b-97a2-94470b485b41.png" alt="img"></p><h4 id="cal-查看日历"><a href="#cal-查看日历" class="headerlink" title="cal 查看日历"></a>cal 查看日历</h4><p><strong>1）基本语法</strong></p><p>cal [选项] （功能描述：不加选项，显示本月日历）</p><p><strong>2)案例实操</strong></p><p><code>cal -3</code> 查看前一个月 后一个月 的日历信息<br><code>cal -m </code>把周一放在第一天的日历</p><p><code>cal 2022</code>   查看2022年的日历<br><code>cal -y</code>     查看当前系统时间的一整年日历</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667455297972-ea887003-ef8b-4b10-ae0d-5d6b19225e7f.png" alt="img"></p><hr><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>Linux是多用户多任务的分时操作系统</p><h4 id="useradd-添加新用户"><a href="#useradd-添加新用户" class="headerlink" title="useradd 添加新用户"></a>useradd 添加新用户</h4><p><code>useradd 用户名</code>            添加新用户<br><code>useradd -g 用户组 用户名</code>   添加新用户到某个组中</p><p><code>useradd -d /home/dave david</code> 将david这个用户的主文件夹改名成dave，登录Linux的用户名还是david</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465273915-54fa6e40-9dea-4311-8adc-2dc18c9d95ec.png" alt="img"></p><h4 id="passwd-设置用户密码"><a href="#passwd-设置用户密码" class="headerlink" title="passwd 设置用户密码"></a>passwd 设置用户密码</h4><p><code>passwd 用户名</code>  给指定用户设置密码</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465496647-c6845df4-7d56-4751-ab15-384d8a53dddc.png" alt="img"></p><p>tony这个用户登录，密码是 123456 ,登录之后进入的目录是 &#x2F;home&#x2F;tony</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465410257-6233f0a5-681e-4f83-bb91-1686188ea7af.png" alt="img"></p><p>david这个用户登录之后，直接进入已经修改过用户主文件夹的dave的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465563807-ac93c0c4-52d6-45b7-b010-f27cb9b65026.png" alt="img"></p><h4 id="id-用户名-查看用户信息，验证是否存在该用户"><a href="#id-用户名-查看用户信息，验证是否存在该用户" class="headerlink" title="id 用户名  查看用户信息，验证是否存在该用户"></a>id 用户名  查看用户信息，验证是否存在该用户</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465770996-28b9e84a-11af-496b-bd07-335f2c92732e.png" alt="img"></p><h4 id="查看所有用户信息"><a href="#查看所有用户信息" class="headerlink" title="查看所有用户信息"></a>查看所有用户信息</h4><p><code>cat /etc/passwd</code>   查看创建了哪些用户<br><code>less /etc/passwd</code>  查看创建了哪些用户，<code>q</code>退出</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667465932879-a94a0da4-d661-49f4-ac86-7520957ae69a.png" alt="img"></p><h4 id="su-用户名-切换到指定用户"><a href="#su-用户名-切换到指定用户" class="headerlink" title="su 用户名  切换到指定用户"></a>su 用户名  切换到指定用户</h4><p><strong>1）基本语法</strong></p><p>su 用户名称   （功能描述：切换用户，只能获得用户的执行权限，不能获得环境变量） su - 用户名称 （功能描述：切换到用户并获得该用户的环境变量及执行权限）</p><p> <strong>2）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466063716-010bc030-5f6e-43a2-9818-98967c1cee6a.png" alt="img"></p><blockquote><p>下图说明</p><p>切换用户实际上是嵌套形式的</p><p>root —&gt; atguigu —&gt;tony</p><p>如果退出则从 tony —&gt; atguigu —&gt; root 这样路径返回</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466184939-a533ff5e-ed98-4b2e-b248-5cde42337ed0.png" alt="img"></p><blockquote><p>下图说明</p><p>tony不能查看atguigu的文件目录，反之亦然。因为他俩属于同一级别</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466338752-96877f5c-0094-46e2-965f-0465388a2229.png" alt="img"></p><blockquote><p>下图说明</p><p>1.因为当前切换用户是基于root用户来的，所以 who am i 一直输出都是 root</p><p>2.whoami 形式，会输出当前切换的用户</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667466481207-4684bba9-6509-4db9-a049-2653137c2f7c.png" alt="img"></p><h4 id="sudo-设置普通用户具有root权限"><a href="#sudo-设置普通用户具有root权限" class="headerlink" title="sudo  设置普通用户具有root权限"></a>sudo  设置普通用户具有root权限</h4><blockquote><p>首先需要在配置文件中配置权限，否则会有下图提示</p><p><code>vim /etc/sudoers </code>进入文件</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467478198-f72cf08f-3ad3-4634-a664-38b01b3e47ea.png" alt="img"></p><blockquote><p>下图说明</p><p>在root下，添加用户的权限</p><p>修改完之后，<code>:wq!</code>强制执行操作</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467631702-c8eea1aa-639a-401e-952d-e3ef56bd58fe.png" alt="img"></p><p>修改完之后，权限就够了</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467731768-abb97595-cb03-4792-a4b4-2fbcf09b0304.png" alt="img"></p><h4 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel  删除用户"></a>userdel  删除用户</h4><p><code>userdel 用户名</code>   删除用户，但不删除用户组的文件内容</p><p><code>rm -rf tony/</code>    删除tony用户下的文件目录内容（不推荐使用，建议保留）</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667467945599-6540404e-25cf-40e2-8c62-797b8d92be5b.png" alt="img"></p><p><code>userdel -r 用户</code>  不仅删除用户，连同该用户的目录也被删掉</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667468146780-4929ad4b-6c6e-4ad5-95f6-924c37f6d37d.png" alt="img"></p><hr><h3 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h3><p>在Linux中，默认新建的用户在自己同名的组中，所有用户组的信息都在 <code>/etc/group</code> 配置文件中</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667471753618-7133c3a4-0c2c-44d7-ae87-390f0acee9b9.png" alt="img"></p><h4 id="groupadd-新建组"><a href="#groupadd-新建组" class="headerlink" title="groupadd  新建组"></a>groupadd  新建组</h4><p>groupadd 组名</p><p><code>groupadd meifa</code>  创建meifa这个组</p><h4 id="groupdel-删除组"><a href="#groupdel-删除组" class="headerlink" title="groupdel 删除组"></a>groupdel 删除组</h4><p><code>groupdel 组名</code>      删除存在的组</p><h4 id="usermod-groupmod-修改用户、修改组"><a href="#usermod-groupmod-修改用户、修改组" class="headerlink" title="usermod  groupmod  修改用户、修改组"></a>usermod  groupmod  修改用户、修改组</h4><p>下图说明</p><ol><li><code>usermod -g meifa tony</code>               将tony这个用户，放到meifu这个用户组中</li><li><code>groupmod -n haircut meifa</code>       将meifa这个组的名字改成haircut</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667471910798-c7f861d8-fbbb-42ce-8672-0a9eb0ad96e0.png" alt="img"></p><p>下图说明</p><ol><li>用户 atguigu 在和root一起创建的时候，会被默认添加到 wheel 组中，而wheel组成员在配合sudo命令时可以拥有管理员权限操作</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667472357293-031fded7-ad22-423a-a141-453c67153c23.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667472462450-2849dd69-8489-405e-9c09-30f06991f6a4.png" alt="img"></p><hr><h3 id="文件权限类"><a href="#文件权限类" class="headerlink" title="文件权限类"></a>文件权限类</h3><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>Linux是一种典型的多用户多任务的操作系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属用户和组。</p><p><strong>1）从左到右的 10 个字符表示，如图 所示</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131446656.png" alt="image-20230808131446656"></p><p>如果没有权限，就会出现减号[ - ]而已。从左至右用0-9这些数字来表示:</p><p>（1）0 首位表示类型 </p><p>​在Linux中第一个字符代表这个文件是目录、文件或链接文件等等 </p><ul><li>代表文件</li><li>d 代表目录</li><li>l 链接文档(link file)；</li></ul><p>（2）第1-3位确定属主（该文件的所有者）拥有该文件的权限。—User </p><p>（3）第4-6位确定属组（所有者的同组用户）拥有该文件的权限，—Group </p><p>（4）第7-9位确定其他用户拥有该文件的权限 —Othe</p><p><strong>2）rwx 作用文件和目录的不同解释</strong></p><p>（1）作用到文件：</p><p>​ [ r ]代表可读(read): 可以读取，查看</p><pre><code> [ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前 提条件是对该文件所在的目录有写权限，才能删除该文件.</code></pre><p>​[ x ]代表可执行(execute):可以被系统执行</p><p>（2）作用到目录：</p><p>​[ r ]代表可读(read): 可以读取，ls查看目录内容</p><p>​[ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录</p><p>​[ x ]代表可执行(execute):可以进入该目录</p><p>下图说明</p><ol><li>在操作<code>ll</code>指令之后，会详细展示出文件类型、操作权限、硬链接数、所属用户、所属用户组、大小、创建&#x2F;修改时间、文件&#x2F;文件夹名称</li><li>在黄色区域中，- 表示文件，d表示文件夹，l表示是一个文件链接，c表示字符设备文件(鼠标)，d表示块设备文件(硬盘)</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667483029843-3681d542-0b74-46e8-9e9d-c7d5ce30a2f7.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131740625.png" alt="image-20230808131740625"></p><h4 id="chmod-修改文件权限"><a href="#chmod-修改文件权限" class="headerlink" title="chmod  修改文件权限"></a>chmod  修改文件权限</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808131808047.png" alt="image-20230808131808047"></p><p>第一种方式变更权限 </p><p>​chmod [{ugoa}{+-&#x3D;}{rwx}] 文件或目录 </p><p>第二种方式变更权限 </p><p>​chmod [mode&#x3D;421 ] [文件或目录]</p><p><strong>经验技巧</strong></p><p>​u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和）</p><p>​r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1</p><p><code>chmod u+x initial-setup-ks.cfg</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667484864251-2df2e6e0-715d-47ca-b5ef-e517772f1b9c.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23197095/1667484969947-1ca27fea-ee43-4dff-92fd-5b1d01295169.png" alt="img"></p><p><code>chmode 644 initial-setup-ks.cfg</code>  修改文件权限</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667485443424-b34628ff-c566-4d9f-8a95-3fb9abd29e35.png" alt="img"></p><p>如果一个文件夹内有很多文件，想要修改该文件夹的权限</p><p><code>chmod -R 777 文件夹/ </code>   <code>-R</code>指令会将该文件夹内的文件的权限也一并修改了</p><h4 id="chown-改变所有者"><a href="#chown-改变所有者" class="headerlink" title="chown  改变所有者"></a>chown  改变所有者</h4><p><strong>1）基本语法</strong></p><p>​chown [选项] [最终用户] [文件或目录]    (改变文件或目录所有者)</p><p><strong>2）选项说明</strong></p><p>​-R   递归操作</p><p><strong>3）案例实操</strong></p><p><code>chown atguigu houge.txt</code>   将文件houge.txt的所属用户改成 atguigu这个用户</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808132324314.png" alt="image-20230808132324314"></p><p>下图说明</p><ol><li>首先查看了initial-setup-ks.cfg文件的详细信息，所属用户，所属组</li><li>chown atguigu initial-setup-ks.cfg    将initial-setup-ks.cfg文件的所属用户从root改成了atguigu</li><li>chmod 700 initial-setup-ks.cfg    atguigu这个用户修改initial-setup-ks.cfg文件的权限</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667487847237-96a1f9f7-3fb7-4066-85e4-db73e88b5f5b.png" alt="img"></p><h4 id="chgrp-改变所属组"><a href="#chgrp-改变所属组" class="headerlink" title="chgrp  改变所属组"></a>chgrp  改变所属组</h4><p>​chgrp [最终用户组] [文件或目录]      改变文件或者目录的所属组</p><p><code>chgrp root houge.txt</code>  将文件houge.txt文件的所属组改成root</p><p>下图说明</p><ol><li>首先查看initial-setup-ks.cfg文件的详细信息</li><li>在atguigu这个用户下修改 initial这个文件的所属组，提示不允许。需要root权限</li><li>切换成root权限之后，chgrp haircut initial-setup-ks.cfg  修改initial这个文件的所属组为haircut</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667488102108-71b65a59-61eb-428c-bdfb-16438f7980ec.png" alt="img"></p><hr><h3 id="搜索查找类"><a href="#搜索查找类" class="headerlink" title="搜索查找类"></a>搜索查找类</h3><h4 id="find查找文件或目录"><a href="#find查找文件或目录" class="headerlink" title="find查找文件或目录"></a>find查找文件或目录</h4><p>​finde指令将从指定目录向下递归地遍历各个子目录，将满足条件的文件显示在终端</p><p><strong>1）基本语法</strong></p><p> find [搜索范围] [选项]</p><p><strong>2）选项说明</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808132629919.png" alt="image-20230808132629919"></p><p><strong>3）案例实操</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -lh   可以更加直观的看到文件的占用存储大小</span><br><span class="line"></span><br><span class="line">find /root -size +10M    在/root路径下，按照存储大小查找超过10M的文件</span><br><span class="line"></span><br><span class="line">find /root -size +2M   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667531748830-cfaae822-b5a6-4fb0-9a48-547b71f342c4.png" alt="img"></p><h4 id="locate快速定位文件路径"><a href="#locate快速定位文件路径" class="headerlink" title="locate快速定位文件路径"></a>locate快速定位文件路径</h4><p>​locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。</p><p><strong>1）基本语法</strong></p><p>​locate 搜索文件</p><p><strong>2）说明</strong></p><p>​由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库</p><p><strong>3）案例实操</strong></p><p>下图说明</p><ol><li><code>updatedb</code>     因为locate命令是根据数据库查询的，所以在使用之前先更新一下系统DB</li><li><code>locate temp</code>   会把所有包含tmp字眼的文件或文件夹都查询出来</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532519496-304690f2-f600-4880-8032-e9511e1788f1.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532649261-155e9193-d5a6-414d-a702-fbe8c6a5eee0.png" alt="img"></p><h4 id="which-whereis-查找命令本身的路径"><a href="#which-whereis-查找命令本身的路径" class="headerlink" title="which  whereis  查找命令本身的路径"></a>which  whereis  查找命令本身的路径</h4><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667532770646-5850f5bb-1091-46e2-8f7c-b6d5a7e6314f.png" alt="img"></p><h4 id="grep-过滤查找及”-”管道符"><a href="#grep-过滤查找及”-”管道符" class="headerlink" title="grep  过滤查找及”|”管道符"></a>grep  过滤查找及”|”管道符</h4><p>管道符 “|” 表示将前一个命令的处理结果传递给后面的指令处理</p><p>find 和locate 与 grep的区别，find locate定位的是文件名，grep查找的是文件的内容</p><p><strong>1）基本语法</strong></p><p>​grep [选项] 查找内容 源文件</p><p><strong>2）选项说明</strong></p><p>​-n    显示匹配行及行号</p><p><strong>3）案例实操</strong></p><p>下图说明</p><ol><li>grep -n boot initial-setup-ks.cfg     查找initial这个文件内容中包含boot的内容，并且-n显示行号</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533166991-b45fd01a-7af3-4618-a432-2e7af4159908.png" alt="img"></p><p>下图说明</p><ol><li>ls  显示出&#x2F;root目录下的文件 文件夹</li><li>ls | grep .cfg    将ls查询的结果传递给grep指令，grep在ls查询结果的基础上，筛选出后缀名带有.cfg的文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533353286-6f546157-56eb-470f-8cb3-5b9eb28d5e31.png" alt="img"></p><h4 id="wc-work-cound"><a href="#wc-work-cound" class="headerlink" title="wc  work cound"></a>wc  work cound</h4><p>下图说明</p><ol><li><code>cat info</code>      查看info这个文件的内容</li><li><code>wc info</code> 查看文件的行号，多少个单词数，存储大小 ，文件名</li><li><code>grep -n boot initial-setup-ks.cfg | wc</code>    将initial文件中包含boot的内容行结果传递给wc指令，统计出该结果有8行，32个单词，341字节</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533787517-441d1b0d-fc6c-4d7c-9295-5be25bb15f06.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667533558401-81da8038-24de-493f-8fa8-8e405cfb9a6e.png" alt="img"></p><hr><h3 id="压缩和解压类"><a href="#压缩和解压类" class="headerlink" title="压缩和解压类"></a>压缩和解压类</h3><h4 id="gzip-gunzip压缩解压缩"><a href="#gzip-gunzip压缩解压缩" class="headerlink" title="gzip&#x2F;gunzip压缩解压缩"></a>gzip&#x2F;gunzip压缩解压缩</h4><p><strong>1）基本语法</strong></p><p><code>gzip  文件</code>         压缩文件，只能将文件压缩为 *.gz 文件<br><code>gunzip  文件.gz</code>    解压缩文件名令</p><p><strong>2）说明</strong></p><p>​只能压缩文件不能压缩目录<br>​不保留原来的文件<br>​同时多个文件会产生多个压缩包</p><h4 id="zip-unzip-压缩解压缩"><a href="#zip-unzip-压缩解压缩" class="headerlink" title="zip&#x2F;unzip 压缩解压缩"></a>zip&#x2F;unzip 压缩解压缩</h4><p><strong>1）基本语法</strong></p><p><code>zip [选项] xxxxx.zip 将要压缩的内容</code>       压缩文件和目录的命令</p><p><code>unzip [选项] xxxxx.zip</code>                   解压缩文件</p><p><strong>2）选项</strong></p><table><thead><tr><th>zip选项</th><th>功能</th></tr></thead><tbody><tr><td>-r</td><td>压缩目录</td></tr></tbody></table><table><thead><tr><th>unzip选项</th><th>功能</th></tr></thead><tbody><tr><td>-d&lt;目录&gt;</td><td>指定解压后文件的存放目录</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/image-20230808133847431.png" alt="image-20230808133847431"></p><h4 id="tar-打包（常用，重点）"><a href="#tar-打包（常用，重点）" class="headerlink" title="tar  打包（常用，重点）"></a>tar  打包（常用，重点）</h4><p><strong>1）基本语法</strong></p><p><code>tar [选项]  xxxx.tar.gz 将要打包进去的内容</code>       打包目录，压缩后的文件格式.tar.gz</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生.tar 打包文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-f</td><td>指定压缩后的文件名</td></tr><tr><td>-z</td><td>打包同时压缩</td></tr><tr><td>-x</td><td>解包 .tar 文件</td></tr><tr><td>-C</td><td>解压到指定目录</td></tr></tbody></table><p><strong>3）案例实操</strong></p><p>下图说明</p><ol><li>进入&#x2F;root 目录下，查看其文件 目录</li><li><code>tar -zcvf temp.tar.gz initial-setup-ks.cfg xzhdx.txt info 公共/</code></li></ol><p>​         将 initial，xzhdx.txt，info，公共&#x2F; ，这4个文件和文件夹，-zcvf打包压缩成名为temp.tar.gz的打包压缩文件</p><ol><li>ls 之后可以看到多出了tem.tar.gz打包压缩文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667545828965-c0baff57-1ee0-4e60-a437-cf2c02802679.png" alt="img"></p><p>下图说明</p><ol><li><code>tar -zxvf temp.tar.gz -C /tmp</code> 将打包压缩文件temp.tar.gz 解包解压缩到 &#x2F;tmp 目录下。</li><li>在&#x2F;tmp目录下，可以看到info&#x2F;initial-setup-ks.cfg&#x2F;xzhdx.txt&#x2F;公共&#x2F; 文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667546227290-8065279a-9108-44c1-97b7-7288696ed9d6.png" alt="img"></p><hr><h3 id="磁盘管理类"><a href="#磁盘管理类" class="headerlink" title="磁盘管理类"></a>磁盘管理类</h3><h4 id="tree-将目录文件以树形式展示"><a href="#tree-将目录文件以树形式展示" class="headerlink" title="tree  将目录文件以树形式展示"></a>tree  将目录文件以树形式展示</h4><p><strong>1）基本语法</strong></p><p><code>yum install tree</code>  首先在Linux系统中，安装tree这个插件，按照提示 y即可</p><p><code>tree ./</code>   将本目录以树的形式展示出来</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667547058826-185770d8-d322-4cc8-886c-5b1eba87d0af.png" alt="img"></p><h4 id="du-查看文件和目录占用的磁盘空间"><a href="#du-查看文件和目录占用的磁盘空间" class="headerlink" title="du 查看文件和目录占用的磁盘空间"></a>du 查看文件和目录占用的磁盘空间</h4><p>du:  disk usage 磁盘占用情况</p><p><strong>1）基本语法</strong></p><p>​<code>du 目录/文件</code> (显示目录下每个子目录对的磁盘使用情况)</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr><tr><td>-a</td><td>不仅查看子目录大小，还要包括文件</td></tr><tr><td>-c</td><td>显示所有的文件和子目录大小后，显示总和</td></tr><tr><td>-s</td><td>只显示总和</td></tr><tr><td>–max-depth&#x3D;n</td><td>指定统计子目录的深度为第 n 层</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23197095/1667547788923-6847dcb4-42cc-49bb-9396-86c0a1b39725.png" alt="img"></p><p>下图说明</p><ol><li><code>du --max-depth=1 -ah </code>   按照文件的一级目录统计占用磁盘大小，最后汇总总占用多少 166M</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667547803253-d47b04fe-f6f8-45c0-a97e-6d3558125ab8.png" alt="img"></p><h4 id="df-查看磁盘空间使用情况"><a href="#df-查看磁盘空间使用情况" class="headerlink" title="df  查看磁盘空间使用情况"></a>df  查看磁盘空间使用情况</h4><p>df  disk free 空余磁盘</p><p><strong>1）基本语法</strong></p><p>​<code>df [选项]</code>   列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占用情况</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-h</td><td>以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667619780722-bd77d9b5-cad8-4d5b-8d58-0b79c551ff3e.png" alt="img"></p><p><code>free -h</code>  显示内存的使用情况，包括实际内存和虚拟交换的内存</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667620475703-f5c9d536-f2bc-4ddc-a968-cdd656c8205f.png" alt="img"></p><h4 id="lsblk-查看设备挂载信息"><a href="#lsblk-查看设备挂载信息" class="headerlink" title="lsblk  查看设备挂载信息"></a>lsblk  查看设备挂载信息</h4><p><strong>1）基本语法</strong></p><p>​<code>lsblk</code>   查看设备挂载情况</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>查看详细的设备挂载情况，显示文件系统信息</td></tr></tbody></table><p>下图说明</p><ol><li>lsblk  查看设备挂载信息情况。sda的来源取决于使用何种硬盘介质。如果是IPE类型的硬盘，则叫hda&#x2F;hdb&#x2F;hdc 以此类推。如果是SATA、SCSI类型的硬盘，则叫sda&#x2F;sdb&#x2F;sdc以此类推</li><li>sr0 是光盘镜像</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667621005245-228a31bf-acf2-4902-8915-a13ef5d801a6.png" alt="img"></p><p>下图说明</p><ol><li><p>lsblk</p></li><li><p>lsblk -f  会比上一条命令显示更多信息</p></li><li><ol><li>xfs 是文件系统类型格式</li><li>UUID  是系统为当前每一个分区分配的唯一标识符  40位</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667621221565-4e9bcb8d-b2f9-430f-bc8f-8e950fb6afea.png" alt="img"></p><h4 id="mount-umount-挂载-卸载"><a href="#mount-umount-挂载-卸载" class="headerlink" title="mount &#x2F; umount 挂载 &#x2F; 卸载"></a>mount &#x2F; umount 挂载 &#x2F; 卸载</h4><p>​         对于Linux用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根目录、一个独立且唯一的文件结构</p><p>​        Linux中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，他的整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623293103-9eb5a5f3-5091-4a80-82d3-3f0ea9a7f13d.png" alt="img"><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623312509-d981e5a9-8f45-4144-9e99-993f4320b77d.png" alt="img"></p><p>设置完成之后，可以查看文件挂载的路径 </p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623381022-24dbd4be-35b1-4a9b-9a4f-2d0d9cfd37a8.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623532664-affdbb11-1925-459e-8b82-8f43520d9510.png" alt="img"></p><p>挂载</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623679251-68fa1820-2174-45cc-a8a8-19728bc2cbba.png" alt="img"></p><p>卸载</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667623719566-60fc2459-4c53-4525-9a07-2bc079079aa8.png" alt="img"></p><p>设置开机自启动挂载</p><p><code>vim /etc/fstab</code></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667624015271-702dbfdb-42ee-46ab-8d3a-a12a1cc2ad63.png" alt="img"></p><p>进入vim编辑之后</p><p>黄色部分是手动写的</p><p>&#x2F;dev&#x2F;cdrom 是挂载文件目录路径 </p><p>&#x2F;mnt&#x2F;cdrom 是挂载点</p><p>iso9660  是文件类型</p><p>defaults</p><p>0  是是否开启备份</p><p>0 是 不做文件系统检查 fsck. 1 2 3 设置优先级，1最高</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667624227767-97c42874-f2e3-4de7-a4e8-21a77eb47ba2.png" alt="img"></p><h4 id="fdisk-分区"><a href="#fdisk-分区" class="headerlink" title="fdisk  分区"></a>fdisk  分区</h4><p>该命令必须在root用户下才能使用</p><p><strong>1）基本语法</strong></p><p>​<code>fdisk -l</code>   查看磁盘分区详情<br>​<code>fdisk 硬盘设备名</code>  对新增因公安进行分区操作</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-l</td><td>显示所有硬盘的分区列表</td></tr></tbody></table><p>下图说明</p><ol><li>fdisk &#x2F;dev&#x2F;sdb   将sdb磁盘分区</li><li>n  添加一个新的分区；q 不保存退出；w 保存退出；p 打印分区表信息</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667804038236-74f576a2-bd04-4438-8d24-35581a4f9754.png" alt="img"></p><p>下图说明</p><ol><li>接上图，输入n 之后，会提示是创建p 主分区还是 e 扩展分区</li><li>Linux中，只能有4个主分区，如果额外添加分区，则将第四个主分区分为第5-16个扩展分区。总计4个主分区，12个扩展分区</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667804424554-ac74defa-c6e6-461f-b785-416c57237b1a.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667792545341-caecf58e-0a98-47a1-a0fa-74062f6951a7.png" alt="img"></p><p><code>mkfs -t xfs /dev/sdb1</code>  格式化磁盘，格式化磁盘之后，才能挂载使用该磁盘</p><p>mkfs创建系统文件 -t文件格式类型<br><code>mount /dev/sdb1 /home/atguigu/</code>   将20G的sdb1新硬盘挂载到atguigu下<br><code>umount /home/atguigu</code>             卸载sdb1硬盘，解除与&#x2F;home&#x2F;atguigu的目录关系</p><hr><h3 id="进程管理类"><a href="#进程管理类" class="headerlink" title="进程管理类"></a>进程管理类</h3><p>​进程是正在执行得给程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源</p><h4 id="ps-查看当前系统进程状态"><a href="#ps-查看当前系统进程状态" class="headerlink" title="ps  查看当前系统进程状态"></a>ps  查看当前系统进程状态</h4><p>ps:  process status 进程状态</p><p><strong>1）基本语法</strong></p><p>​<code>ps aux | grep xxx</code>   查看系统中所有进程</p><p>​<code>ps -ef | grep xxx</code>   可以查看子父进程之间的关系</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>列出带有终端的所有用户的进程</td></tr><tr><td>x</td><td>列出当前用户的所有进程，包括没有终端的进程</td></tr><tr><td>u</td><td>面向用户友好的显示风格</td></tr><tr><td>-e</td><td>列出所有进程</td></tr><tr><td>-u</td><td>列出某个用户关联的所有进程</td></tr><tr><td>-f</td><td>显示完整格式的进程列表</td></tr></tbody></table><p><strong>3）功能说明</strong></p><ol><li>PID：进程的ID号。    PPID：PID对应的父进程</li><li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li><li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li><li>VSZ：该进程占用虚拟内存的大小，单位KB</li><li>RSS：该进程占用实际物理内存的大小，单位是KB</li><li>TTY：该进程是在哪个终端中运行的。对于CentOS来说，tty1是图像化终端，tty2-tty6是本地的字符界面终端。pts&#x2F;0-255代表虚拟终端</li><li>STAT：进程状态。常见的状态有：R 运行状态；S 睡眠状态； T 暂停状态 ；Z 僵尸状态 ；s 包含子进程；l 多线程；+ 前台显示；&lt; 当前进程优先级很高；N 当前进程优先级较低</li><li>START：该进程的启动时间</li><li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li><li>COMMAND：产生此进程的命令名</li></ol><p>如果想要查看进程的CPU占用率和内存占用率，可以使用 <code>ps aux</code></p><p>如果想看进程的父进程ID，可以使用 <code>ps -ef</code></p><h4 id="kill终止进程"><a href="#kill终止进程" class="headerlink" title="kill终止进程"></a>kill终止进程</h4><p><strong>1）基本语法</strong></p><p><code>kill [选项] 进程号</code>    通过进程号杀死进程</p><p><code>killall  进程名称</code>     通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢的时候很有用</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-9</td><td>表示强迫进程立即停止</td></tr></tbody></table><h4 id="pstree-查看进程树"><a href="#pstree-查看进程树" class="headerlink" title="pstree  查看进程树"></a>pstree  查看进程树</h4><p><strong>1）基本语法</strong></p><p>pstree [选项]</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-p</td><td>显示进程的 PID</td></tr><tr><td>-u</td><td>显示进程的所属用户</td></tr></tbody></table><p>下图说明</p><ol><li>pstree | less  分页查看进程树</li><li>找到sshd远程登录。首先Linux系统开启时，sshd系统守护进程会自启动，之后开启一个远程服务登录sshd会启动，在这个远程登录的页面中启动bash命令界面，在bash中输入了less pstree命令</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667815653233-258f6a2e-7dd7-4606-ba1a-44135949631f.png" alt="img"></p><h4 id="top-实时监控系统进程状态"><a href="#top-实时监控系统进程状态" class="headerlink" title="top  实时监控系统进程状态"></a>top  实时监控系统进程状态</h4><p><strong>1）基本语法</strong></p><p>top [选项]</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒更新。默认是3秒在top命令的交互模式当中可以执行的命令</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控进程ID来仅仅监控某个进程的状态</td></tr></tbody></table><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以CPU使用率排序，默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出top</td></tr></tbody></table><p>下图说明</p><p>​1.上面是整体系统运行状态</p><ol><li>a.</li></ol><p>​2.下面是具体进程运行状态</p><ol><li><ol><li>PID：当前进程ID</li><li>USER：哪个用户的进程</li><li>PR：当前系统任务调度的优先级</li><li>NI：用户指定的nice值（nice值越小）</li><li>VIRT：虚拟内存占用的大小</li><li>RES：实际内存，物理内存使用大小</li><li>SHR：共享内存</li><li>S：status状态</li><li>%CPU：CPU计算时间的占比</li><li>%MEM：内存的占比</li><li>TIME+：精确到0.01秒的已经占用到cpu的总时间</li><li>COMMAND：调用当前进程的命令是什么</li></ol></li></ol><p>​3.下图默认是按照CPU占用排序的，如果按<code>shift＋m</code> 是按照内存占用大小排序的。<code>shift+p</code> CPU排序。上下键 pageUP&#x2F;pageDown可以翻页。q退出</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667816821658-21caab83-35d2-44f6-ab19-59f9765a4854.png" alt="img"></p><blockquote><p>1.在输入top命令之后，输入u 可以指定用户显示进程；输入k可以杀死指定进程，接着发送9信号，就是杀死进程。</p><p>2.top -p 4910 表示只查看4910这个进程的信息</p></blockquote><h4 id="netstat-显示网络状态和端口占用信息"><a href="#netstat-显示网络状态和端口占用信息" class="headerlink" title="netstat  显示网络状态和端口占用信息"></a>netstat  显示网络状态和端口占用信息</h4><p><strong>1）基本语法</strong></p><p><code>netstat -anp | grep 进程号</code>     查看该进程网络信息<br><code>netstat -nlp | grep 端口号</code>     查看网络端口号占用情况</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示所有正在监听（listen）和未监听的套接字（socket）</td></tr><tr><td>-n</td><td>拒绝显示别名，能显示数字的全部转化成数字</td></tr><tr><td>-l</td><td>仅列出在监听的服务状态</td></tr><tr><td>-p</td><td>表示显示哪个进程在调用</td></tr></tbody></table><ol><li><p>套接字&#x3D;ip+端口     端口（ 0-65535）</p></li><li><p>介绍下面的含义</p></li><li><ol><li>Proto：网络传输协议</li><li>Recv-Q：已经接收到的但是还没拷贝的字节数</li><li>Send-Q：已经发出去了但是远程的主机还没有确认收到的字节数</li><li>Local Address：本地地址</li><li>Foreign Address：远程地址</li><li>State：进程状态</li><li>PID&#x2F;Program name：进程ID名字和进程名字</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667874210230-dfb5cefe-cd2a-432d-af8b-8fe4ccf1240c.png" alt="img"></p><h4 id="crontab-系统定时任务"><a href="#crontab-系统定时任务" class="headerlink" title="crontab  系统定时任务"></a>crontab  系统定时任务</h4><p><strong>服务管理</strong></p><p>重新启动 crond 服务</p><p>systemctl restart crond</p><p>定时任务设置</p><p><strong>1）基本语法</strong></p><p>crontab [选项]</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>编辑crontab定时任务</td></tr><tr><td>-l</td><td>查询crontab任务</td></tr><tr><td>-r</td><td>删除当前用户素有的crontab任务</td></tr></tbody></table><p>进入crontab编辑界面，会打开vim编辑你的定时任务时间设置</p><p>***** 执行的任务</p><ol><li>*       一小时当中的第几分钟，0–59</li><li>*      一天当中的第几个小时，0–23</li><li>*      一个月当中的第几天， 1–31</li><li>*      一年当中的第几个月，1–12</li><li>*      一周当中的星期几，0–7（0和7都代表周日）</li></ol><p>特殊符号</p><p>*      ——&gt;  代表任何时间。比如第一个 * 就代表一个小时中每分钟都执行一次的意思</p><p>，    ——&gt;  代表不连续的时间。比如“0 8，12，16***”代表在每天的8点0分，12点0分，16点0分都执行一次</p><p>-      ——&gt;  代表连续的时间范围。比如“0 5 ** 1-6”代表在周一到周六的凌晨5点0分执行任务</p><p><em>&#x2F;n   ——&gt;  代表每隔多久执行一次。比如“</em>&#x2F;10****”代表每隔10分钟就执行一遍命令</p><p>下图说明</p><ol><li>crontab -l     查看所有定时任务</li><li>crontab -e    编辑定时任务，内容见下图。 <em>&#x2F;1</em>***echo “hello,world”  &gt;&gt; &#x2F;root&#x2F;hello</li></ol><p>每一分钟输出hello，world在&#x2F;root&#x2F;hello文件中</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667878993467-7430e4be-598f-4807-8175-44abd645802c.png" alt="img"></p><ol><li>cat hello  查看文件内容</li><li>tail -f hello  实时监控查看</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667876652468-f0438464-71e8-4de0-ba71-9156642f4f7b.png" alt="img"></p><hr><h1 id="软件包管理"><a href="#软件包管理" class="headerlink" title="软件包管理"></a>软件包管理</h1><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><h4 id="RPM概述"><a href="#RPM概述" class="headerlink" title="RPM概述"></a>RPM概述</h4><p>​RPM(RedHat Package Manager),RedHat软件包管理工具，是Linux这系列操作系统里的打包安装工具，它虽然是RedHat的标志，但理念是通用的。</p><h4 id="查询命令-rpm-qa"><a href="#查询命令-rpm-qa" class="headerlink" title="查询命令(rpm -qa)"></a>查询命令(rpm -qa)</h4><p><strong>1）基本语法</strong></p><p><code>rpm -qa</code>    查询所安装的所有rpm软件包</p><p>由于软件包比较多，一般都会采用过滤。 rpm -qa | grep rpm软件包</p><p>下图说明</p><ol><li><code>rpm -qa | grep firefox</code>   查询安装的Firefox软件信息</li><li><code>rpm -qi firefox</code>   详细查询安装的Firefox软件信息</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667888952612-d88f8abb-6c87-4613-908b-fdf3c279083a.png" alt="img"></p><h4 id="RPM卸载命令"><a href="#RPM卸载命令" class="headerlink" title="RPM卸载命令"></a>RPM卸载命令</h4><p><strong>1）基本语法</strong></p><p><code>rpm -e RPM软件包名</code>   卸载指定的软件包</p><p><code>rpm -e --nodeps</code>     卸载软件时，不检查依赖。</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>卸载软件包</td></tr><tr><td>–nodeps</td><td>卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件</td></tr></tbody></table><p><strong>3）实际操作</strong></p><p><code>rpm -e firefox</code></p><h4 id="RPM安装命令-rpm-ivh"><a href="#RPM安装命令-rpm-ivh" class="headerlink" title="RPM安装命令(rpm -ivh)"></a>RPM安装命令(rpm -ivh)</h4><p><strong>1）基本语法</strong></p><p><code>rpm -ivh RPM包全名</code></p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-i</td><td>install，安装</td></tr><tr><td>-v</td><td>–verbose,显示详细信息</td></tr><tr><td>-h</td><td>–hash,进度条</td></tr><tr><td>–nodeps</td><td>安装前不检查依赖</td></tr></tbody></table><p>下图解释</p><ol><li>首先Linux的镜像是需要挂载的，然后找到这个镜像的文件夹中的packages目录，ls | grep firefox筛选出火狐浏览器的安装包</li><li>rpm -ivh firefox-68.10.0-1.el7.centos.x86-64.rpm  安装火狐浏览器，下面会显示安装进度</li></ol><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667889610497-e2cdf822-cb05-475c-8339-63cea258128f.png" alt="img"></p><hr><h3 id="YUM仓库配置"><a href="#YUM仓库配置" class="headerlink" title="YUM仓库配置"></a>YUM仓库配置</h3><h4 id="YUM概述"><a href="#YUM概述" class="headerlink" title="YUM概述"></a>YUM概述</h4><p>YUM（Yellow dog Updater,Modified）是一个在Fedora和RedHat以及CentOS中的shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无需频繁的一次性下载、安装。</p><p><img src="https://cdn.jsdelivr.net/gh/nywave/image_hosting/notes_img/1667892147333-641864ec-7642-4d6b-8fee-1204a443a996.png" alt="img"></p><h4 id="YUM的常用命令"><a href="#YUM的常用命令" class="headerlink" title="YUM的常用命令"></a>YUM的常用命令</h4><p><strong>1）基本语法</strong></p><p>yum [选项] [参数]</p><p><strong>2）选项说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-y</td><td>对所有提问都回答”yes”</td></tr></tbody></table><p><strong>3）参数说明</strong></p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>install</td><td>安装rpm软件包</td></tr><tr><td>update</td><td>更新rpm软件包</td></tr><tr><td>check-update</td><td>检查是否有可用的更新rpm软件包</td></tr><tr><td>remove</td><td>删除指定的rpm软件包</td></tr><tr><td>list</td><td>显示软件包信息</td></tr><tr><td>clean</td><td>清理yum过期的缓存</td></tr><tr><td>deplist</td><td>显示yum软件包的所有依赖关系</td></tr></tbody></table><h4 id="修改网YUM源"><a href="#修改网YUM源" class="headerlink" title="修改网YUM源"></a>修改网YUM源</h4><p>​默认的系统yum源，需要连接国外apache网站，网速比较慢，可以修改关联的网络YUM源位国内镜像的网站，比如网易163，aliyun等</p><p>1.安装wget，wget用来从指定的URL下载文件</p><p><code>yum install wget</code></p><p>2.在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录下，备份默认的repos文件</p><blockquote><p>进入&#x2F;etc&#x2F;yum.repos.d目录下</p></blockquote><p><code>cp CentOS-Base.repo CentOS-Base.repo.backup</code></p><p>3.下载网易163或是aliyun的repos文件，任选其一</p><p><code>wget http://mirrors.aliyun.com/repo/CentOS-7.repo</code>         阿里云</p><p><code>wget http://mirrors.163.com/.help/CentOS7-Base-163.repo</code>   网易163</p><p>4.使用下载好的repos文件替换默认的repos文件</p><p>用CentOS7-Base163.repo替换CentOS-Base.repo</p><p><code>mv CentOS7-Base-163.repo CentOS-Base.repo</code></p><p>5.清理就缓存数据，缓存新数据</p><p><code>yum clean all</code><br><code>yum makecache</code>   就是把服务器的包信息下载到本地电脑缓存起来</p><p>6.测试</p><p><code>yum list | grep firefox</code>   查看当前是否安装了firefox相关的软件<br><code>yum -y install firefox</code>    如果没有的话，yum方式安装</p><hr><h1 id="克隆虚拟机"><a href="#克隆虚拟机" class="headerlink" title="克隆虚拟机"></a>克隆虚拟机</h1><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux概述&quot;&gt;&lt;a href=&quot;#Linux概述&quot; class=&quot;headerlink&quot; title=&quot;Linux概述&quot;&gt;&lt;/a&gt;Linux概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/nywave/image</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="系统" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/12/03/hello-world/"/>
    <id>http://example.com/2022/12/03/hello-world/</id>
    <published>2022-12-03T07:42:54.000Z</published>
    <updated>2023-08-05T05:56:29.902Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
